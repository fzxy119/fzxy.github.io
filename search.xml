<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ISO8601标准时间格式</title>
    <url>/2022/01/13/Knowledge/iso8601date/</url>
    <content><![CDATA[<p>国际标准化组织的国际标准ISO8601是日期和时间的表示方法，全称为《数据存储和交换形式·信息交换·日期和时间的表示方法》。目前是第二版ISO8601:2000以替代第一版ISO8601:1988。</p>
<p><strong>日期表示法</strong></p>
<p>年由4位数组成，以公历公元1年为0001年，以公元前1年为0000年，公元前2年为-0001年，其他以此类推。应用其他纪年法要换算成公历，但如果发送和接受信息的双方有共同一致同意的其他纪年法，可以自行应用。</p>
<p><strong>日历日期表示法</strong></p>
<p>年为4位数，月为2位数，月中的日为2位数，例如2004年5月3日可写成2004-05-03或20040503。</p>
<p><strong>顺序日期表示法</strong></p>
<p>可以将一年内的天数直接表示，平年365天，闰年366天。如2004年5月3日可以表示为2004-157或2004157</p>
<p><strong>日历星期和日表示法</strong></p>
<p>可以用2位数表示本年内第几个日历星期，再加上一位数表示日历星期内第几天，但日历星期前要加上一个大写字母W，如2004年5月3日可写成2004-W17-3或2004W173。但2004-W011是从2004年1月5日开始的，前几天属于上年的第54个日历星期，每个日历星期从星期一开始，星期日为第7天。</p>
<p><strong>日的时间表示法</strong></p>
<p>小时、分和秒都用2位数表示，对UTC时间最后加一个大写字母Z，其他时区用实际时间加时差表示。如UTC时间下午2点30分5秒表示为14:30:05Z或143005Z，当时的北京时间表示为22:30:05+08:00或223005+0800，也可以简化成223005+08。</p>
<p><strong>日期和时间的组合表示法</strong></p>
<p>合并表示时，要在时间前面加一大写字母T，如要表示北京时间2004年5月3日下午5点30分8秒，可以写成2004-05-03T17:30:08+08:00或20040503T093008+08。</p>
<p><strong>时间段表示法</strong></p>
<p>如果要表示某一作为一段时间的时间期间，前面加一大写字母P，但时间段后都要加上相应的代表时间的大写字母。如在一年三个月五天六小时七分三十秒内，可以写成P1Y3M5DT6H7M30S。</p>
<p><strong>重复时间表示法</strong></p>
<p>前面加上一大写字母R，如要从2004年5月6日北京时间下午1点起重复半年零5天3小时，要重复3次，可以表示为R3/20040506T130000+08/P0Y6M5DT3H0M0S。</p>
]]></content>
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>标准</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做规划</title>
    <url>/2021/09/15/Knowledge/guihua/</url>
    <content><![CDATA[<p><u><em><strong>做事先规划是做事的一种方式</strong></em></u></p>
<h2 id="应该学会规划"><a href="#应该学会规划" class="headerlink" title="应该学会规划"></a>应该学会规划</h2><p style="text-indent:2em">
由于早起工作的态度问题，在接到任务后就总是凑齐技术要素，知道别人要什么就着手开始做，并能很快的完成并交付任务，这是一种被动接受的心态，有时也做规划，但是规划的层次比较低，面向的都是结果。时间如梭，多年后发现，高层次规划是提升和锻炼自己很有效的方法，思考问题的方式从如何完成目标任务，到了解事件背景，解决什么问题，再到深层次目标，输入的问题更多，你做的规划方案也就不一样，技术选型也不一样，架构设计也不一样。
</p>
<p style="text-indent:2em">
规划是输入问题经过思考后并给出解决问题实行方案的过程的结果，这个过程是通用的，是需要经过低层次规划到高层次规划锻炼才能熟练的，并且可以适用到大事小事，个人或者团队的事。
</p>
<span id="more"></span>

<h2 id="规划具有重要的意义"><a href="#规划具有重要的意义" class="headerlink" title="规划具有重要的意义"></a>规划具有重要的意义</h2><h4 id="聚焦目标"><a href="#聚焦目标" class="headerlink" title="聚焦目标"></a>聚焦目标</h4><p style="text-indent:2em">
规划的一个最为重要的作用就是让目标更清晰。团队里的人知道要做什么，有一部分人觉得迷茫，很大程度是目标不清楚，好像知道要做什么事，又不知道如何下手。这个目标可大可小，小的方面就是要完成一个项目或一个需求，大的方面就是要建立一套体系。笔者曾经就有这样的切身经历，有一段时间显得非常迷茫，不知道自己要做什么，人一迷茫就会焦虑。一旦有这样的状态，就要思考是不是目标不够清晰，目标度量是不是不够细。当目标明确之后，大家"心向一处想，劲往一处使"，这样的工作状态效率是非常高的，团队的氛围也是非常好的。
</p>

<h4 id="洞察背后逻辑"><a href="#洞察背后逻辑" class="headerlink" title="洞察背后逻辑"></a>洞察背后逻辑</h4><p style="text-indent:2em">
规划出来的内容是结果，最为重要的是思考为什么要做这些事，背后的逻辑才是核心。分析当前的现状、痛点、业界发展状况……结合业务本身，去做一些决策、取舍。不同的人思考出发点不一样，大家在一起碰撞时，会有一些想法闪现出来，也是思想的交流。我们做事不仅仅要懂得how，更要懂得why，当把why讲清楚之后，how也就是水到渠成的事，往往我们的一个困惑是不知道why。
</p>

<h4 id="知晓未来方向"><a href="#知晓未来方向" class="headerlink" title="知晓未来方向"></a>知晓未来方向</h4><p style="text-indent:2em">
规划有短期规划，也有长期规划，一般笔者是先思考长期规划，思考3年之后，我们要具备怎样的能力，再回到短期上，我们当下这个阶段要做到怎样的程度。有些事不紧急，但很重要，可以放晚一点做；有的事非常重要，又非常紧急，优先级就要提高。当我们知道了方向之后，即使当下没有去做一些事，也知道将来我们要做成什么样。以笔者的过往经历，一个团队有一两年的长远规划，团队里的成员达成共识之后，这个团队在一两年内是稳定的，因为大家知道两年之后我们会做成什么样，远方一直有一个目标在照亮着我们，大家一起努力不断逼近那个目标。
</p>
<img src="/2021/09/15/Knowledge/guihua/640.webp" class="" title="规划">


<h2 id="规划的两种思维"><a href="#规划的两种思维" class="headerlink" title="规划的两种思维"></a>规划的两种思维</h2><h4 id="归纳思维"><a href="#归纳思维" class="headerlink" title="归纳思维"></a>归纳思维</h4><p style="text-indent:2em">规划使用的第一种思维是归纳法。这是大家最常用的方法，一般是从现状出发，思考当下有哪些问题、业界是怎么做的，从这些输入中去归纳我们需要去做什么。比如当下工单咨询比较多，那么就需要对工单进行分类，如归纳成产品设计问题、程序代码问题、依赖方问题、交互设计问题，针对每类问题，再去思考我们应该要做到哪些工作。在店铺平台建设中的规划中，我们就梳理了当下的一些痛点问题，如平台只有一些基础的能力，没有给业务方提供强大的能力支撑，那么接下来就要加强店铺能力建设，丰富店铺能力。</p>
<p style="text-indent:2em">归纳思维有一个缺点就是就事论事，解决了表层的问题，比如竞品有什么，我们没有该项能力，是不是我们就要去做同样的事。归纳思维要配合深度思考一起做规划设计，真正挖掘出我们当下的痛点是什么，比如一个工单，用户只会提出他遇到了什么问题，此时就要深入分析它的root cause，有的时候只需要一个清晰的提示文案就可能解决用户的问题。</p>

<h4 id="演绎思维"><a href="#演绎思维" class="headerlink" title="演绎思维"></a>演绎思维</h4><p style="text-indent:2em">规划使用的第二种思维是演绎思维。演绎思维是一种更高级的思维模式，它需要一个人对事物有非常深刻的认识，当洞察出了底层的规律之后，再去思考我们要做什么。一般的人并不习惯用这种思维模式，它对人的要求非常高，一旦掌握之后，规划也就容易得多，很多科学家更偏向使用演绎思维。</p>
<p style="text-indent:2em">在店铺规划中，笔者就运用了演绎的思维。比如在规划之前，笔者就思考两个问题：店铺的本质是什么、店铺要提供的商业价值是什么。当把这两个问题想清楚之后，沿着价值方向去思考我们应该要给用户提供怎样的能力，这是一步一步推导出来的。店铺的本质是一个"场"，它连接了卖家和买家。针对这两种角色，卖家最为关注的是怎么使用得好店铺，包含使用得爽、店铺转化好；买家最为关注的是怎么通过最少的钱、最少的时间买到心仪的商品。沿着卖家和买家关注点，继续思考我们怎么让卖家用得爽、用得好呢？其中一个点是我们要知道卖家现在有哪些不好的体验，一定要能度量得出来，而不是定性地去分析，当定量地度量出体验指标之后，这样就可以非常有针对性地去做一些体验优化工作。站在买家的角度，可以给买家一些优惠，让他更愿意购物，这也即是我们规划店铺营销的初衷。</p>

<img src="/2021/09/15/Knowledge/guihua/641.webp" class="" title="规划">





<blockquote><footer><strong>阿里技术</strong><cite><a href="https://mp.weixin.qq.com/s/LILm--w9vj_K7qjI4EakBw">如何做规划？分享2种思维和4个方法</a></cite></footer></blockquote>
]]></content>
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>软件过程模型之RUP</title>
    <url>/2023/11/25/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E4%B9%8BRUP/</url>
    <content><![CDATA[<p>&emsp;&emsp; RUP (Rational Unified Process).Rational 公司提出的统一软件过程，Unified 说RUP是最佳开发经验总结，Process说明 RUP是一个软件开发过程。</p>
<p>软件的生命周期：</p>
<p>&emsp;&emsp; 软件的生命周期是一个软件从无到有再到消亡，经过的生命各个阶段，软件的生命周期有通用的生命周期，但是不同的场景，不同的开发方法可能会进行不同的裁剪，一般情况下软件的生命周期有</p>
<ol>
<li>问题定义，</li>
<li>可行性分析，</li>
<li>需求分析，</li>
<li>概要设计，</li>
<li>详细设计，</li>
<li>软件实现，</li>
<li>测试验收部署，</li>
<li>运行与维护，</li>
<li>消亡。</li>
</ol>
<p>&emsp;&emsp;RUP是一种软件过程模型，定义了我们在开发周期内的不同阶段、及在各个阶段内参与的人，从事的活动及产出物，那么这种开发过程的总结是一种经验性方法总结，可以指导我们如何能够明确的、有条不紊、高效的软件开发。</p>
<h3 id="RUP将软件开发周期了四个阶段："><a href="#RUP将软件开发周期了四个阶段：" class="headerlink" title="RUP将软件开发周期了四个阶段："></a>RUP将软件开发周期了四个阶段：</h3><blockquote>
<p>1.初始化阶段：定义最终产品视图和业务模型，并确定系统范围</p>
</blockquote>
<blockquote>
<p>2.细化阶段：设计及确定系统的体系结构，确定工作计划及资源要求。</p>
</blockquote>
<blockquote>
<p>3.构建阶段：构造产品并继续演进需求，体系结构，计划直至产品提交。</p>
</blockquote>
<blockquote>
<p>4.交付阶段：把产品交付给用户使用</p>
</blockquote>
<p><em>RUP定义的4个过程组成了一个周期，那么在整个软件开发过程中，RUP的4个过程是一直进行迭代增量的，每次迭代都会演化为产品的下一代产品。直至产品交付和消亡</em></p>
<p>&emsp;&emsp;RUP有三个显著的特点：用例驱动，以系统架构为中心，迭代与增量。他们是RUP解决问题的方式及方法。</p>
<h4 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h4><p>&emsp;&emsp;初始化阶段他包含了软件生命周期中问题的定义，需求的分析，并完成系统定位及范围，最终生成产品视图、业务模型、及系统范围。此阶段中我们一般从事 RUP中定义的 业务建模活动，需求分析活动，业务建模是理解待开发所在机构及其商业活动运作，确保所有参与人员对待开发系统所在的机构，有共同的认识，待开发系统对所在机构的影响。</p>
<p><strong>&emsp;&emsp;在初始化阶段，必须识别出所有与系统交互的外部实体，定义系统与外部实体交互的特性，在这个阶段中所关注的是整个项目的业务和需求方面的主要风险，对建立在原有系统基础上的开发项目来说，初始化阶段可能很短。</strong></p>
<p>此阶段我们需要完成<br>1：业务流程模型的建立，流程模型可以是文档描述，也可以使用图形表述，无论何种方式使大家能够对业务有一个清醒的统一的认识是主要目的:<br>2：完成系统与外部实体，交互关系图，及交互方式定义。<br>3：完成系统与外部系统职责，及确定系统的范围</p>
<h4 id="细化阶段"><a href="#细化阶段" class="headerlink" title="细化阶段"></a>细化阶段</h4><p>&emsp;&emsp;设计及确定系统的体系结构，确定工作计划及资源要求。软件体系结构刻画了系统的整体结构，它去掉了细节部分，突出了系统的重要特征。<br>软件体系结构的设计与代码设计无关，不依赖于程序设计语言，软件体系结构是软件设计过程中的一个层次，体系结构的设计需要考虑多方面问题。<br>在功能性特征方面要考虑系统的功能，非功能性特征方面要考虑系统性能，安全性和可用性等。<br>软件开发有关的特征需要考虑可修改性，可移植性，可重用性，可集成性，可测试性<br>开发经济学有关的特征需要考虑，开发时间，费用，系统生命周期，</p>
<p>&emsp;&emsp;设对于一个软件系统，不同人员所关心的内容是不一样的，因此软件的体系结构是一个多维的结构，也就是说会采用多个视图来描述软件体系结构。<br>如：对于一座大厦，对于大厦建设和维护人员来说，会用电线布线结构，有些人会用电梯布局结构，有些人会用水管布局结构。</p>
<p>&emsp;&emsp;在RUP总采用4+1 视图模型来描述软件体系结构，用例图，逻辑图，实现图，进程图，部署图。<br>分析人员和测试人员关心的是系统行为，因此会侧重于用例视图，用户关心的是系统功能，会侧重于逻辑视图，程序人员关心的是系统配置和装配问题，侧重于实现视图，<br>系统集成人员关心系统的可伸缩性，吞吐率等问题，因此侧重于进程视图，系统工程师关心系统的发布，安装，拓扑，侧重于部署图。</p>
<p>RUP定义的9中活动：业务建模，需求，分析设计，实现，测试，部署，配置与变更管理，项目管理，环境<br>RUP中的核心概念：角色 Role,活动 Activity 制品 Artifact 工作流 workflow</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>过程模型</tag>
      </tags>
  </entry>
  <entry>
    <title>项目管理相关文件</title>
    <url>/2022/01/06/Knowledge/xmglwenjian/</url>
    <content><![CDATA[<h3 id="项目章程"><a href="#项目章程" class="headerlink" title="项目章程"></a>项目章程</h3><ul>
<li><p>项目目的</p>
</li>
<li><p>可测量的项目目标和相关成功标准</p>
</li>
<li><p>高层及需求</p>
</li>
<li><p>高层级项目描述，边界定义及主要可交付成果</p>
</li>
<li><p>整体项目风险</p>
</li>
<li><p>总体里程碑进度计划</p>
</li>
<li><p>预算批准的财务资源</p>
</li>
<li><p>主要相关方名单</p>
</li>
<li><p>项目审计要求（用什么标准评价成功，由谁对项目成功下结论，有谁签署项目结束）</p>
</li>
<li><p>项目退出标准（比如，结束或取消项目或阶段前应满足的条件）</p>
</li>
<li><p>委派项目经理及其职责和职权</p>
</li>
<li><p>发起人或其他批准项目章程的人员姓名和职权</p>
</li>
</ul>
<h3 id="项目范围说明书："><a href="#项目范围说明书：" class="headerlink" title="项目范围说明书："></a>项目范围说明书：</h3><ul>
<li>项目范围描述（渐进明细）</li>
<li>项目可交付成功</li>
<li>验收标准</li>
<li>项目排除项</li>
</ul>
<h3 id="项目文件："><a href="#项目文件：" class="headerlink" title="项目文件："></a>项目文件：</h3><p>经验教训登记册</p>
<p>需求跟踪矩阵</p>
<p>需求文件</p>
<h2 id="计划类"><a href="#计划类" class="headerlink" title="计划类"></a>计划类</h2><p>项目管理计划：包含各个组件计划</p>
<p>需求管理计划：需求管理计划记录了如何管理项目需求</p>
<p>范围管理计划：范围管理计划记录了如何控制项目和产品范围 如何根据 项目范围说明书创建 WBS</p>
<p>变更管理计划：变更管理计划定义了管理项目变更的过程</p>
<p>配置管理计划：配置管理计划定义了哪些是配置项，哪些配置项需要正式变更控制，以及针对这些配置项的变更控制过程</p>
<p>进度管理计划：是项目管理计划的组成部分，为编制、监督和控制项目进度建立准则和明确活动</p>
]]></content>
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>项目管理相关文件</tag>
      </tags>
  </entry>
  <entry>
    <title>项目管理相关词</title>
    <url>/2021/12/25/Knowledge/xmglword/</url>
    <content><![CDATA[<h3 id="PMO：-项目管理办公室"><a href="#PMO：-项目管理办公室" class="headerlink" title="PMO： 项目管理办公室"></a>PMO： 项目管理办公室</h3><p>Project Management Office 项目管理办公室，项目管理办公室是企业设立的一个职能机构名称，也有的称作项目管理部、项目办公室或项目管理中心等，英文为： Project Management Office ，缩写简称：PMO。</p>
<p>PMO是在组织内部将实践、过程、运作形式化和标准化的部门，是提高组织管理成熟度的核心部门，它根据业界最佳实践和公认的项目管理知识体系，并结合企业自身的业务和行业特点，以此确保项目成功率的提高和组织战略的有效贯彻执行。</p>
<h3 id="PMI：项目管理协会"><a href="#PMI：项目管理协会" class="headerlink" title="PMI：项目管理协会"></a>PMI：项目管理协会</h3><p>PMI（<strong>Project Management Institute</strong>）中文名是项目管理协会，是世界领先的非盈利会员协会的项目管理专业机构 ，1969年成立，在全球185个国家有70多万会员和证书持有人。此外，PMI还是多个英文短语的缩写，较为著名的是采购经理指数PMI。</p>
<h3 id="PMIS-项目管理信息系统"><a href="#PMIS-项目管理信息系统" class="headerlink" title="PMIS:项目管理信息系统"></a>PMIS:项目管理信息系统</h3><p>项目管理信息系统（project management information system，PMIS）是计算机辅助项目管理的工具，为项目目标的实现提供了强有力的帮助</p>
<h3 id="CCB：变更控制委员-会"><a href="#CCB：变更控制委员-会" class="headerlink" title="CCB：变更控制委员 会"></a>CCB：变更控制委员 会</h3><p>CCB(Change Control Board) 在<a href="https://baike.baidu.com/item/CMMI">CMMI</a>(Capability Maturity Model Integration)中，是“<a href="https://baike.baidu.com/item/%E5%8F%98%E6%9B%B4%E6%8E%A7%E5%88%B6%E5%A7%94%E5%91%98%E4%BC%9A/5875484">变更控制委员会</a>”的含义，同时具有配置控制<a href="https://baike.baidu.com/item/%E5%A7%94%E5%91%98%E4%BC%9A/290784">委员会</a>（Configuration Control Board）的含义。</p>
<p>CCB可以由一个小组担任，也可以由多个不同的组担任，负责做出决定究竟将哪些已建议需求变更或新产品特性付诸应用。典型的<a href="https://baike.baidu.com/item/%E5%8F%98%E6%9B%B4%E6%8E%A7%E5%88%B6%E5%A7%94%E5%91%98%E4%BC%9A/5875484">变更控制委员会</a>会同样决定在哪一些版本中纠正哪些错误。</p>
<p>CCB的成员应当能代表变更涉及的团体。其可能包括如下方面的代表：</p>
<p>1.产品或计划管理部门</p>
<p>2.项目管理部门</p>
<p>3.开发部门</p>
<p>4.测试或质量保证部门</p>
<p>5.市场部或客户代表</p>
<p>6.制作用户文档的部门</p>
<p>7.技术支持部门</p>
<p>8.帮助桌面或用户支持热线部门</p>
<p>9.配置管理部门</p>
<h3 id="PMCD：项目经理能力发展框架"><a href="#PMCD：项目经理能力发展框架" class="headerlink" title="PMCD：项目经理能力发展框架"></a>PMCD：项目经理能力发展框架</h3><p>《项目经理能力发展框架》是由美国项目管理协会开发制定，已成为国际标准。它为定义、评估和发展项目经理能力提供了通用指南，构建了项目管理能力的三个关键维度，定义了影响项目经理绩效的关键能力元素。不管项目的属性、类型、规模和复杂度有什么不同，这些能力将使项目经理可以进行跨行业的交流，而且各行业、各组织可以在PMCD框架的基础上建立具有自己特色的能力模型。该标准还对组织能力发展过程的创建提供了指导，帮助组织对其员工的项目管理能力进行持续评估和提升。</p>
<h3 id="SME：领域或主题的专家"><a href="#SME：领域或主题的专家" class="headerlink" title="SME：领域或主题的专家"></a>SME：领域或主题的专家</h3><p>SME，是Subject Matter Expert的缩写，意思是精通某一领域或主题的专家。</p>
<h3 id="WBS-工作分解结构-WBS-实施标准"><a href="#WBS-工作分解结构-WBS-实施标准" class="headerlink" title="WBS:工作分解结构(WBS)实施标准"></a>WBS:工作分解结构(WBS)实施标准</h3><p>定义项目目标以及把工作委派给项目成员是项目经理最重要的工作之一。成功的项目管理要求项目经理完成这项工作。工作分解结构（WBS）就是定义工作并使其符合特定的项目目标的指南。WBS的应用范围可涉及各行各业，它是项目经理的无价工具，可以帮助项目经理完成整个项目生命周期中的众多关键步骤。本书表述了作为项目管理工具的WBS的标准定义及应用方法，包括项目范围定义、构建项目状态和进展报告的基础框架、方便项目经理与项目干系人沟通等内容.</p>
<p>《工作分解结构（WBS）实施标准（第2版）》是2015年10月电子工业出版社出版的图书，作者是强茂山、陈平。</p>
<h3 id="PPP经理："><a href="#PPP经理：" class="headerlink" title="PPP经理："></a>PPP经理：</h3><p>PPP（Public-Private Partnership），又称PPP模式，即政府和社会资本合作，是公共基础设施中的一种项目运作模式。在该模式下，鼓励私营企业、民营资本与政府进行合作，参与公共基础设施的建设。</p>
<p>项目管理7宗罪：</p>
<p>肉包子打狗有去无回，需求给出去，就不再有后续监控跟踪，如何形成闭环，完成任务自行运行</p>
<p>项目任务千丝万缕，如何管理</p>
<p>沟通隔靴搔痒，大部分时间花在了沟通上</p>
<p>需求变换莫测，多变环境如何适应</p>
<p>传统项目管理软件太高冷，普及应用困难。</p>
<p>日志，记录，报告，总结，不堪重负</p>
<p>教训不断重演，经验教训无法形成知识（组织过程资产）   项目结束后经验难以总结，项目过程当中就要进行经验总结</p>
]]></content>
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>项目管理-项目整合管理</title>
    <url>/2021/12/25/Knowledge/xmglxmzh/</url>
    <content><![CDATA[<h3 id="制定项目章程"><a href="#制定项目章程" class="headerlink" title="制定项目章程:"></a>制定项目章程:</h3><p>制定项目章程是编写<u>一份正式批准项目并授权项目经理在项目活动中使用组织资源</u>的文件的过 程。<strong>本过程的主要作用是，明确项目与组织战略目标之间的直接联系，确立项目的正式地位，并展 示组织对项目的承诺。</strong>项目章程在项目执行组织与需求组织之间建立起伙伴关系。在执行外部项目时，通常需要用正式 的合同来达成合作协议。这种情况下，可能仍要用项目章程来建立组织内部的合作关系，以确保正确 交付合同内容。项目章程一旦被批准，就标志着项目的正式启动。在项目中，应尽早确认并任命项目 经理，最好在制定项目章程时就任命，且总应在规划开始之前任命。项目章程可由发起人编制，或者 由项目经理与发起机构合作编制。通过这种合作，项目经理可以更好地了解项目目的、目标和预期效 益，以便更有效地向项目活动分配资源。项目章程授权项目经理规划、执行和控制项目。</p>
<h3 id="制定项目计划"><a href="#制定项目计划" class="headerlink" title="制定项目计划:"></a>制定项目计划:</h3><h3 id="管理项目知识："><a href="#管理项目知识：" class="headerlink" title="管理项目知识："></a>管理项目知识：</h3><p>知识通常分为“<strong>显性知识</strong>”（易使用文字、图片和数字进行编撰的知识）和“<strong>隐性知识</strong>”（个体 知识以及难以明确表达的知识，如信念、洞察力、经验和“诀窍”）两种。知识管理指管理显性和 隐性知识，旨在重复使用现有知识并生成新知识。<strong>有助于达成这两个目的的关键活动是知识分享和 知识集成</strong>（不同领域的知识、情境知识和项目管理知识）。 </p>
<p>一个常见误解是，知识管理只是将知识记录下来用于分享；另一种常见误解是，知识管理只是在 项目结束时总结经验教训，以供未来项目使用。这样的话，只有经编撰的显性知识可以得到分享。 因为显性知识缺乏情境，可作不同解读，所以，虽易分享，但无法确保正确理解或应用。隐性知识 虽蕴含情境，却很难编撰。它存在于专家个人的思想中，或者存在于社会团体和情境中，通常经由 人际交流和互动来分享。 </p>
<p>从组织的角度来看，知识管理指的是确保项目团队和其他相关方的技能、经验和专业知识在项目 开始之前、开展期间和结束之后得到运用。<em>因为知识存在于人们的思想中，且无法强迫人们分享自 己的知识或关注他人的知识</em>，所以，<strong>知识管理最重要的环节就是营造一种相互信任的氛围，激励人 们分享知识或关注他人的知识。如果不激励人们分享知识或关注他人的知识，即便最好的知识管理 工具和技术也无法发挥作用</strong>。在实践中，联合使用**<u>知识管理工具和技术（用于人际互动）以及信息 管理工具和技术</u>**（用于编撰显性知识）来分享知识</p>
<h3 id="监控项目工作："><a href="#监控项目工作：" class="headerlink" title="监控项目工作："></a>监控项目工作：</h3><p>&nbsp; &nbsp; 监控项目工作是跟踪、审查和报告整体项目进展，以实现项目管理计划中确定的绩效目标的过程。本过程的主要作用是，<strong>让相关方了解项目的当前状态并认可<u>为处理绩效问题而采取的行动</u>，以及通过成本和进度预测，让相关方了解未来项目状态</strong>。本过程需要在整个项目期间开展。<br>&nbsp; &nbsp; 监督是贯穿于整个项目的项目管理活动之一，包括收集、测量和分析测量结果，以及预测趋势，以便推动过程改进。<strong>持续的监督使项目管理团队能洞察项目的健康状况，并识别须特别关注的任何方面。控制包括制定纠正或预防措施或重新规划，并跟踪行动计划的实施过程，以确保它们能有效解决问题</strong>。</p>
<p>滚动式规划</p>
<p>滚动式规划是一种迭代式的规划技术，即详细规划近期要完成的工作，同时在较高层级上粗略规 划远期工作。它是一种渐进明细的规划方式，适用于工作包、规划包以及采用敏捷或瀑布式方法的 发布规划。因此，在项目生命周期的不同阶段，工作的详细程度会有所不同。在早期的战略规划阶 段，信息尚不够明确，工作包只能分解到已知的详细水平；而后，随着了解到更多的信息，近期即 将实施的工作包就可以分解到具体的活动</p>
<p>敏捷技术</p>
<p>紧前关系绘图法（PDM）是创建进度模型的一种技术</p>
<p>项目进度网络图</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5>]]></content>
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>项目管理</tag>
      </tags>
  </entry>
  <entry>
    <title>activity5 engine</title>
    <url>/2022/01/05/activity/engine/</url>
    <content><![CDATA[<h3 id="关键词："><a href="#关键词：" class="headerlink" title="关键词："></a>关键词：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">processDefinitionKey：流程定义key</span><br><span class="line">processDefinitionId: 模型部署后生成流程定义ID</span><br><span class="line">businessKey：业务参数</span><br><span class="line">category：用户对自己模型、定义和实例做的分类；</span><br><span class="line">tenantId：租户概念，对应多个系统共享同一个数据库的数据。</span><br></pre></td></tr></table></figure>

<h3 id="数据库配置："><a href="#数据库配置：" class="headerlink" title="数据库配置："></a>数据库配置：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">databaseType：h2, mysql, oracle, postgres, mssql, db2</span><br><span class="line">databaseSchemaUpdate：</span><br><span class="line">	false （default）：在构建过程引擎是，检查数据库模式是否和包版本一致，如果不一致就抛出异常</span><br><span class="line">	true：在构建过程引擎是，如果有必要，将执行检查，并执行模式的更新。如果模式不存在就创建</span><br><span class="line">	create-drop：当创建引擎时候就创建数据库模式，当流程引擎关闭的时候就删除模式</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="历史配置：history"><a href="#历史配置：history" class="headerlink" title="历史配置：history"></a>历史配置：history</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">none：跳过有所有历史数据的归档，此配置会使流程高性能执行，但是不会提供历史信息</span><br><span class="line">activity: 归档所有流程实例和活动实例。在流程实例的末尾，顶级流程实例变量的最新值将被复制到历史变量实例中。没有任何细节将被存档。</span><br><span class="line">audit：这是默认的。它存档所有流程实例、活动实例、不断保持变量值的同步以及提交的所有表单属性，以便所有通过表单进行的用户交互都是可跟踪的，并且可以进行审计</span><br><span class="line">full: 这是历史存档的最高水平，因此也是最慢的。此级别存储审计级别中的所有信息，以及所有其他可能的详细信息，主要是流程变量更新。</span><br></pre></td></tr></table></figure>

<h3 id="表结构："><a href="#表结构：" class="headerlink" title="表结构："></a>表结构：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACT_RE_*: RE stands for repository，表记录着一些静态信息，如流程的定义，流程资源，如图片，规则等</span><br><span class="line">ACT_RU_*: RU stands for runtime，包含流程，任务，参数，任务等等运行时数据，Activity只存储执行中的流程运行时数据，并且当流程结束后将被删除，使运行时表不至于过大，并且执行快速</span><br><span class="line">ACT_ID_*: ID stands for identity  包含一些身份信息，如用户用户组</span><br><span class="line">ACT_HI_*: HI stands for history   包含过去的流程历史数据，如流程实例，任务实例，参数</span><br><span class="line">ACT_GE_*: general  存储多样化数据</span><br><span class="line"></span><br><span class="line">ACT_RU_EXECUTION：</span><br><span class="line">ID_：EXECUTION主键，这个主键有可能和PROC_INST_ID_相同，相同的情况表示这条记录为主实例记录。</span><br><span class="line">REV_：表示数据库表更新次数。</span><br><span class="line">PROC_INST_ID_：一个流程实例不管有多少条分支实例，这个ID都是一致的。</span><br><span class="line">BUSINESS_KEY_:这个为业务主键，主流程才会使用业务主键，另外这个业务主键字段在表中有唯一约束。</span><br><span class="line">PARENT_ID_：这个记录表示父实例ID，如上图，同步节点会产生两条执行记录，这两条记录的父ID为主线的ID。</span><br><span class="line">PROC_DEF_ID_ :流程定义ID</span><br><span class="line">SUPER_EXEC ： 这个如果存在表示这个实例记录为一个外部子流程记录，对应主流程的主键ID。</span><br><span class="line">ACT_ID_：表示流程运行到的节点，如上图主实例运行到的节点ID。</span><br><span class="line">IS_ACTIVE_ : 是否活动流程实例</span><br><span class="line">IS_CONCURRENT_:是否并发。上图同步节点后为并发，如果是并发多实例也是为1。</span><br><span class="line">IS_SCOPE_: 这个字段我跟踪了一下不同的流程实例，如会签，子流程，同步等情况，发现主实例的情况这个字段为1，子实例这个字段为0。</span><br><span class="line">TENANT_ID_ :  这个字段表示租户ID。可以应对多租户的设计。</span><br><span class="line">IS_EVENT_SCOPE: 没有使用到事件的情况下，一般都为0。</span><br><span class="line">SUSPENSION_STATE_： 这个表示是否暂停。</span><br><span class="line">CACHE_ENT_STATE :这个暂时还不明白有什么作用。</span><br><span class="line"></span><br><span class="line">------------------------------------------------------</span><br><span class="line">act_ge_bytearray:通用资源表</span><br><span class="line">act_re_model：模型表</span><br><span class="line">act_re_deployment：部署信息表</span><br><span class="line">act_re_procdef：流程定义表</span><br><span class="line"></span><br><span class="line">act_hi_procinst：启动的流程实例</span><br><span class="line">act_hi_actinst：启动的活动实例</span><br><span class="line"></span><br><span class="line">act_ru_execution：启动的执行记录</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#流程或执行相关参数设置 多条执行并行，通过 getVariableLocal setVariableLocal 来区分，非多执行情况下效果一样</span><br><span class="line">RuntimeService.getVariable</span><br><span class="line">RuntimeService.getVariableLocal</span><br><span class="line">RuntimeService.setVariable</span><br><span class="line">RuntimeService.setVariableLocal</span><br><span class="line"></span><br><span class="line">#任务参数设置，和任务相关，并行任务通过setVariableLocal getVariableLocal来区分，单执行任务效果一样</span><br><span class="line">TaskService.setVariable</span><br><span class="line">TaskService.setVariableLocal</span><br><span class="line">TaskService.getVariable</span><br><span class="line">TaskService.getVariableLocal</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Expressions： Activiti使用UEL进行表达-解析。Uel表示统一表达式语言，是EE6规范的一部分</span><br><span class="line">Activiti uses UEL for expression-resolving，UEL stands for Unified Expression Language and is part of the EE6 specification</span><br><span class="line"></span><br><span class="line">有2中类型的表达式：value-expression and method-expression</span><br><span class="line"></span><br><span class="line">Value expression：值表达式</span><br><span class="line">解析为一个Value值，默认情况下，所有的流程变量是可以使用的，并且所有的springbean也是可以使用的</span><br><span class="line">resolves to a value. By default, all process variables are available to use. Also all spring-beans (if using Spring) are available to use in expressions. Some examples</span><br><span class="line">$&#123;myVar&#125;</span><br><span class="line">$&#123;myBean.myProperty&#125;</span><br><span class="line"></span><br><span class="line">Method expression:方法表达式</span><br><span class="line">调用带有或不带参数的方法。当调用没有参数的方法时，请确保在方法名称之后添加空括号(因为这将表达式与值表达式区分开来)。传递的参数可以是本身解析的文字值或表达式。</span><br><span class="line">invokes a method, with or without parameters. When invoking a method without parameters, be sure to add empty parentheses after the method-name (as this distinguishes the expression from a value expression). The passed parameters can be literal values or expressions that are resolved themselves</span><br><span class="line">$&#123;printer.print()&#125;</span><br><span class="line">$&#123;myBean.addNewOrder(&#x27;orderName&#x27;)&#125;</span><br><span class="line">$&#123;myBean.doSomething(myVar, execution)&#125;</span><br></pre></td></tr></table></figure>

<p>这些表达式支持解析原语(包括比较它们)、bean、列表、数组和映射</p>
<h4 id="在所有进程变量之上，有一些默认对象可用于表达式中默认情况下"><a href="#在所有进程变量之上，有一些默认对象可用于表达式中默认情况下" class="headerlink" title="在所有进程变量之上，有一些默认对象可用于表达式中默认情况下"></a>在所有进程变量之上，有一些默认对象可用于表达式中默认情况下</h4><p>（所有的流程变量是可以使用的，并且所有的springbean也是可以使用的）</p>
<ul>
<li><p><strong>execution</strong>：DelegateExecution，它保存有关正在执行的其他信息。</p>
</li>
<li><p><strong>task</strong>：包含有关当前任务的其他信息的DelegateTask。注意：只在任务侦听器计算的表达式中工作</p>
</li>
<li><p><strong>authenticatedUserId</strong>：当前已通过身份验证的用户的id。如果没有对用户进行身份验证，则变量不可用。</p>
</li>
</ul>
<p><strong>Expressions可以在  Java Service tasks, Execution Listeners, Task Listeners and Conditional sequence flows 中使用</strong></p>
<p>默认情况下，当使用ProcessEngineFactoryBean时，BPMN进程中的所有表达式也将看到所有Springbean。可以使用您可以配置的映射来限制要在表达式中公开的bean，甚至完全不公开bean。下面的示例公开一个bean(打印机)，可在键“打印机”下使用。若要完全不公开bean，只需将一个空列表作为SpringProcessEngineConfiguration上的Beans属性传递即可。当没有设置bean属性时，上下文中的所有Springbean都是可用的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;beans&quot;&gt;</span><br><span class="line">    &lt;map&gt;</span><br><span class="line">      &lt;entry key=&quot;printer&quot; value-ref=&quot;printer&quot; /&gt;</span><br><span class="line">    &lt;/map&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;printer&quot; class=&quot;org.activiti.examples.spring.Printer&quot; /&gt;</span><br></pre></td></tr></table></figure>



<h4 id="Java-Service-tasks"><a href="#Java-Service-tasks" class="headerlink" title="Java Service tasks"></a>Java Service tasks</h4><ul>
<li>activiti:delegateExpression 配置一个委派的Bean对象 通常这个bean在spring中，任务交给指定的对象来执行 对象实现了JavaDelegate</li>
<li>activiti:class 配置一个类，任务交给指定的类来执行 类实现JavaDelegate</li>
<li>activiti:expression 配置一个表达式，表达式的执行作为任务的内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指定task执行类</span><br><span class="line">&lt;serviceTask id=&quot;javaService&quot;name=&quot;My Java Service Task&quot; activiti:class=&quot;org.activiti.MyJavaDelegate&quot; /&gt;</span><br><span class="line"></span><br><span class="line">指定task执行类，delegateExpressionBean 实现了JavaDelegate接口，并且定义在spring中</span><br><span class="line">&lt;serviceTask id=&quot;serviceTask&quot; activiti:delegateExpression=&quot;$&#123;delegateExpressionBean&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">执行执行脚本方法</span><br><span class="line">&lt;serviceTask id=&quot;javaService&quot; name=&quot;My Java Service Task&quot; activiti:expression=&quot;#&#123;printer.printMessage()&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">执行带参数的脚本方法</span><br><span class="line">&lt;serviceTask id=&quot;javaService&quot;name=&quot;My Java Service Task&quot; activiti:expression=&quot;#&#123;printer.printMessage(execution, myVar)&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Execution-Listeners"><a href="#Execution-Listeners" class="headerlink" title="Execution Listeners"></a>Execution Listeners</h4><ul>
<li>delegateExpression:配置一个委派的Bean对象，通常这个bean在spring中，任务交给指定的对象来执行 对象实现了<strong>org.activiti.engine.delegate.ExecutionListener</strong></li>
<li>class:配置一个类，任务交给指定的类来执行 类实现ExecutionListener</li>
<li>expression：配置一个表达式，表达式的执行作为任务的内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;activiti:executionListener event=&quot;start&quot; delegateExpression=&quot;$&#123;myExecutionListenerBean&#125;&quot; /&gt;</span><br><span class="line">&lt;activiti:executionListener expression=&quot;$&#123;myPojo.myMethod(execution.eventName)&#125;&quot; event=&quot;end&quot; /&gt;</span><br><span class="line">&lt;activiti:executionListener class=&quot;org.activiti.executionlistener.ExampleExecutionListenerOne&quot; event=&quot;start&quot; /&gt;</span><br></pre></td></tr></table></figure>

<h4 id="Task-Listeners"><a href="#Task-Listeners" class="headerlink" title="Task Listeners"></a>Task Listeners</h4><p><strong>event</strong> </p>
<ul>
<li>assignment:当任务分配给某人时发生。注意：当进程执行到达userTask时，首先会触发一个分配事件，然后再触发CREATE事件。        这似乎是一种不自然的顺序，但其原因是务实的：在接收创建事件时，我们通常希望检查任务的所有属性，包括受让人</li>
<li>create:在已创建任务并设置了“所有任务”属性时发生</li>
<li>complete:在任务完成时和任务从运行时数据中删除之前发生。</li>
<li>delete:在删除任务之前发生。注意，当任务通常通过完全任务完成时，它也将被执行。</li>
</ul>
<p><strong>class</strong></p>
<ul>
<li>delegateExpression:配置一个委派的Bean对象，通常这个bean在spring中，任务交给指定的对象来执行 对象实现了<strong>org.activiti.engine.delegate.TaskListener</strong></li>
<li>class:配置一个类，任务交给指定的类来执行 类实现ExecutionListener</li>
<li>expression：配置一个表达式，表达式的执行作为任务的内容</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;activiti:taskListener event=&quot;create&quot; delegateExpression=&quot;$&#123;myTaskListenerBean&#125;&quot; /&gt;</span><br><span class="line">&lt;activiti:taskListener event=&quot;create&quot; expression=&quot;$&#123;myObject.callMethod(task, task.eventName)&#125;&quot; /&gt;</span><br><span class="line">&lt;activiti:taskListener event=&quot;create&quot; class=&quot;org.activiti.MyTaskCreateListener&quot; /&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Conditional-sequence-flows"><a href="#Conditional-sequence-flows" class="headerlink" title="Conditional sequence flows"></a>Conditional sequence flows</h4><p>目前条件表达式只能与UEL一起使用，有关这些的详细信息可以在部分表达式中找到。使用的表达式应该解析为布尔值，否则在计算条件时会引发异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下面的示例通过getter引用典型JavaBean样式中流程变量的数据</span><br><span class="line">&lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;</span><br><span class="line">    &lt;![CDATA[$&#123;order.price &gt; 100 &amp;&amp; order.price &lt; 250&#125;]]&gt;</span><br><span class="line">&lt;/conditionExpression&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此示例调用解析为布尔值的方法</span><br><span class="line">&lt;conditionExpression xsi:type=&quot;tFormalExpression&quot;&gt;</span><br><span class="line">  &lt;![CDATA[$&#123;order.isStandardOrder()&#125;]]&gt;</span><br><span class="line">&lt;/conditionExpression&gt;</span><br></pre></td></tr></table></figure>



<h3 id="表单概念"><a href="#表单概念" class="headerlink" title="表单概念"></a>表单概念</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">普通表单：每个节点的表单内容都写死在JSP或者HTML中。</span><br><span class="line"></span><br><span class="line">动态表单：表单内容存放在流程定义文件中（包含在启动事件以及每个用户任务中）。</span><br><span class="line"></span><br><span class="line">外置表单：每个用户任务对应一个单独的&lt;b&gt;.form&lt;/b&gt;文件，和流程定义文件同时部署（打包为zip/bar文件）。</span><br><span class="line"></span><br><span class="line">综合流程：可以查询到所有的流程（普通、动态、外置固定查询某些流程的表单，为了演示所以单独分开）；综合流程的目的在于可以启动用户上传或者设计    后部署的流程定义</span><br><span class="line"></span><br><span class="line">设置表单地址</span><br><span class="line"></span><br><span class="line">l 全局表单：新建流程时或活动元素上未设置表单标识时调用的表单，位于开始事件属性中“表单标识”字段，指定表单访问地址。</span><br><span class="line"></span><br><span class="line">l 活动表单：当前步骤使用的表单，使用活动节点属性“表单标识”字段。</span><br></pre></td></tr></table></figure>

<h3 id="设置流程参与者"><a href="#设置流程参与者" class="headerlink" title="设置流程参与者"></a>设置流程参与者</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">assignee：任务执行人，设置系统中的“登录名”（loginName）。            参与人类型ACT_IDENTITYLINK： participant， 发起人类型:starter</span><br><span class="line"></span><br><span class="line">candidateUsers：任务执行人，可以填写多个。                          候选人类型ACT_IDENTITYLINK：candidate   </span><br><span class="line"></span><br><span class="line">candidateGroups：任务执行组，可以填写多个，设置系统中的“角色英文名（enname）”。</span><br><span class="line"></span><br><span class="line">assignee和candidateUsers的区别是：assignee不需要签收任务，直接可执行任务；candidateUsers为竞争方式分配任务，被指定人待办中都有一条任务，谁先签收谁就获得任务的执行权。参与者可指定流程变量（EL表达式），动态指定参与者，如：$&#123;processer&#125;</span><br><span class="line"></span><br><span class="line">ASSIGNEE_（受理人）</span><br><span class="line">Task task=taskService.createTaskQuery().singleResult();</span><br><span class="line">//签收</span><br><span class="line">taskService.claim(task.getId(), &quot;billy&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OWNER_（委托人）：受理人委托其他人操作该TASK的时候，受理人就成了委托人OWNER_，其他人就成了受理人ASSIGNEE_</span><br><span class="line">Task task=taskService.createTaskQuery().singleResult();</span><br><span class="line">//委托</span><br><span class="line">taskService.delegateTask(task.getId(), &quot;cc&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">当前线程使用申请用户id，并留存在审批流程中</span><br><span class="line">activiti:initiator </span><br><span class="line">申请用户</span><br><span class="line">try &#123;</span><br><span class="line">  identityService.setAuthenticatedUserId(&quot;bono&quot;);</span><br><span class="line">  runtimeService.startProcessInstanceByKey(&quot;someProcessKey&quot;);</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">  identityService.setAuthenticatedUserId(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code> 任务操作流程：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生成任务并设置候选执行人，候选执行组</span><br><span class="line"></span><br><span class="line">候选任或者候选组人进行任务签收</span><br><span class="line"></span><br><span class="line">签收人执行处理任务</span><br></pre></td></tr></table></figure>

<h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//设置部署记录类型，将联动部署相关的流程定义一并更新类型</span><br><span class="line">repositoryService.setDeploymentCategory(&quot;10001&quot;,&quot;JTDLS&quot;);</span><br><span class="line">//设置流程定义类型</span><br><span class="line">repositoryService.setProcessDefinitionCategory(&quot;process_test_finance:1:10004&quot;,&quot;JTDLS&quot;);</span><br><span class="line">//设置部署的租户信息</span><br><span class="line">repositoryService.changeDeploymentTenantId(&quot;10001&quot;,&quot;AGENT&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Activity与spring集成"><a href="#Activity与spring集成" class="headerlink" title="Activity与spring集成:"></a>Activity与spring集成:</h3><h4 id="相关依赖"><a href="#相关依赖" class="headerlink" title="相关依赖"></a>相关依赖</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.activiti&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.22.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.activiti&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activiti-spring&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.22.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.activiti&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activiti-bpmn-model&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.22.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.activiti&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activiti-bpmn-converter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.22.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.activiti&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activiti-image-generator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.22.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h4><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">80</span></span><br><span class="line"><span class="attr">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line"><span class="attr">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/activity_local?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"><span class="attr">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">spring.datasource.password</span>=<span class="string">CHENxiao1989119</span></span><br><span class="line"><span class="attr">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">activity.deployment.deploymentResources[0]</span>=<span class="string">processes/*.bpmn20.xml</span></span><br></pre></td></tr></table></figure>

<h4 id="相关BEAN初始化"><a href="#相关BEAN初始化" class="headerlink" title="相关BEAN初始化"></a>相关BEAN初始化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> SpringProcessEngineConfiguration <span class="title function_">springProcessEngineConfiguration</span><span class="params">(DataSource dataSource, PlatformTransactionManager transactionManager)</span>&#123;</span><br><span class="line">    <span class="type">SpringProcessEngineConfiguration</span> <span class="variable">springProcessEngineConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpringProcessEngineConfiguration</span>();</span><br><span class="line">    springProcessEngineConfiguration.setDataSource(dataSource);</span><br><span class="line">    springProcessEngineConfiguration.setTransactionManager(transactionManager);</span><br><span class="line">    springProcessEngineConfiguration.setDatabaseSchemaUpdate(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">    springProcessEngineConfiguration.setDatabaseSchema(<span class="string">&quot;mysql&quot;</span>);</span><br><span class="line">    springProcessEngineConfiguration.setHistoryLevel(HistoryLevel.FULL);</span><br><span class="line">    <span class="keyword">return</span>  springProcessEngineConfiguration;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ProcessEngineFactoryBean <span class="title function_">processEngineFactoryBean</span><span class="params">(SpringProcessEngineConfiguration springProcessEngineConfiguration)</span>&#123;</span><br><span class="line">    <span class="type">ProcessEngineFactoryBean</span> <span class="variable">processEngineFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProcessEngineFactoryBean</span>();</span><br><span class="line">    processEngineFactoryBean.setProcessEngineConfiguration(springProcessEngineConfiguration);</span><br><span class="line">    <span class="keyword">return</span> processEngineFactoryBean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RepositoryService <span class="title function_">repositoryService</span><span class="params">(ProcessEngine processEngine)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> processEngine.getRepositoryService();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RuntimeService <span class="title function_">runtimeService</span><span class="params">(ProcessEngine processEngine)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> processEngine.getRuntimeService();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> TaskService <span class="title function_">taskService</span><span class="params">(ProcessEngine processEngine)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> processEngine.getTaskService();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> HistoryService <span class="title function_">historyService</span><span class="params">(ProcessEngine processEngine)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> processEngine.getHistoryService();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> ManagementService <span class="title function_">managementService</span><span class="params">(ProcessEngine processEngine)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> processEngine.getManagementService();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IdentityService <span class="title function_">identityService</span><span class="params">(ProcessEngine processEngine)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> processEngine.getIdentityService();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">        exception.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="自动资源部署"><a href="#自动资源部署" class="headerlink" title="自动资源部署"></a>自动资源部署</h4><h5 id="deploymentResources："><a href="#deploymentResources：" class="headerlink" title="deploymentResources："></a>deploymentResources：</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;&gt;</span><br><span class="line">&lt;property name=&quot;deploymentResources&quot;</span><br><span class="line">    value=&quot;classpath*:/org/activiti/spring/test/autodeployment/autodeploy.*.bpmn20.xml&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(&quot;activity.deployment&quot;)</span><br><span class="line">public class DeploymentResourceConfig &#123;</span><br><span class="line"></span><br><span class="line">    private String[] deploymentResources;</span><br><span class="line"></span><br><span class="line">    public Resource[] getDeploymentResources() &#123;</span><br><span class="line">        PathMatchingResourcePatternResolver pathMatchingResourcePatternResolver = new PathMatchingResourcePatternResolver();</span><br><span class="line">        List&lt;Resource&gt; resources = new ArrayList&lt;&gt;();</span><br><span class="line">        for (String deploymentResource : deploymentResources) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Resource[] search_res =  pathMatchingResourcePatternResolver.getResources(deploymentResource);</span><br><span class="line">                resources.addAll(Arrays.asList(search_res));</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return resources.toArray(new Resource[]&#123;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDeploymentResources(String[] deploymentResources) &#123;</span><br><span class="line">        this.deploymentResources = deploymentResources;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下，上面的配置将匹配筛选的所有资源分组到Activiti引擎的单个部署中。防止重新部署未更改资源的重复筛选适用于整个部署。在某些情况下，这可能不是你想要的。例如，如果您以这种方式部署了一组流程资源，并且这些资源中只有一个流程定义已经更改，则整个部署将被视为新的，而部署中的所有流程定义都将被重新部署，从而生成每个流程定义的新版本，即使实际上只有一个被更改。</p>
<p>为了能够自定义确定部署的方式，您可以在SpringProcessEngineConfiguration，DeploymentMode中指定一个附加属性。此属性定义从匹配筛选器的一组资源中确定部署的方式。对于此属性，默认情况下支持3个值。</p>
<h5 id="deploymentMode："><a href="#deploymentMode：" class="headerlink" title="deploymentMode："></a>deploymentMode：</h5><ul>
<li>default:将所有资源分组到单个部署中，并对该部署应用重复筛选。这是默认值，如果不指定值，将使用它</li>
<li>single-resource:为每个单独的资源创建一个单独的部署，并对该部署应用重复筛选。此值用于将每个流程定义分别部署，并仅在更改后创建一个新的流程定义版本</li>
<li>resource-parent-folder:为共享同一个父文件夹的资源创建单独的部署，并对该部署应用重复筛选。此值可用于为大多数资源创建单独的部署，但仍可以通过将它们放置在共享文件夹中对某些资源进行分组。下面是如何为部署模式指定单资源配置的示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;bean id=&quot;processEngineConfiguration&quot; class=&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;&gt;</span><br><span class="line">  &lt;property name=&quot;deploymentResources&quot; value=&quot;classpath*:/activiti/*.bpmn&quot; /&gt;</span><br><span class="line">  &lt;property name=&quot;deploymentMode&quot; value=&quot;single-resource&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>activity</tag>
      </tags>
  </entry>
  <entry>
    <title>工作流引擎Activity事件</title>
    <url>/2022/01/07/activity/event/</url>
    <content><![CDATA[<h3 id="事件功能"><a href="#事件功能" class="headerlink" title="事件功能"></a>事件功能</h3><p>事件用来表明流程的生命周期中发生了什么事。 事件总是画成一个圆圈。在BPMN 2.0中，事件有两大分类：<em>捕获（catching）</em> 或 <em>触发（throwing）</em> 事件。        </p>
<ul>
<li><strong>捕获（Catching）：</strong>当流程执行到事件，它会等待被触发。触发的类型是由内部图表或XML中的类型声明来决定的。 捕获事件与触发事件在显示方面是根据内部图表是否被填充来区分的（白色的）。            </li>
<li><strong>触发（Throwing）：</strong>当流程执行到事件，会触发一个事件。触发的类型是由内部图表或XML中的类型声明来决定的。触发事件与捕获事件在显示方面是根据内部图表是否被填充来区分的（被填充为黑色）。</li>
</ul>
<h3 id="事件位置："><a href="#事件位置：" class="headerlink" title="事件位置："></a>事件位置：</h3><p>起始：事件位于流程的起始位置</p>
<p>中间：事件位于流程的中间位置</p>
<p>边界：事件位于节点或者子流程的边界</p>
<p>结束：事件位于流程的结束位置</p>
<h3 id="事件定义"><a href="#事件定义" class="headerlink" title="事件定义:"></a>事件定义:</h3><p>空事件：可用于开始事件，中间事件，结束事件</p>
<p>定时器事件：可用于开始事件，中间事件，边界事件</p>
<p>错误事件：可用于开始事件，边界事件，结束事件</p>
<p>信号事件：可用于开始事件，中间事件，边界事件</p>
<p>消息事件：可用于开始事件，中间事件，边界事件</p>
<p>补偿事件：可用于边界事件</p>
<p>取消事件：可用于边界事件，结束事件</p>
<table>
<thead>
<tr>
<th></th>
<th>起始</th>
<th>中间</th>
<th>边界</th>
<th>结束</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>空事件</td>
<td>-</td>
<td>-</td>
<td></td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>错误</td>
<td>-</td>
<td></td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>定时</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>信号</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>消息</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>补偿</td>
<td></td>
<td></td>
<td>-</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>取消</td>
<td></td>
<td></td>
<td>-</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="开始事件"><a href="#开始事件" class="headerlink" title="开始事件"></a>开始事件</h3><h4 id="空的开始事件"><a href="#空的开始事件" class="headerlink" title="空的开始事件"></a>空的开始事件</h4><h4 id="消息开始事件"><a href="#消息开始事件" class="headerlink" title="消息开始事件"></a>消息开始事件</h4><ul>
<li><p><strong>消息开始事件的名称在给定流程定义中不能重复</strong>。流程定义不能包含多个名称相同的消息开始事件。如果两个或以上消息开始事件应用了相同的事件，或两个或以上消息事件引用的消息名称相同，activiti会在发布流程定义时抛出异常</p>
</li>
<li><p><strong>消息开始事件的名称在所有已发布的流程定义中不能重复</strong>，如果一个或多个消息开始事件引用了相同名称的消息，而这个消息开始事件已经部署到不同的流程定义中，activiti就会在发布时抛出一个异常</p>
</li>
<li><p>流程版本：<strong>在发布新版本的流程定义时，之前订阅的消息订阅会被取消</strong>。如果新版本中没有消息事件也会这样处理</p>
<h4 id="启动流程实例"><a href="#启动流程实例" class="headerlink" title="启动流程实例"></a>启动流程实例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProcessInstance startProcessInstanceByMessage(String messageName);</span><br><span class="line">ProcessInstance startProcessInstanceByMessage(String messageName, Map&lt;String, Object&gt; processVariables);</span><br><span class="line">ProcessInstance startProcessInstanceByMessage(String messageName, String businessKey, Map&lt;String, Object&lt; processVariables);</span><br></pre></td></tr></table></figure>

<ul>
<li>消息开始事件只支持顶级流程。消息开始事件不支持内嵌子流程。                         </li>
<li>如果流程定义有多个消息开始事件，<code>runtimeService.startProcessInstanceByMessage(...)</code>会选择对应的开始事件。                         </li>
<li>如果流程定义有多个消息开始事件和一个空开始事件。<code>runtimeService.startProcessInstanceByKey(...)</code>和                             <code>runtimeService.startProcessInstanceById(...)</code>会使用空开始事件启动流程实例。 </li>
<li>如果流程定义有多个消息开始事件，而且没有空开始事件，<code>runtimeService.startProcessInstanceByKey(...)</code>和                             <code>runtimeService.startProcessInstanceById(...)</code>会抛出异常。                         </li>
<li>如果流程定义只有一个消息开始事件，<code>runtimeService.startProcessInstanceByKey(...)</code>和                             <code>runtimeService.startProcessInstanceById(...)</code>会使用这个消息开始事件启动流程实例。                         </li>
<li>如果流程被调用环节（callActivity）启动，消息开始事件只支持如下情况：                             <ul>
<li>在消息开始事件以外，还有一个单独的空开始事件</li>
<li>流程只有一个消息开始事件，没有空开始事件。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="定时开始事件："><a href="#定时开始事件：" class="headerlink" title="定时开始事件："></a>定时开始事件：</h4><ul>
<li><strong>timeDate</strong>：</li>
</ul>
<p>使用 <a href="http://en.wikipedia.org/wiki/ISO_8601#Dates">ISO 8601</a> 格式指定一个确定的时间，触发事件的时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;timerEventDefinition&gt;</span><br><span class="line">    &lt;timeDate&gt;2011-03-11T12:13:14&lt;/timeDate&gt;</span><br><span class="line">&lt;/timerEventDefinition&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>timeDuration</strong>:</li>
</ul>
<p>指定定时器之前要等待多长时间<em>timeDuration</em>可以设置为<em>timerEventDefinition</em>的子元素,使用<a href="http://en.wikipedia.org/wiki/ISO_8601#Durations">ISO 8601</a>规定的格（等待10天）。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;timerEventDefinition&gt;</span><br><span class="line">    &lt;timeDuration&gt;P10D&lt;/timeDuration&gt;</span><br><span class="line">&lt;/timerEventDefinition&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>timeCycle</strong></li>
</ul>
<p>指定重复执行的间隔， 可以用来定期启动流程实例，或为超时时间发送多个提醒。timeCycle元素可以使用两种格式。第一种是         <a href="http://en.wikipedia.org/wiki/ISO_8601#Repeating_intervals">ISO 8601</a>标准的格式。示例（重复3次，每次间隔10小时）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;timerEventDefinition&gt;</span><br><span class="line">    &lt;timeCycle&gt;R3/PT10H&lt;/timeCycle&gt;</span><br><span class="line">&lt;/timerEventDefinition&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用cron表达式指定timeCycle，下面的例子是从整点开始，每5分钟执行一次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0/5 * * * ?</span><br></pre></td></tr></table></figure>

<p><strong>时间段表示法</strong>：</p>
<p>如果要表示某一作为一段时间的时间期间，前面加一大写字母P，但时间段后都要加上相应的代表时间的大写字母。如在一年三个月五天六小时七分三十秒内，可以写成P1Y3M5DT6H7M30S</p>
<p><strong>重复时间表示法</strong></p>
<p>前面加上一大写字母R，如要从2004年5月6日北京时间下午1点起重复半年零5天3小时，要重复3次，可以表示为R3/20040506T130000+08/P0Y6M5DT3H0M0S。</p>
<h4 id="信号开始事件"><a href="#信号开始事件" class="headerlink" title="信号开始事件:"></a>信号开始事件:</h4><p>signal开始事件，可以用来通过一个已命名的信号（signal）来启动一个流程实例。信号可以在流程实例内部使用“中间信号抛出事务”触发，也可以通过API(<em>runtimService.signalEventReceivedXXX</em> 方法)触发。两种情况下，所有流程实例中拥有相同名称的signalStartEvent都会启动</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>activity</tag>
      </tags>
  </entry>
  <entry>
    <title>Es RESTful Api</title>
    <url>/2022/07/26/db/esapi/</url>
    <content><![CDATA[<h3 id="查询所有索引信息"><a href="#查询所有索引信息" class="headerlink" title="查询所有索引信息"></a>查询所有索引信息</h3><ul>
<li>http:///_cat/indices</li>
</ul>
<h3 id="索引映射查看"><a href="#索引映射查看" class="headerlink" title="索引映射查看"></a>索引映射查看</h3><ul>
<li>get http:///agent-info</li>
</ul>
<h3 id="索引设置查看"><a href="#索引设置查看" class="headerlink" title="索引设置查看"></a>索引设置查看</h3><ul>
<li>get http:///agent-info/_settings</li>
</ul>
<h3 id="索引删除"><a href="#索引删除" class="headerlink" title="索引删除"></a>索引删除</h3><ul>
<li>delete  http:///agent-info</li>
</ul>
<h3 id="精确匹配"><a href="#精确匹配" class="headerlink" title="精确匹配"></a>精确匹配</h3><ul>
<li>get  http:///agent-info/_search</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;:&#123;</span><br><span class="line">        &quot;match&quot;:&#123;</span><br><span class="line">            &quot;ag_name&quot;: &quot;大石桥市旺达水果蔬菜便利店&quot;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引全文检索"><a href="#索引全文检索" class="headerlink" title="索引全文检索"></a>索引全文检索</h3><ul>
<li>get  http:///agent-info/_search</li>
</ul>
<h3 id="关键词分析"><a href="#关键词分析" class="headerlink" title="关键词分析"></a>关键词分析</h3><ul>
<li>get http:///_analyze<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;analyzer&quot; : &quot;ik_max_word&quot;,</span><br><span class="line">  &quot;text&quot; : &quot;739183800@qq.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="cat操作类表"><a href="#cat操作类表" class="headerlink" title="_cat操作类表"></a>_cat操作类表</h3><ul>
<li>get http:///_cat</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=^.^=</span><br><span class="line">/_cat/allocation</span><br><span class="line">/_cat/shards</span><br><span class="line">/_cat/shards/&#123;index&#125;</span><br><span class="line">/_cat/master</span><br><span class="line">/_cat/nodes</span><br><span class="line">/_cat/tasks</span><br><span class="line">/_cat/indices</span><br><span class="line">/_cat/indices/&#123;index&#125;</span><br><span class="line">/_cat/segments</span><br><span class="line">/_cat/segments/&#123;index&#125;</span><br><span class="line">/_cat/count</span><br><span class="line">/_cat/count/&#123;index&#125;</span><br><span class="line">/_cat/recovery</span><br><span class="line">/_cat/recovery/&#123;index&#125;</span><br><span class="line">/_cat/health</span><br><span class="line">/_cat/pending_tasks</span><br><span class="line">/_cat/aliases</span><br><span class="line">/_cat/aliases/&#123;alias&#125;</span><br><span class="line">/_cat/thread_pool</span><br><span class="line">/_cat/thread_pool/&#123;thread_pools&#125;</span><br><span class="line">/_cat/plugins</span><br><span class="line">/_cat/fielddata</span><br><span class="line">/_cat/fielddata/&#123;fields&#125;</span><br><span class="line">/_cat/nodeattrs</span><br><span class="line">/_cat/repositories</span><br><span class="line">/_cat/snapshots/&#123;repository&#125;</span><br><span class="line">/_cat/templates</span><br><span class="line">/_cat/ml/anomaly_detectors</span><br><span class="line">/_cat/ml/anomaly_detectors/&#123;job_id&#125;</span><br><span class="line">/_cat/ml/trained_models</span><br><span class="line">/_cat/ml/trained_models/&#123;model_id&#125;</span><br><span class="line">/_cat/ml/datafeeds</span><br><span class="line">/_cat/ml/datafeeds/&#123;datafeed_id&#125;</span><br><span class="line">/_cat/ml/data_frame/analytics</span><br><span class="line">/_cat/ml/data_frame/analytics/&#123;id&#125;</span><br><span class="line">/_cat/transforms</span><br><span class="line">/_cat/transforms/&#123;transform_id&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><ul>
<li><p>get http:///_cat/health</p>
<blockquote>
<p>1658815275 06:01:15 ryx green 3 3 10 8 0 0 0 0 - 100.0%</p>
</blockquote>
<h3 id="查看集群信息"><a href="#查看集群信息" class="headerlink" title="查看集群信息"></a>查看集群信息</h3></li>
<li><p>get http:///_cluster/health</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;cluster_name&quot;: &quot;ryx&quot;,</span><br><span class="line">    &quot;status&quot;: &quot;green&quot;,</span><br><span class="line">    &quot;timed_out&quot;: false,</span><br><span class="line">    &quot;number_of_nodes&quot;: 3,</span><br><span class="line">    &quot;number_of_data_nodes&quot;: 3,</span><br><span class="line">    &quot;active_primary_shards&quot;: 8,</span><br><span class="line">    &quot;active_shards&quot;: 10,</span><br><span class="line">    &quot;relocating_shards&quot;: 0,</span><br><span class="line">    &quot;initializing_shards&quot;: 0,</span><br><span class="line">    &quot;unassigned_shards&quot;: 0,</span><br><span class="line">    &quot;delayed_unassigned_shards&quot;: 0,</span><br><span class="line">    &quot;number_of_pending_tasks&quot;: 0,</span><br><span class="line">    &quot;number_of_in_flight_fetch&quot;: 0,</span><br><span class="line">    &quot;task_max_waiting_in_queue_millis&quot;: 0,</span><br><span class="line">    &quot;active_shards_percent_as_number&quot;: 100.0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查看集群master"><a href="#查看集群master" class="headerlink" title="查看集群master"></a>查看集群master</h3></li>
<li><p>get http:///_cat/master</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TzHcEWPTRW-D8vFqj0lTUQ 12.3.10.105 12.3.10.105 node-105</span><br></pre></td></tr></table></figure>
<h3 id="查看集群节点信息"><a href="#查看集群节点信息" class="headerlink" title="查看集群节点信息"></a>查看集群节点信息</h3></li>
<li><p>get http:///_cat/nodes</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12.3.10.205 65 97 3 0.02 0.11 0.17 cdfhilmrstw - node-205</span><br><span class="line">12.3.10.222 15 94 3 0.03 0.07 0.06 cdfhilmrstw - node-222</span><br><span class="line">12.3.10.105 51 98 2 0.06 0.08 0.02 cdfhilmrstw * node-105</span><br></pre></td></tr></table></figure>
<h3 id="查看集群分片信息"><a href="#查看集群分片信息" class="headerlink" title="查看集群分片信息"></a>查看集群分片信息</h3></li>
<li><p>get http:///_cat/shards</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">agent-info       2 p STARTED 13569   1.8mb 12.3.10.205 node-205</span><br><span class="line">agent-info       1 p STARTED 13104   1.8mb 12.3.10.205 node-205</span><br><span class="line">agent-info       0 p STARTED 13476   1.8mb 12.3.10.222 node-222</span><br><span class="line">.security-7      0 r STARTED     7  25.7kb 12.3.10.205 node-205</span><br><span class="line">.security-7      0 p STARTED     7  25.7kb 12.3.10.222 node-222</span><br><span class="line">.geoip_databases 0 r STARTED     4     4mb 12.3.10.205 node-205</span><br><span class="line">.geoip_databases 0 p STARTED     4     4mb 12.3.10.222 node-222</span><br><span class="line">order-info       2 p STARTED   570 266.7kb 12.3.10.222 node-222</span><br><span class="line">order-info       1 p STARTED   508 249.2kb 12.3.10.205 node-205</span><br><span class="line">order-info       0 p STARTED   521   259kb 12.3.10.222 node-222</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ES安装与运行</title>
    <url>/2022/05/19/db/es/</url>
    <content><![CDATA[<h2 id="ES安装："><a href="#ES安装：" class="headerlink" title="ES安装："></a>ES安装：</h2><p>安装 Elasticsearch 之前，你需要先安装一个较新的版本的 Java</p>
<p><a href="https://www.elastic.co/cn/downloads/elasticsearch">Es 官网下载</a></p>
<ul>
<li><p>如果你想把 Elasticsearch 作为一个守护进程在后台运行，那么可以在后面添加参数 -d </p>
</li>
<li><p>如果你是在 Windows 上面运行 Elasticseach，你应该运行 bin\elasticsearch.bat 而不是 bin\elasticsearch</p>
</li>
</ul>
<p>测试是否安装成功</p>
<p>curl ‘<a href="http://localhost:9200/?pretty&#39;">http://localhost:9200/?pretty&#39;</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node-222&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cluster_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ryx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cluster_uuid&quot;</span><span class="punctuation">:</span> <span class="string">&quot;AaljyBfbTm2VVmOmyZSgsw&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;number&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7.15.2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;build_flavor&quot;</span><span class="punctuation">:</span> <span class="string">&quot;default&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;build_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;tar&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;build_hash&quot;</span><span class="punctuation">:</span> <span class="string">&quot;93d5a7f6192e8a1a12e154a2b81bf6fa7309da0c&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;build_date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2021-11-04T14:04:42.515624022Z&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;build_snapshot&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;lucene_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8.9.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;minimum_wire_compatibility_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6.8.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;minimum_index_compatibility_version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6.0.0-beta1&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tagline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;You Know, for Search&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="环境变量设置："><a href="#环境变量设置：" class="headerlink" title="环境变量设置："></a>环境变量设置：</h3><p> ES_HOME=/usr/local/src/elasticsearch-7.15.2<br> ES_JAVA_HOME=/usr/local/src/elasticsearch-7.15.2/jdk</p>
<h3 id="用户组准备-es禁止使用root-启动服务，所以需要准备es对应的用户信息-创建用户组-及用户并修改es用户对根目录数据目录日志目录的权限"><a href="#用户组准备-es禁止使用root-启动服务，所以需要准备es对应的用户信息-创建用户组-及用户并修改es用户对根目录数据目录日志目录的权限" class="headerlink" title="用户组准备 es禁止使用root 启动服务，所以需要准备es对应的用户信息 创建用户组 及用户并修改es用户对根目录数据目录日志目录的权限"></a>用户组准备 es禁止使用root 启动服务，所以需要准备es对应的用户信息 创建用户组 及用户并修改es用户对根目录数据目录日志目录的权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groupadd es</span><br><span class="line">useradd es -g es -p es</span><br><span class="line">chown -R es:es  elasticsearch-7.15.2/</span><br><span class="line">chown -R es:es  eslog/</span><br><span class="line">chown -R es:es  esdata/</span><br></pre></td></tr></table></figure>

<h2 id="部署配置"><a href="#部署配置" class="headerlink" title="部署配置"></a>部署配置</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><p>内存：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;64 GB 内存的机器是非常理想的， 但是32 GB 和16 GB 机器也是很常见的。少于8 GB 会适得其反（你最终需要很多很多的小机器），大于64 GB 的机器也会有问题</p>
<p>CPU:</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;大多数 Elasticsearch 部署往往对 CPU 要求不高。因此，相对其它资源，具体配置多少个（CPU）不是那么关键。你应该选择具有多个内核的现代处理器，常见的集群使用两到八个核的机器。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果你要在更快的 CPUs 和更多的核心之间选择，选择更多的核心更好。多个内核提供的额外并发远胜过稍微快一点点的时钟频率</p>
<p>硬盘：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;硬盘对所有的集群都很重要，对大量写入的集群更是加倍重要（例如那些存储日志数据的）。硬盘是服务器上最慢的子系统，这意味着那些写入量很大的集群很容易让硬盘饱和，使得它成为集群的瓶颈。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果你负担得起 SSD，它将远远超出任何旋转介质（注：机械硬盘，磁带等）。 基于 SSD 的节点，查询和索引性能都有提升。如果你负担得起，SSD 是一个好的选择。</p>
<p>网络：</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;快速可靠的网络显然对分布式系统的性能是很重要的。 低延时能帮助确保节点间能容易的通讯，大带宽能帮助分片移动和恢复。现代数据中心网络（1 GbE, 10 GbE）对绝大多数集群都是足够的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;即使数据中心们近在咫尺，也要避免集群跨越多个数据中心。绝对要避免集群跨越大的地理距离。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Elasticsearch 假定所有节点都是平等的—并不会因为有一半的节点在150ms 外的另一数据中心而有所不同。更大的延时会加重分布式系统中的问题而且使得调试和排错更困难</p>
<h3 id="文件描述符和MMAP"><a href="#文件描述符和MMAP" class="headerlink" title="文件描述符和MMAP"></a>文件描述符和MMAP</h3><p>Es的用户线程打开数量要求最低4096，打开文件描述符开放到65536，进程虚拟内存区域655360</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#用户级限制配置</span><br><span class="line">vi /etc/security/limits.conf   # 在最后面追加下面内容</span><br><span class="line"></span><br><span class="line">es soft nproc 4096 #max number of threads [1024] for user [es] is too low, increase to at least [4096]</span><br><span class="line">es hard nofile 65536 # elasticsearch用户拥有的可创建文件描述的权限太低，至少需要65536</span><br><span class="line">es soft nofile 65536 # elasticsearch用户拥有的可创建文件描述的权限太低，至少需要65536</span><br><span class="line"></span><br><span class="line">#切换到root用户修改 max_map_count文件包含限制一个进程可以拥有的VMA(虚拟内存区域)的数量 </span><br><span class="line">vim /etc/sysctl.conf    # 在最后面追加下面内容</span><br><span class="line">vm.max_map_count=655360</span><br><span class="line">#执行  sysctl -p</span><br></pre></td></tr></table></figure>

<h3 id="elasticsearch-相关隐私配置-elasticsearch-keystore"><a href="#elasticsearch-相关隐私配置-elasticsearch-keystore" class="headerlink" title="elasticsearch 相关隐私配置 elasticsearch-keystore"></a>elasticsearch 相关隐私配置 elasticsearch-keystore</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bin/elasticsearch-keystore create -p </span><br><span class="line"></span><br><span class="line">#设置xpack.security.transport.ssl.keystore.password</span><br><span class="line">bin/elasticsearch-keystore add xpack.security.transport.ssl.keystore.secure_password</span><br><span class="line"></span><br><span class="line">#设置xpack.security.transport.ssl.truststore.password</span><br><span class="line">bin/elasticsearch-keystore add xpack.security.transport.ssl.truststore.secure_password</span><br></pre></td></tr></table></figure>

<h3 id="管理账号密码初始"><a href="#管理账号密码初始" class="headerlink" title="管理账号密码初始"></a>管理账号密码初始</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.bin/elasticsearch-setup-passwords interactive    </span><br><span class="line"></span><br><span class="line">Initiating the setup of passwords for reserved users elastic,kibana,logstash_system,beats_system.</span><br><span class="line">You will be prompted to enter passwords as the process progresses.</span><br><span class="line">Please confirm that you would like to continue [y/N]y</span><br><span class="line">Enter password for [elastic]: </span><br><span class="line">passwords must be at least [6] characters long</span><br><span class="line">Try again.</span><br><span class="line">Enter password for [elastic]: </span><br><span class="line">Reenter password for [elastic]: </span><br><span class="line">Passwords do not match.</span><br><span class="line">Try again.</span><br><span class="line">Enter password for [elastic]: </span><br><span class="line">Reenter password for [elastic]: </span><br><span class="line">Enter password for [kibana]: </span><br><span class="line">Reenter password for [kibana]: </span><br><span class="line">Enter password for [logstash_system]: </span><br><span class="line">Reenter password for [logstash_system]: </span><br><span class="line">Enter password for [beats_system]: </span><br><span class="line">Reenter password for [beats_system]: </span><br><span class="line">Changed password for user [kibana]</span><br><span class="line">Changed password for user [logstash_system]</span><br><span class="line">Changed password for user [beats_system]</span><br><span class="line">Changed password for user [elastic]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>系统间数据传输添加安全协议层</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">elasticsearch-certutil</span></span><br><span class="line">bin/elasticsearch-certutil</span><br><span class="line">(</span><br><span class="line">(ca [--ca-dn &lt;name&gt;] [--days &lt;n&gt;] [--pem])</span><br><span class="line">| (cert ([--ca &lt;file_path&gt;] | [--ca-cert &lt;file_path&gt; --ca-key &lt;file_path&gt;])</span><br><span class="line">[--ca-dn &lt;name&gt;] [--ca-pass &lt;password&gt;] [--days &lt;n&gt;]</span><br><span class="line">[--dns &lt;domain_name&gt;] [--in &lt;input_file&gt;] [--ip &lt;ip_addresses&gt;]</span><br><span class="line">[--keep-ca-key] [--multiple] [--name &lt;file_name&gt;] [--pem] [--self-signed])</span><br><span class="line"></span><br><span class="line">| (csr [--dns &lt;domain_name&gt;] [--in &lt;input_file&gt;] [--ip &lt;ip_addresses&gt;]</span><br><span class="line">[--name &lt;file_name&gt;])</span><br><span class="line"></span><br><span class="line">[-E &lt;KeyValuePair&gt;] [--keysize &lt;bits&gt;] [--out &lt;file_path&gt;]</span><br><span class="line">[--pass &lt;password&gt;]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">| http</span><br><span class="line"></span><br><span class="line">[-h, --help] ([-s, --silent] | [-v, --verbose])</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">The following <span class="built_in">command</span> generates a CA certificate and private key <span class="keyword">in</span> PKCS<span class="comment">#12</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成 CA证书和私钥 以PKCS<span class="comment">#12格式存储</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">You are prompted <span class="keyword">for</span> an output filename and a password. Alternatively, you can specify the --out and --pass parameters</span></span><br><span class="line">bin/elasticsearch-certutil ca</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">You can <span class="keyword">then</span> generate X.509 certificates and private keys by using the new CA</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">You are prompted <span class="keyword">for</span> the CA password and <span class="keyword">for</span> an output filename and password. Alternatively, you can specify the --ca-pass, --out, and --pass parameters</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">生成X.509 证书和私钥</span></span><br><span class="line">bin/elasticsearch-certutil cert --ca elastic-stack-ca.p12</span><br></pre></td></tr></table></figure>



<h3 id="系统简单配置"><a href="#系统简单配置" class="headerlink" title="系统简单配置"></a>系统简单配置</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">cluster.name:</span> <span class="string">ryx</span></span><br><span class="line"><span class="attr">node.master:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.data:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-222</span></span><br><span class="line"><span class="comment">#discovery.type: single-node</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment">#和其他程序通信</span></span><br><span class="line"><span class="attr">network.publish_host:</span> <span class="number">12.3</span><span class="number">.10</span><span class="number">.222</span></span><br><span class="line"><span class="comment">#network.publish_host: 12.3.10.205</span></span><br><span class="line"><span class="comment">#network.publish_host: 12.3.10.105</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="attr">discovery.seed_hosts:</span> [<span class="string">&quot;12.3.10.222&quot;</span>,<span class="string">&quot;12.3.10.205&quot;</span>, <span class="string">&quot;12.3.10.105&quot;</span>]</span><br><span class="line"><span class="attr">cluster.initial_master_nodes:</span> [<span class="string">&quot;node-222&quot;</span>,<span class="string">&quot;node-205&quot;</span>,<span class="string">&quot;node-105&quot;</span>]</span><br><span class="line"><span class="attr">discovery.zen.minimum_master_nodes:</span> <span class="number">2</span> <span class="comment">#至少连个master节点启动才算集群启动，并开始数据同步</span></span><br><span class="line"><span class="attr">bootstrap.system_call_filter:</span> <span class="literal">false</span> <span class="comment">#关闭系统版本校验</span></span><br><span class="line"><span class="attr">action.destructive_requires_name:</span> <span class="literal">true</span> <span class="comment">#索引删除是否名称敏感</span></span><br><span class="line"><span class="attr">action.auto_create_index:</span> <span class="literal">false</span> <span class="comment">#是否自动创建索引</span></span><br><span class="line"><span class="attr">xpack.security.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">xpack.license.self_generated.type:</span> <span class="string">basic</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.keystore.path:</span> <span class="string">cer/elastic-certificates.p12</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.keystore.type:</span> <span class="string">PKCS12</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.keystore.password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.verification_mode:</span> <span class="string">certificate</span> <span class="comment">#指定传输验证模式</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.truststore.path:</span> <span class="string">cer/elastic-certificates.p12</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.truststore.type:</span> <span class="string">PKCS12</span></span><br><span class="line"><span class="attr">xpack.security.transport.ssl.truststore.password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>


<h3 id="重要的配置项"><a href="#重要的配置项" class="headerlink" title="重要的配置项"></a>重要的配置项</h3><ul>
<li>集群名称<br>&nbsp;&nbsp;&nbsp;&nbsp;Elasticsearch 默认启动的集群名字叫 elasticsearch 。你最好给你的生产环境的集群改个名字，改名字的目的很简单， 就是防止某人的笔记本电脑加入了集群这种意外<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#elasticsearch.yml</span><br><span class="line">cluster.name: elasticsearch_production</span><br></pre></td></tr></table></figure></li>
<li>节点名称<br>&nbsp;&nbsp;&nbsp;&nbsp;Elasticsearch 会在你的节点启动的时候随机给它指定一个名字。你可能会觉得这很有趣，但是当凌晨 3 点钟的时候， 你还在尝试回忆哪台物理机是 Tagak the Leopard Lord 的时候，你就不觉得有趣了。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;更重要的是，这些名字是在启动的时候产生的，每次启动节点， 它都会得到一个新的名字。这会使日志变得很混乱，因为所有节点的名称都是不断变化的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#elasticsearch.yml</span><br><span class="line">node.name: elasticsearch_005_data</span><br></pre></td></tr></table></figure>


<ul>
<li>路径</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;默认情况下，Elasticsearch 会把插件、日志以及你最重要的数据放在安装目录下。这会带来不幸的事故， 如果你重新安装 Elasticsearch 的时候不小心把安装目录覆盖了。如果你不小心，你就可能把你的全部数据删掉了</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;最好的选择就是把你的数据目录配置到安装目录以外的地方， 同样你也可以选择转移你的插件和日志目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#elasticsearch.yml</span><br><span class="line">#数据目录</span><br><span class="line">path.data: /path/to/data1,/path/to/data2 </span><br><span class="line"></span><br><span class="line">#日志目录</span><br><span class="line">path.logs: /path/to/logs</span><br><span class="line"></span><br><span class="line"># 插件目录</span><br><span class="line">path.plugins: /path/to/plugins</span><br></pre></td></tr></table></figure>
<ul>
<li>最小节点数</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;minimum_master_nodes  设定对你的集群的稳定 极其 重要。 当你的集群中有两个 masters（注：主节点）的时候，这个配置有助于防止 脑裂 ，一种两个主节点同时存在于一个集群的现象。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果你的集群发生了脑裂，那么你的集群就会处在丢失数据的危险中，因为主节点被认为是这个集群的最高统治者，它决定了什么时候新的索引可以创建，分片是如何移动的等等。如果你有 两个 masters 节点， 你的数据的完整性将得不到保证，因为你有两个节点认为他们有集群的控制权。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这个配置就是告诉 Elasticsearch 当没有足够 master 候选节点的时候，就不要进行 master 节点选举，等 master 候选节点足够了才进行选举</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;此设置应该始终被配置为 master 候选节点的法定个数（大多数个）。法定个数就是 ( master 候选节点个数 / 2) + 1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#elasticsearch.yml</span><br><span class="line">discovery.zen.minimum_master_nodes: 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#PUT /_cluster/settings</span><br><span class="line">&#123;</span><br><span class="line">    &quot;persistent&quot; : &#123;</span><br><span class="line">        &quot;discovery.zen.minimum_master_nodes&quot; : 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>集群恢复相关的配置</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这三个设置可以在集群重启的时候避免过多的分片交换。这可能会让数据恢复从数个小时缩短为几秒钟</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#config/elasticsearch.yml</span><br><span class="line"># Elasticsearch 在存在至少 8 个节点（数据节点或者 master 节点）之前进行数据恢复。 这个值的设定取决于个人喜好：整个集群提供服务之前你希望有多少个节点在线？这种情况下，我们设置为 8，这意味着至少要有 8 个节点，该集群才可用</span><br><span class="line">gateway.recover_after_nodes: 8</span><br><span class="line"></span><br><span class="line"># 现在我们要告诉 Elasticsearch 集群中 应该 有多少个节点，以及我们愿意为这些节点等待多长时间</span><br><span class="line">gateway.expected_nodes: 10</span><br><span class="line">gateway.recover_after_time: 5m</span><br><span class="line">#这意味着 Elasticsearch 会采取如下操作：</span><br><span class="line">    #等待集群至少存在 8 个节点</span><br><span class="line">    #等待 5 分钟，或者10 个节点上线后，才进行数据恢复，这取决于哪个条件先达到。</span><br></pre></td></tr></table></figure>

<ul>
<li>使用单播代替组播</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;虽然组播仍然 作为插件提供， 但它应该永远不被使用在生产环境了，否则你得到的结果就是一个节点意外的加入到了你的生产环境，仅仅是因为他们收到了一个错误的组播信号。 对于组播 本身 并没有错，组播会导致一些愚蠢的问题，并且导致集群变的脆弱（比如，一个网络工程师正在捣鼓网络，而没有告诉你，你会发现所有的节点突然发现不了对方了）。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;使用单播，你可以为 Elasticsearch 提供一些它应该去尝试连接的节点列表。 当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系 master 节点，并加入集群。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;这意味着你的单播列表不需要包含你的集群中的所有节点， 它只是需要足够的节点，当一个新节点联系上其中一个并且说上话就可以了。如果你使用 master 候选节点作为单播列表，你只要列出三个就可以了。 这个配置在 elasticsearch.yml 文件中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">discovery.zen.ping.unicast.hosts: [&quot;host1&quot;, &quot;host2:port&quot;]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>ES基础</title>
    <url>/2022/07/26/db/esbase/</url>
    <content><![CDATA[<h2 id="Elasticsearch-是做什么的"><a href="#Elasticsearch-是做什么的" class="headerlink" title="Elasticsearch  是做什么的"></a>Elasticsearch  是做什么的</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;Elasticsearch 是一个实时的分布式搜索分析引擎，它能让你以前所未有的速度和规模，去探索你的数据。 它被用作全文检索、结构化搜索、分析以及这三个功能的组合</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;通常情况下，我们从数据库中提取可用的知识出乎意料的低效，当然，你可以通过时间戳或精确值进行过滤，但是它们能够全文检索、处理同义词、通过相关性给文档评分么？ 它们能从同样的数据中生成分析与聚合数据吗？最重要的是，它们能实时地做到上述操作，而不经过大型批处理的任务么？</p>
<h2 id="Elasticsearch-是用什么实现的"><a href="#Elasticsearch-是用什么实现的" class="headerlink" title="Elasticsearch  是用什么实现的"></a>Elasticsearch  是用什么实现的</h2><p>Elasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。 Lucene 可以说是当下最先进、高性能、全功能的搜索引擎库—​无论是开源还是私有。</p>
<p>但是 Lucene 仅仅只是一个库。为了充分发挥其功能，你需要使用 Java 并将 Lucene 直接集成到应用程序中。 更糟糕的是，您可能需要获得信息检索学位才能了解其工作原理。Lucene 非常 复杂。</p>
<p>Elasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目的是使全文检索变得简单， 通过隐藏 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。</p>
<p>然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容：</p>
<ul>
<li>一个分布式的实时文档存储，每个字段 可以被索引与搜索</li>
<li>一个分布式实时分析搜索引擎</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据</li>
</ul>
<p>Elasticsearch 将所有的功能打包成一个单独的服务，这样你可以通过程序与它提供的简单的 RESTful API 进行通信， 可以使用自己喜欢的编程语言充当 web 客户端，甚至可以使用命令行（去充当这个客户端）</p>
<h3 id="Elasticsearch-面向文档"><a href="#Elasticsearch-面向文档" class="headerlink" title="Elasticsearch 面向文档"></a>Elasticsearch 面向文档</h3><p>Elasticsearch 是 面向文档 的，意味着它存储整个对象或 文档。Elasticsearch 不仅存储文档，而且 索引 每个文档的内容，使之可以被检索。在 Elasticsearch 中，我们对文档进行索引、检索、排序和过滤—​而不是对行列数据。这是一种完全不同的思考数据的方式，也是 Elasticsearch 能支持复杂全文检索的原因</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>ES</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql数据类型</title>
    <url>/2022/07/26/db/mysql/</url>
    <content><![CDATA[<h1 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h1><img src="/2022/07/26/db/mysql/mysqlint.png" class="" title="jvmmap">

<p>在整型类型中，有 signed 和 unsigned 属性，其表示的是整型的取值范围，默认为 signed</p>
<h2 id="浮点类型-高精度"><a href="#浮点类型-高精度" class="headerlink" title="浮点类型 高精度"></a>浮点类型 高精度</h2><ul>
<li>浮点类型  Float 和 Double</li>
</ul>
<p>MySQL 之前的版本中存在浮点类型 Float 和 Double，但这些类型因为不是高精度，也不是 SQL 标准的类型，所以在真实的生产环境中不推荐使用</p>
<ul>
<li>高精度类型 DECIMAL(8,2)</li>
</ul>
<blockquote>
<p>整形类型与自增</p>
<blockquote>
<p>用 BIGINT 做主键，而不是 INT<br>自增值并不持久化，可能会有回溯现象（MySQL 8.0 版本前）,MySQL 8.0 版本前，自增不持久化，自增值可能会存在回溯问题<br>资金类字段设计 建议采用BIG INT（8字节定长）,以分为单位</p>
</blockquote>
</blockquote>
<h1 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h1><p>MySQL 数据库的字符串类型有 CHAR、VARCHAR、BINARY、BLOB、TEXT、ENUM、SET。不同的类型在业务设计、数据库性能方面的表现完全不同，其中最常使用的是 CHAR、VARCHAR</p>
<p>CHAR(N) 用来保存固定长度的字符，N 的范围是 0 ~ 255，请牢记，N 表示的是字符，而不是字节。</p>
<p>VARCHAR(N) 用来保存变长字符，N 的范围为 0 ~ 65536， N 表示字符。</p>
<p>在超出 65536 个字符的情况下，可以考虑使用更大的字符类型 TEXT 或 BLOB，两者最大存储长度为 4G，其区别是 BLOB 没有字符集属性，纯属二进制存储</p>
<p>和 Oracle、Microsoft SQL Server 等传统关系型数据库不同的是，MySQL 数据库的 VARCHAR 字符类型，最大能够存储 65536 个字符，所以在 MySQL 数据库下，绝大部分场景使用类型 VARCHAR 就足够了</p>
<h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p>在表结构设计中，除了将列定义为 CHAR 和 VARCHAR 用以存储字符以外，还需要额外定义字符对应的字符集，因为每种字符在不同字符集编码下，对应着不同的二进制值。常见的字符集有 GBK、UTF8，通常推荐把默认字符集设置为 UTF8</p>
<p>而且随着移动互联网的飞速发展，推荐把 MySQL 的默认字符集设置为 UTF8MB4,否则，某些 emoji 表情字符无法在 UTF8 字符集下存储，比如 emoji 笑脸表情，对应的字符编码为 0xF09F988E</p>
<p>包括 MySQL 8.0 版本在内，字符集默认设置成 UTF8MB4，8.0 版本之前默认的字符集为 Latin1。因为不同版本默认字符集的不同，你要显式地在配置文件中进行相关参数的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">character-set-server = utf8mb4</span><br></pre></td></tr></table></figure>

<p>另外，不同的字符集，CHAR(N)、VARCHAR(N) 对应最长的字节也不相同。比如 GBK 字符集，1 个字符最大存储 2 个字节，UTF8MB4 字符集 1 个字符最大存储 4 个字节。所以从底层存储内核看，在多字节字符集下，CHAR 和 VARCHAR 底层的实现完全相同，都是变长存储</p>
<ul>
<li>正确设置字符集</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE emoji_test CHARSET utf8mb4;</span><br><span class="line">mysql&gt; ALTER TABLE emoji_test CONVERT TO CHARSET utf8mb4;</span><br></pre></td></tr></table></figure>

<h2 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h2><p>排序规则（Collation）是比较和排序字符串的一种规则，每个字符集都会有默认的排序规则，你可以用命令 SHOW CHARSET 来查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW CHARSET LIKE &#x27;utf8%&#x27;;</span><br><span class="line"></span><br><span class="line">+---------+---------------+--------------------+--------+</span><br><span class="line"></span><br><span class="line">| Charset | Description   | Default collation  | Maxlen |</span><br><span class="line"></span><br><span class="line">+---------+---------------+--------------------+--------+</span><br><span class="line"></span><br><span class="line">| utf8    | UTF-8 Unicode | utf8_general_ci    |      3 |</span><br><span class="line"></span><br><span class="line">| utf8mb4 | UTF-8 Unicode | utf8mb4_0900_ai_ci |      4 |</span><br><span class="line"></span><br><span class="line">+---------+---------------+--------------------+--------+</span><br><span class="line"></span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW COLLATION LIKE &#x27;utf8mb4%&#x27;;</span><br><span class="line"></span><br><span class="line">+----------------------------+---------+-----+---------+----------+---------+---------------+</span><br><span class="line"></span><br><span class="line">| Collation                  | Charset | Id  | Default | Compiled | Sortlen | Pad_attribute |</span><br><span class="line"></span><br><span class="line">+----------------------------+---------+-----+---------+----------+---------+---------------+</span><br><span class="line"></span><br><span class="line">| utf8mb4_0900_ai_ci         | utf8mb4 | 255 | Yes     | Yes      |       0 | NO PAD        |</span><br><span class="line"></span><br><span class="line">| utf8mb4_0900_as_ci         | utf8mb4 | 305 |         | Yes      |       0 | NO PAD        |</span><br><span class="line"></span><br><span class="line">| utf8mb4_0900_as_cs         | utf8mb4 | 278 |         | Yes      |       0 | NO PAD        |</span><br><span class="line"></span><br><span class="line">| utf8mb4_0900_bin           | utf8mb4 | 309 |         | Yes      |       1 | NO PAD        |</span><br><span class="line"></span><br><span class="line">| utf8mb4_bin                | utf8mb4 |  46 |         | Yes      |       1 | PAD SPACE     |</span><br></pre></td></tr></table></figure>

<p>排序规则以 _ci 结尾，表示不区分大小写（Case Insentive），_cs 表示大小写敏感，_bin 表示通过存储字符的二进制进行比较。需要注意的是，比较 MySQL 字符串，默认采用不区分大小的排序规则</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis集群</title>
    <url>/2022/07/26/db/redis/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>cd redis/src<br>make MALLOC=libc</p>
<p>cd redis<br>make &amp;&amp; make install</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 7001 # 客户端连接端口</span><br><span class="line">bind 12.3.10.222 #实例绑定的IP地址</span><br><span class="line">logfile &quot;usr/local/src/redis-5.0.14/logs/6479.log&quot;</span><br><span class="line">dir /usr/local/src/redis-5.0.14/datas_6479 # redis实例数据配置存储位置</span><br><span class="line">daemonize yes # 是否以后台进程的方式启动redis实例</span><br><span class="line">pidfile /var/run/redis_7001.pid # 指定该进程pidfile</span><br><span class="line"></span><br><span class="line">cluster-enabled yes # 开启集群模式</span><br><span class="line">cluster-config-file # 集群中该实例的配置文件，该文件会在data目录下生成</span><br><span class="line">appendonly yes # 开启aop日志</span><br><span class="line">protected-mode no # 关闭保护模式</span><br><span class="line">requirepass cx # master开启密码保护</span><br><span class="line">masterauth cx # replica同master交互密码</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> src/redis-server cluster/redis-6474.config  </span><br><span class="line"> src/redis-server cluster/redis-6475.config </span><br><span class="line"> src/redis-server cluster/redis-6476.config </span><br><span class="line"> src/redis-server cluster/redis-6477.config </span><br><span class="line"> src/redis-server cluster/redis-6478.config </span><br><span class="line"> src/redis-server cluster/redis-6479.config </span><br><span class="line"></span><br><span class="line">#文本替换</span><br><span class="line">:1,$s/6479/6474/gc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">src/redis-cli -p cx --cluster create 12.3.10.222:6479 12.3.10.222:6478 12.3.10.222:6477 12.3.10.222:6476 12.3.10.222:6475 12.3.10.222:6474 --cluster-replicas 1 -a cx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> ps aux|grep redis|grep -v &#x27;grep&#x27;|awk &#x27;&#123;print $2&#125;&#x27;|xargs kill -15</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>镜像构建</title>
    <url>/2021/10/28/docker/imagebuild/</url>
    <content><![CDATA[<p>[TOC]</p>
<img src="/2021/10/28/docker/imagebuild/576507.png" class="" title="docker架构图">

<h2 id="Docker镜像的创建方法"><a href="#Docker镜像的创建方法" class="headerlink" title="Docker镜像的创建方法"></a>Docker镜像的创建方法</h2><p>基于Dockerfile进行创建，docker build .</p>
<p>基于容器进行创建</p>
<span id="more"></span>



<h2 id="基于Dockerfile创建"><a href="#基于Dockerfile创建" class="headerlink" title="基于Dockerfile创建"></a>基于Dockerfile创建</h2><h3 id="Dockerfile构建需要的信息："><a href="#Dockerfile构建需要的信息：" class="headerlink" title="Dockerfile构建需要的信息："></a>Dockerfile构建需要的信息：</h3><p><strong>Dockerfile、Context 和 .dockerignore</strong>，build指令的执行时在Dorker daemon程序中，第一步就是地递归的将环境Context发送到daemon段，通常情况下会采用一个空的目录作为Context,并将Dockerfile文件至于Context目录中</p>
<p>通常情况下Context下要有一个名称为Dockerfile的文件，可以通过-f 指定任意位置的Dockerfile 文件</p>
<p>我们可以通过.dockerignore文件忽略上下文环境下的文件和目录</p>
<p>我们可以通过-t 来指定新的镜像的repository和标签信息,可以指定多个 -t 来对多个repository仓库的镜像image进行打标签</p>
<p>如：docker build -t shykes/myapp:1.0.2 -t shykes/myapp:latest .</p>
<h3 id="一个Dockerfile例子"><a href="#一个Dockerfile例子" class="headerlink" title="一个Dockerfile例子"></a>一个Dockerfile例子</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> centos:<span class="number">7</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> chenxiao@ruiyinxin.com</span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;0.2&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> description=<span class="string">&quot;测试创建sentinel&quot;</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/home/tomcat/log/&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">mkdir</span> -p /app/jdk</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> jdk /app/jdk</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> sentinel-dashboard.jar /app/</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> run.sh /app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> 777 /app/run.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;Asia/Shanghai&#x27;</span> &gt;/etc/timezone</span></span><br><span class="line"><span class="keyword">ENV</span> JAVA_HOME /app/jdk</span><br><span class="line"><span class="keyword">ENV</span> PATH $PATH:$JAVA_HOME/bin</span><br><span class="line"><span class="keyword">ENV</span> CLASSPATH .:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8088</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"><span class="comment">#CMD [&quot;sh&quot;,&quot;run.sh&quot;]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;./run.sh&quot;</span>]</span></span><br><span class="line"><span class="comment">#ENTRYPOINT [&quot;./run.sh&quot;]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/sh</span></span><br><span class="line">java -jar -Dspring.profiles.active=test sentinel-dashboard.jar</span><br></pre></td></tr></table></figure>

<h3 id="执行docker命令来创建docker镜像"><a href="#执行docker命令来创建docker镜像" class="headerlink" title="执行docker命令来创建docker镜像"></a>执行docker命令来创建docker镜像</h3><p>命令格式为 docker build -t ImageName:TagName    Dir</p>
<ul>
<li><code>-t</code> − 给镜像加一个Tag</li>
<li><code>ImageName</code> − 给镜像起的名称</li>
<li><code>TagName</code> − 给镜像的Tag名</li>
<li><code>Dir</code> − Dockerfile所在目录</li>
</ul>
<p>docker build -t bd/sentineld  .</p>
<ul>
<li><code>.</code> 表示当前目录，即Dockerfile所在目录</li>
</ul>
<h3 id="dockerignore"><a href="#dockerignore" class="headerlink" title=".dockerignore"></a>.dockerignore</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># comment</span><br><span class="line">*/temp*</span><br><span class="line">*/*/temp*</span><br><span class="line">temp?</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><code># comment</code></th>
<th>Ignored.</th>
</tr>
</thead>
<tbody><tr>
<td><code>*/temp*</code></td>
<td>Exclude files and directories whose names start with <code>temp</code> in any immediate subdirectory of the root. For example, the plain file <code>/somedir/temporary.txt</code> is excluded, as is the directory <code>/somedir/temp</code>.</td>
</tr>
<tr>
<td><code>*/*/temp*</code></td>
<td>Exclude files and directories starting with <code>temp</code> from any subdirectory that is two levels below the root. For example, <code>/somedir/subdir/temporary.txt</code> is excluded.</td>
</tr>
<tr>
<td><code>temp?</code></td>
<td>Exclude files and directories in the root directory whose names are a one-character extension of <code>temp</code>. For example, <code>/tempa</code> and <code>/tempb</code>are excluded.</td>
</tr>
</tbody></table>
<h2 id="指令解析"><a href="#指令解析" class="headerlink" title="指令解析"></a>指令解析</h2><h3 id="Dockerfile命令列表"><a href="#Dockerfile命令列表" class="headerlink" title="Dockerfile命令列表"></a>Dockerfile命令列表</h3><table>
<thead>
<tr>
<th><strong>指令</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>FROM 镜像</td>
<td>指定新镜像所基于的镜像，第一条指令必须为FROM指令，每创建一个镜像就需要一条FROM指令</td>
</tr>
<tr>
<td>MAINTAINER 名字</td>
<td>说明新镜像的维护人信息</td>
</tr>
<tr>
<td>RUN命令</td>
<td>在所基于的镜像上执行命令，并提交到新的镜像中</td>
</tr>
<tr>
<td>CMD [“要运行的程序”,“参数1”,“参数2”]</td>
<td>指令启动容器时要运行的命令或者脚本，Dockerfile只能有一条CMD命令，如果指定多条则只能最后一条被执行，</td>
</tr>
<tr>
<td>EXPOSE 端口号</td>
<td>指定新镜像加载到Docker时要开启的端口（EXPOSE暴露的是容器内部端口，需要再映射到一个外部端口上）</td>
</tr>
<tr>
<td>ENV 环境变量 变量值</td>
<td>设置一个环境变量的值，会被后面的RUN使用</td>
</tr>
<tr>
<td>ADD 源文件/目录 目标文件/目录</td>
<td>将源文件复制到目标文件（与COPY的区别是将本地tar文件解压到镜像中）</td>
</tr>
<tr>
<td>COPY 源文件/目录 目标文件/目录</td>
<td>将本地主机上的文件/目录复制到目标地点，源文件/目录要与Dockerfile在相同的目录中</td>
</tr>
<tr>
<td>VOLUME [“目录”]</td>
<td>在容器中创建一个挂载点（VOLUME是宿主机中的某一个目录挂载到容器中）</td>
</tr>
<tr>
<td>USER 用户名/UID</td>
<td>指定运行容器时的用户</td>
</tr>
<tr>
<td>WORKDIR 路径</td>
<td>为后续的RUN、CMD、ENTRYPOINT指定工作目录（WORKDIR类似于cd，但是只切换目录一次，后续的RUN命令就可以写相对路径了）</td>
</tr>
<tr>
<td>ONBUILD 命令</td>
<td>指定所生成的镜像作为一个基础镜像时所要运行的命令</td>
</tr>
<tr>
<td>HEALTHCHECK</td>
<td>健康检查</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td>指令和CMD类似，它也是用户指定容器启动时要执行的命令，但如果dockerfile中也有CMD指令，CMD中的参数会被附加到ENTRYPOINT指令的后面。 如果这时docker run命令带了参数，这个参数会覆盖掉CMD指令的参数，并也会附加到ENTRYPOINT 指令的后面。优先级：ENTRYPOINT&gt;CMD&gt;docker run</td>
</tr>
</tbody></table>
<h3 id="启动执行脚本-ENTRYPOINT-CMD"><a href="#启动执行脚本-ENTRYPOINT-CMD" class="headerlink" title="启动执行脚本 ENTRYPOINT CMD"></a>启动执行脚本 ENTRYPOINT CMD</h3><p><img src="https://img.jbzj.com/file_images/article/201803/2018031211363722.png" alt="img"></p>
<p><strong>shell 模式</strong></p>
<p>使用 shell 模式时，docker 会以 <code>/bin/sh -c &quot;task command&quot;</code> 的方式执行任务命令</p>
<p><strong>exec 模式</strong></p>
<p>使用 exec 模式时，容器中的任务进程就是容器内的 1 号进程</p>
<p>我们大概可以总结出下面几条规律：</p>
<p>   • 如果 ENTRYPOINT 使用了 shell 模式，CMD 指令会被忽略。</p>
<p>   • 如果 ENTRYPOINT 使用了 exec 模式，CMD 指定的内容被追加为 ENTRYPOINT 指定命令的参数。</p>
<p>   • 如果 ENTRYPOINT 使用了 exec 模式，CMD 也应该使用 exec 模式。</p>
<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt; [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[:&lt;tag&gt;] [AS &lt;name&gt;]</span><br><span class="line"><span class="keyword">FROM</span> [--platform=&lt;platform&gt;] &lt;image&gt;[@&lt;digest&gt;] [AS &lt;name&gt;]</span><br></pre></td></tr></table></figure>

<p> Dockerfile必须是以FROM指令开始</p>
<p><code>ARG</code> 是唯一一个优先于 地位高于 FROM指令的，</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ARG</span> VERSION=latest</span><br><span class="line"><span class="keyword">FROM</span> busybox:$VERSION</span><br><span class="line"><span class="keyword">ARG</span> VERSION</span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$VERSION</span> &gt; image_version</span></span><br></pre></td></tr></table></figure>

<p>–platform，指定镜像能被使用的平台信息，默认情况下是执行build request的平台信息被作为platform，如：linux/amd64<code>, </code>linux/arm64，windows/amd64</p>
<p><code>as name</code>通查是可选的，他可以指定自定义构建步骤的名称</p>
<h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><p>RUN指令执行有两种形式</p>
<p>shell形式  RUN  <command>，此指令执行在shell上下文环境中，默认是 /bin/sh -c  ’code‘</p>
<p>exec 形式 RUN  [“executable”, “param1”, “param2”]，exec 模式会将后续的参数解析成json 数组，也就是说我们的参数需要用双引号包括，而不是单引号。</p>
<p>run命令的每次执行在当前镜像的最顶层生成新的层，并提交结果，并且将在下一个步骤中使用，也就是说每层之间是独立的，shell环境也是独立的。我们可以使用  <code>\</code> 来使用多行单指令 如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc; \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">echo $HOME&#x27;</span></span></span><br><span class="line"><span class="comment">#两者含义相同</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc; echo $HOME&#x27;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><ul>
<li><code>CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</code> exec模式</li>
<li><code>CMD [&quot;param1&quot;,&quot;param2&quot;] 作为</code>ENTRYPOINT 的默认参数</li>
<li><code>CMD command param1 param2</code> <em>shell</em> 模式</li>
</ul>
<p>不可将run与cmd指令混淆，run指令会执行命令，并提交结果，cmd并不执行任何东西，在构建的过程当中，他只指定镜像启动预期指令</p>
<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; </span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> <span class="string">&quot;com.example.vendor&quot;</span>=<span class="string">&quot;ACME Incorporated&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> com.example.label-with-value=<span class="string">&quot;foo&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> description=<span class="string">&quot;This text illustrates \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">that label-values can span multiple lines.&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> multi.label1=<span class="string">&quot;value1&quot;</span> multi.label2=<span class="string">&quot;value2&quot;</span> other=<span class="string">&quot;value3&quot;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> multi.label1=<span class="string">&quot;value1&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      multi.label2=<span class="string">&quot;value2&quot;</span> \</span></span><br><span class="line"><span class="language-bash">      other=<span class="string">&quot;value3&quot;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</span><br></pre></td></tr></table></figure>

<p>默认情况下expose 使用的tcp协议，也可以显示指定</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -p 80:80/tcp -p 80:80/udp ...</span></span><br></pre></td></tr></table></figure>

<h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure>

<p>env指令设置环境变量信息，那么环境变量信息，将存在于后续构建的各个阶段，</p>
<p>可以通过运行镜像，并指定环境变零的方式对镜像中设置的环境变量进行变更<code>docker run --env &lt;key&gt;=&lt;value&gt;</code>.</p>
<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD [--chown=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span><br><span class="line">ADD [--chown=&lt;user&gt;:&lt;group&gt;] [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span><br></pre></td></tr></table></figure>

<p>–chown指令只支持linux系统上构建的镜像，在windows环境中并不工作，如果不指定用户或者用户组，默认使用 a UID and GID of 0</p>
<p>src： 可使用通配符，并且路径都是相对于Context的相对路径</p>
<p>​         网络上的远程文件url，如果url不是以斜线结尾，那么将被报错在dest目录下，如果是以斜线结尾，那么问题名称将被推理出来，</p>
<p>​          如 ADD <a href="http://example.com/foobar/">http://example.com/foobar/</a>  将创建问文件  /foobar，URL必须有一个非平凡的路径，这样才能找到适当的文件名。<a href="http://example.com/">http://example.com</a> 不会工作</p>
<p>​          文件必须存在于Context中，不能使用../ 因为build第一步是发送context到docker daemon程 序</p>
<p>​          如果src是一个目录，那么目录的整个内容将被复制，COPY jdk /app/jdk</p>
<p>​          如果src是一个压缩文件(identity, gzip, bzip2 or xz) ，那么src将被解压到目标目录</p>
<p>dest： 目标路径如果不是以 / 开头的话是以WORKDIR为目录的相对路径</p>
<p>​        如果dest不存在，那么整个路径将被创建</p>
<p>​        如果dest不是以斜线结尾，那么dest将被认为是一个常规文件，src的内容将被写入到文件</p>
<p>​        如果src是多个资源，或者使用了通配符，那么dest必须要以斜线结尾</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD hom* /mydir/</span><br><span class="line">ADD hom?.txt /mydir/</span><br><span class="line">ADD test.txt relativeDir/</span><br><span class="line">ADD test.txt /absoluteDir/</span><br><span class="line"></span><br><span class="line">ADD --chown=55:mygroup files* /somedir/</span><br><span class="line">ADD --chown=bin files* /somedir/</span><br><span class="line">ADD --chown=1 files* /somedir/</span><br><span class="line">ADD --chown=10:11 files* /somedir/</span><br></pre></td></tr></table></figure>

<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] &lt;src&gt;... &lt;dest&gt;</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [--<span class="built_in">chown</span>=&lt;user&gt;:&lt;group&gt;] [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>src : 文件必须存在于Context中</p>
<p>​        如果src是一个目录，那么他的内容和元数据信息将被拷贝到目标目录 COPY jdk /app/jdk</p>
<p>​        如果src是一个文件，并且dest 是以斜线结尾，那么文件将被拷贝到目录下，如 dest/src </p>
<p>dest: 如果目录不存在，那么整个文件目录将被创建</p>
<p>​         如果dest没有是以斜杠结尾，那么他将被看做事一个普通文件，并且src将被写入到dest</p>
<p>​          如果src是多资源文件，那么dest必须是以斜杠结尾</p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]   <span class="comment">#exec模式</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="built_in">command</span> param1 param2                <span class="comment">#shell模式</span></span></span><br></pre></td></tr></table></figure>

<ol>
<li>Dockerfile 最少需要制定一个CMD或者ENTRYPOINT指令</li>
<li>当容器是可执行的情况下，应该定义ENTRYPOINT</li>
<li>CMD应该被用来定义ENTRYPOINT 的默认参数，</li>
<li>CMD参数可以在容器运行的时候被替换掉，ENTRYPOINT则不行</li>
</ol>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><strong>No ENTRYPOINT</strong></th>
<th align="left"><strong>ENTRYPOINT exec_entry p1_entry</strong></th>
<th><strong>ENTRYPOINT [“exec_entry”, “p1_entry”]</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>No CMD</strong></td>
<td align="left"><em>error, not allowed</em></td>
<td align="left">/bin/sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry</td>
</tr>
<tr>
<td align="left"><strong>CMD [“exec_cmd”, “p1_cmd”]</strong></td>
<td align="left">exec_cmd p1_cmd</td>
<td align="left">/bin/sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry exec_cmd p1_cmd</td>
</tr>
<tr>
<td align="left"><strong>CMD [“p1_cmd”, “p2_cmd”]</strong></td>
<td align="left">p1_cmd p2_cmd</td>
<td align="left">/bin/sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry p1_cmd p2_cmd</td>
</tr>
<tr>
<td align="left"><strong>CMD exec_cmd p1_cmd</strong></td>
<td align="left">/bin/sh -c exec_cmd p1_cmd</td>
<td align="left">/bin/sh -c exec_entry p1_entry</td>
<td>exec_entry p1_entry /bin/sh -c exec_cmd p1_cmd</td>
</tr>
</tbody></table>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/data&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>VOLUME指令将从本地主机或者其他的容器创建一个挂载点并使用给定的名称，他的值可以是一个json数组VOLUME [“/var/log/“]，或者是一个字符串 VOLUME /var/log。 或者是多个VOLUME /var/log /var/db。</p>
<p>如果是基于windows的容器，那么这数据卷必须是一个不存在的或者是一个空的目录，并且是C盘以外的数据驱动</p>
<p>volume在声明之后，如果在build的过程中的每一个步骤对volume内容的修改都将被忽略，</p>
<p>声明的时候如果是json数据，必须是以双引号进行包括，而不是单引号</p>
<p>VOLUME指令挂在的目录，并不能通过host_dir来指定映射到主机那个目录，他是在运行容器的时候才确定的，你必须指定一个挂载点，当你创建或者启动一个容器的时候，</p>
<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">USER</span> &lt;<span class="keyword">user</span>&gt;[:&lt;group&gt;]</span><br><span class="line"><span class="keyword">USER</span> &lt;UID&gt;[:&lt;GID&gt;]</span><br></pre></td></tr></table></figure>

<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br></pre></td></tr></table></figure>

<p>ARG指令可以在构建的过程中定义一些参数，并设置一些默认值，并且在build的时候可以指定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build --build-arg user=what_user .</span><br></pre></td></tr></table></figure>

<p><strong>默认值；</strong>如果build的时候没有指定–build-arg user1=what_user 那么someuser将被作为默认值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">ARG user1=someuser</span><br><span class="line">ARG buildno=1</span><br></pre></td></tr></table></figure>

<p><strong>作用域：</strong>以下示例，第二行将使用some_user来作为值来使用，第四行将使用what_user，ARG指令定义的变量是从他定义的行开始生效的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM busybox</span><br><span class="line">USER $&#123;user:-some_user&#125;</span><br><span class="line">ARG user</span><br><span class="line">USER $user</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build --build-arg user=what_user .</span><br></pre></td></tr></table></figure>

<p><strong>使用ARG变量：</strong>ENV指令将会覆盖ARG同名参数，如下将使用v1.0.0，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">ARG CONT_IMG_VER</span><br><span class="line">ENV CONT_IMG_VER=v1.0.0</span><br><span class="line">RUN echo $CONT_IMG_VER</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build --build-arg CONT_IMG_VER=v2.0.1 .</span><br></pre></td></tr></table></figure>

<p><strong>ENV和ARG</strong>：ARG变量并不能像EVN环境变量那样保存在镜像之中</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ARG</span> CONT_IMG_VER</span><br><span class="line"><span class="keyword">ENV</span> CONT_IMG_VER=$&#123;CONT_IMG_VER:-v1.<span class="number">0.0</span>&#125;   <span class="comment">#可带有默认值</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="variable">$CONT_IMG_VER</span></span></span><br></pre></td></tr></table></figure>

<p>Docker中包含一些默认的ARG参数，可以不用再Dockerfile中生命</p>
<ul>
<li><p><code>HTTP_PROXY</code></p>
</li>
<li><p><code>http_proxy</code></p>
</li>
<li><p><code>HTTPS_PROXY</code></p>
</li>
<li><p><code>https_proxy</code></p>
</li>
<li><p><code>FTP_PROXY</code></p>
</li>
<li><p><code>ftp_proxy</code></p>
</li>
<li><p><code>NO_PROXY</code></p>
</li>
<li><p><code>no_proxy</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build --build-arg HTTPS_PROXY=https://my-proxy.example.com .</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Docker默认的ARG全局范围内的平台参数，这些参数是在全局范围中定义的，因此在构建阶段或运行命令中不自动可用。要在构建阶段中公开这些参数之一，请在没有值的情况下重新定义它</p>
<ul>
<li><p><code>TARGETPLATFORM</code> - platform of the build result. Eg <code>linux/amd64</code>, <code>linux/arm/v7</code>, <code>windows/amd64</code>.</p>
</li>
<li><p><code>TARGETOS</code> - OS component of TARGETPLATFORM</p>
</li>
<li><p><code>TARGETARCH</code> - architecture component of TARGETPLATFORM</p>
</li>
<li><p><code>TARGETVARIANT</code> - variant component of TARGETPLATFORM</p>
</li>
<li><p><code>BUILDPLATFORM</code> - platform of the node performing the build.</p>
</li>
<li><p><code>BUILDOS</code> - OS component of BUILDPLATFORM</p>
</li>
<li><p><code>BUILDARCH</code> - architecture component of BUILDPLATFORM</p>
</li>
<li><p><code>BUILDVARIANT</code> - variant component of BUILDPLATFORM</p>
<p>如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM alpine</span><br><span class="line">ARG TARGETPLATFORM</span><br><span class="line">RUN echo &quot;I&#x27;m building for $TARGETPLATFORM&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ONBUILD &lt;INSTRUCTION&gt;</span><br></pre></td></tr></table></figure>

<p>这是一个触发器指令，镜像构建时候定义，当别的镜像基于当前镜像进行构建的时候 ONBUILD指令将在FROM指令后首先触发基础镜像的ONBUILD指令，</p>
<p>他注册了一个超前指令，并在之后运行，运行环境是构建容器的Context，如果有一个指令失败，那么FROM指令将是失败的</p>
<p>他能在docker inspect指令中被观察到</p>
<p>ONBUILD 只在直接FROM Dockerfile中生效，也就是多级A FROM B FROM C ,那么c的ONBILD 不会再A中生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br></pre></td></tr></table></figure>

<p>ONBUILD不支持连续使用，ONBUILD ONBUILD</p>
<p>ONBUILD不会触发FROM 和 MAINTAINER指令</p>
<h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br></pre></td></tr></table></figure>

<p>默认的STOPSIGNAL 可以使用–stop-signal 标记，在docker run 和docker create 的时候修改掉</p>
<h3 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h3><ul>
<li><p><code>HEALTHCHECK [OPTIONS] CMD command</code> (check container health by running a command inside the container)</p>
</li>
<li><p><code>HEALTHCHECK NONE</code> (disable any healthcheck inherited from the base image)</p>
<p>HEALTHCHECK 指令告诉Docker如何测试容器是否在工作。</p>
<p>当指定了HEALTHCHECK 那么容器除了正常的状态，会添加一些健康状态，初始化是starting，当健康检查通过，状态为healthy，当经理了一系列的故障之后，将变更为unhealthy</p>
<ul>
<li><code>--interval=DURATION</code> (default: <code>30s</code>)</li>
<li><code>--timeout=DURATION</code> (default: <code>30s</code>)</li>
<li><code>--start-period=DURATION</code> (default: <code>0s</code>)</li>
<li><code>--retries=N</code> (default: <code>3</code>)</li>
</ul>
</li>
<li><p>0: success - the container is healthy and ready for use</p>
</li>
<li><p>1: unhealthy - the container is not working correctly</p>
</li>
<li><p>2: reserved - do not use this exit code 预留的状态</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HEALTHCHECK --interval=5m --timeout=3s CMD curl -f http://localhost/ || exit 1</span><br></pre></td></tr></table></figure>

<h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p>shell指令运行将默认的shell进行调整，默认的linux shell 是[“/bin/sh”, “-c”] Windows 是<code>[&quot;cmd&quot;, &quot;/S&quot;, &quot;/C&quot;]</code></p>
<p>shell ，在Dockerfile中必须是json模式的</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>链接Docker守护进程认证</title>
    <url>/2021/11/07/docker/logindmauth/</url>
    <content><![CDATA[<p><a href="https://docs.docker.com/engine/security/protect-access/">https://docs.docker.com/engine/security/protect-access/</a></p>
<p>SSH保护</p>
<p>TLS保护</p>
<p>CA,SERVER和client keys</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>面向对象设计中的要素与原则有哪些</title>
    <url>/2021/09/13/java/Designprinciples/</url>
    <content><![CDATA[<p>面向对象是基于万物皆是对象这个哲学观点，把一个对象抽象成类，具体就是把一个对象的静态特这和动态特征抽象成属性和方法，也就是把一类事物的数据结构及算法封装在一个类之中，程序是多个对象和互相之间的通信组成的。</p>
<span id="more"></span>

<h1 id="面向对象设计的三个基本要素"><a href="#面向对象设计的三个基本要素" class="headerlink" title="面向对象设计的三个基本要素"></a>面向对象设计的三个基本要素</h1><img src="/2021/09/13/java/Designprinciples/58e757d32da94.png" class="" title="面向对象设计的三个基本要素">

<ul>
<li><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>一种信息隐蔽技术，他体现于类的说明，是对象重要的特性。封装使得数据和操作数据的方法封装为一个整体，想成独立性很强的模块，使得用户只能看到对象的外部特性（对象可以接受拿些信息，可以进行何种处理），而对象的内部特性（内部私有属性和实现处理能力的算法）用户是看不到的。简而言之就是说，封装使对象的设计者与对象的使用者分开，使用者只要知道对象可以做什么就可以了，无需知道具体是怎么实现的。借助封装有助于提高类和系统的安全性。</p>
</li>
<li><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="继承的概述"><a href="#继承的概述" class="headerlink" title="继承的概述"></a>继承的概述</h4><p>​    继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码，能够大大的提高开发的效率。</p>
<p>​    诚然，继承定义了类如何相互关联，共享特性。对于若干个相同或者相识的类，我们可以抽象出他们共有的行为或者属相并将其定义成一个父类或者超类，然后用这些类继承该父类，他们不仅可以拥有父类的属性、方法还可以定义自己独有的属性或者方法。</p>
<h4 id="使用继承时需要记住三句话"><a href="#使用继承时需要记住三句话" class="headerlink" title="使用继承时需要记住三句话"></a>使用继承时需要记住三句话</h4><ol>
<li><p>子类拥有父类非private的属性和方法。</p>
</li>
<li><p>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
</li>
<li><p>子类可以用自己的方式实现父类的方法（重写）</p>
</li>
</ol>
<p>  学习继承一定少不了这三个东西：<em><strong>构造器、protected关键字、向上转型</strong></em></p>
<p>​    通过前面我们知道子类可以继承父类的属性和方法，除了那些private的外还有一样是子类继承不了的—构造器。对于构造器而言，它只能够被调用，而不能被继承。 调用父类的构造方法我们使用super()即可。</p>
<p>​    构建过程是从父类“向外”扩散的，也就是从父类开始向子类一级一级地完成构建。而且我们并没有显示的引用父类的构造器，这就是java的聪明之处：编译器会默认给子类调用父类的构造器。</p>
<p>​    但是，这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。</p>
<p>​    对于子类而已,其构造器的正确初始化是非常重要的,而且当且仅当只有一个方法可以保证这点：在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。</p>
<p>​    对于继承而言，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。</p>
<p>​    private访问修饰符，对于封装而言，是最好的选择，但这个只是基于理想的世界，有时候我们需要这样的需求：我们需要将某些事物尽可能地对这个世界隐藏，但是仍然允许子类的成员来访问它们。这个时候就需要使用到protected。</p>
<p>​    对于protected而言，它指明就类用户而言，他是private，但是对于任何继承与此类的子类而言或者其他任何位于同一个包的类而言，他却是可以访问的。</p>
<h4 id="谨慎继承"><a href="#谨慎继承" class="headerlink" title="谨慎继承"></a><strong>谨慎继承</strong></h4><p>在这里我们需要明确，继承存在如下缺陷：</p>
<ol>
<li><p>父类变，子类就必须变。</p>
</li>
<li><p>继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。</p>
</li>
<li><p>继承是一种强耦合关系。</p>
</li>
</ol>
<p>所以说当我们使用继承的时候，我们需要确信使用继承确实是有效可行的办法。那么到底要不要使用继承呢？《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。</p>
<p>一般情况下我们通过抽象的类来定义模板方法，具体执行方法交由实现类来实现，不同的实现有不同的处理算法，但是具体的执行逻辑由抽象类来控制，如ApplicationContext 中AbstractApplicationContext的refresh方法</p>
</li>
<li><h3 id="多态-多态分为编译时多态和运行时多态"><a href="#多态-多态分为编译时多态和运行时多态" class="headerlink" title="多态(多态分为编译时多态和运行时多态)"></a>多态(<strong>多态分为编译时多态和运行时多态</strong>)</h3><ol>
<li><h4 id="多态的综述"><a href="#多态的综述" class="headerlink" title="多态的综述"></a><strong>多态的综述</strong></h4></li>
</ol>
<p>​    所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</p>
<p>​    所以对于多态我们可以总结如下：</p>
<p>   指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。</p>
<p>​    对于面向对象而言，多态分为编译时多态和运行时多态。其中编程时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编程之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</p>
<ol start="2">
<li><h4 id="多态实现的条件（继承、重写、向上转型）"><a href="#多态实现的条件（继承、重写、向上转型）" class="headerlink" title="多态实现的条件（继承、重写、向上转型）"></a><strong>多态实现的条件</strong>（<em><strong>继承、重写、向上转型</strong></em>）</h4></li>
</ol>
<p>​    继承：在多态中必须存在有继承关系的子类和父类。<br>​    重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。<br>​    向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</p>
<p>​    只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</p>
<p>​    对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</p>
<ol start="3">
<li><h4 id="实现形式"><a href="#实现形式" class="headerlink" title="实现形式"></a><strong>实现形式</strong></h4></li>
</ol>
<p>​    在Java中有两种形式可以实现多态：继承和接口</p>
<h5 id="a-基于继承实现的多态"><a href="#a-基于继承实现的多态" class="headerlink" title="a. 基于继承实现的多态"></a><strong>a. 基于继承实现的多态</strong></h5><p>​     基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为,对于引用子类的父类类型，在处理该引用时，它适用于继承该父类的所有子类，子类对象的不同，对方法的实现也就不同，执行相同动作产生的行为也就不同。</p>
<h5 id="b-基于接口实现的多态"><a href="#b-基于接口实现的多态" class="headerlink" title="b. 基于接口实现的多态"></a><strong>b. 基于接口实现的多态</strong></h5><p>​    在接口的多态中，指向接口的引用必须是指定这实现了该接口的一个类的实例程序，在运行时，根据对象引用的实际类型来执行对应的方法，继承都是单继承，只能为一组相关的类提供一致的服务接口。但是接口可以是多继承多实现，它能够利用一组相关或者不相关的接口进行组合与扩充，能够对外提供一致的服务接口。所以它相对于继承来说有更好的灵活性。</p>
</li>
</ul>
<h1 id="面向对象七种设计原则"><a href="#面向对象七种设计原则" class="headerlink" title="面向对象七种设计原则"></a>面向对象七种设计原则</h1><p>一个好的系统设计应该有如下的性质</p>
<ul>
<li>可扩展性（Extensibility）：可以很容易的在系统中加入一个新的功能</li>
<li>灵活性（Flexibility）：可以很容易的实现对某个代码的修改，而不担心对其他模块产生影响</li>
<li>可插入性（Pluggability）：可以很容易的将一个类抽出去复用，或者将另一个有同样功能的接口的类加入到系统里</li>
</ul>
<p>面向对象的设计原则都是以可维护性、可复用性、扩展性为基础的，这些原则相互依赖，相互补充，遵循这些设计原则可以提高系统的复用性，扩展性，同时提高系统的可维护性。</p>
<table>
<thead>
<tr>
<th>原则</th>
<th align="left">简称</th>
<th>核心思想</th>
<th align="left">概述</th>
</tr>
</thead>
<tbody><tr>
<td>单一功能原则</td>
<td align="left">Single Responsibility Principle, SRP</td>
<td>解耦和增强内聚性（高内聚，低耦      合）</td>
<td align="left">类被修改的几率很大，因此应该专注于单一的功能。<br />如果你把多个功能放在同一个类中，功能之间就形成了关联，<br />改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题</td>
</tr>
<tr>
<td>开闭原则</td>
<td align="left">Open-Closed Principle, OCP</td>
<td>对扩展开放，对修改关闭</td>
<td align="left">扩展开放：模块添加新功能，不改变原有的代码,<br />修改关闭：某模块被其他模块调用，<br />如果该模块的源代码不允许修改，则该模块修改关闭的</td>
</tr>
<tr>
<td>里氏替换原则</td>
<td align="left">Liskov Substitution Principle, LSP</td>
<td>任何父类出现的地方，子类都可以替代出现</td>
<td align="left">任何父类出现的地方，子类都可以替代出现，把基类替换成它的子类，程序将不会产生任务错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类</td>
</tr>
<tr>
<td>依赖倒转原则</td>
<td align="left">Dependence Inversion Principle, DIP</td>
<td>要依赖于抽象，不要依赖于具体的实现</td>
<td align="left"></td>
</tr>
<tr>
<td>接口分离原则</td>
<td align="left">Interface Segregation Principle, ISP</td>
<td>不应该强迫客户程序依赖他们不需要使用的方法</td>
<td align="left">一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口当中</td>
</tr>
<tr>
<td>合成复用原则</td>
<td align="left">Composite Reuse Principle, CRP</td>
<td>尽量使用对象组合，而不是继承来达到复用的目的</td>
<td align="left">继承关系是强耦合，组合关系是低耦合</td>
</tr>
<tr>
<td>迪米特原则</td>
<td align="left">Law of Demeter, LoD</td>
<td>又称最少知识原则,一个对象应当对其他对象有尽可能少的了解,不和陌生人说话</td>
<td align="left">降低各个对象之间的耦合，提高系统的可维护性</td>
</tr>
</tbody></table>
<h2 id="开闭原则："><a href="#开闭原则：" class="headerlink" title="开闭原则："></a>开闭原则：</h2><p>开闭原则对扩展开放对修改关闭，并不意味着我们的代码不能做出任何变更，开闭原则是我们开发应用程序的目标，<strong>抽象化是开闭原则实现的关键，通过接口或者抽象类来完成对修改的封闭约束，不允许出现在接口中或者抽象类中不存在的public方法，采用抽象类的具体实现或者接口多实现类以及多态性的方式来完成业务功能的扩展，以实现对功能修改的关闭，对功能实现的扩展，里氏替换原则是实现开闭原则的重要方式之一。</strong></p>
<h2 id="里氏替换原则："><a href="#里氏替换原则：" class="headerlink" title="里氏替换原则："></a>里氏替换原则：</h2><p>里氏替换原则主要是针对继承的设计原则，<strong>它为良好的继承定义了一个规范</strong>，当我们考虑使用继承的时候需要考虑里氏替换原则，并且里氏替换原则是实现开闭原则的重要方式之一</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）可以放大（比父类方法的输入参数更宽松）</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）可以被缩小（比父类更严格）</li>
</ul>
<p><strong>如果父类的某些方法在子类中已经不能使用，则建议断开父子继承关系，采用依懒，聚合，组合关系代替继承</strong></p>
<h2 id="依懒倒置原则"><a href="#依懒倒置原则" class="headerlink" title="依懒倒置原则"></a>依懒倒置原则</h2><p>依赖倒置原则规定了我们编程的方式，要针对抽象层编程，而不是针对具体实现编程，搞层模块不应依赖底层实现模块，他们都应该依赖抽象，抽象不应该依赖袭击，细节应该依赖于抽象，换句话说，开闭原则是我们开发软件要实现的目标，依赖倒置原则规定了我们开发编程时候的开发方式。</p>
<p>依赖倒置原则的常用实现方式之一是在代码中使用抽象类，而具体的实现可使用动态的特性，在运行时根据业务数据选择不同的执行策略，这些具体实现可以放入配置文件或者容器中，具体业务动态绑定到具体的实现，也是为了实现开闭原则目标的方式。</p>
<p><strong>依懒的三种写法</strong></p>
<p>构造函数传递依懒对象，也叫构造函数注入</p>
<p>Setter方法传递依懒对象，也叫Setter依懒注入</p>
<p>接口声明依懒对象，也叫接口注入，就是在接口的方法参数中声明依懒对象。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>接口隔离原则要求我们不要建立功能丰富的庞大接口，使用多个专门的接口来取代一个统一的接口。<strong>每一个接口应该承担一种相对独立的角色，不多不少，不干不该干的事，该干的事都要干，在具体程序上，避免操作越界，通过接口的控制操作的界限，如使用依赖倒置原则，依赖接口进行开发，查询接口只提供查询功能，在查询逻辑中禁止修改逻辑，依赖单一功能接口可避免查询中进行修改这种越界操作提高系统安全性</strong>，接口隔离原则告诉我们：使用多个隔离的接口，比使用单个接口要好，尽量降低类之间的耦合度。</p>
<ol>
<li>一个接口就只代表一个角色，每个角色都有它特定的一个接口。 </li>
<li>接口仅仅提供客户端需要的行为，即所需的方法，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。</li>
<li>使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</li>
</ol>
<p>具体使用如BeanDefinitionRegistry，BeanFactory ，BeanFactory 定义获取bean的接口，BeanDefinitionRegistry定义注册beanDefinition的接口，是获取和注册功能拆分，在获取的时候依赖于BeanFactory ，在注册的时候依赖于BeanDefinitionRegistry，避免获取的时候进行注册等越界操作</p>
<p><strong>综合各种面向对象的原则，都是从不同较多描述了 对 ”抽象“ 的使用，开闭原则是从开发目标的角度描述了抽象，替换原则从如何实现抽象的角度描述了抽象，依赖倒置原则从编程方式的角度描述了抽象，接口隔离原则从责任及安全的角度描述了抽象，总的来说都是对现实世界抽象的使用，以及抽象能带来的益处的总结。</strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title>问题归类</title>
    <url>/2021/09/15/java/Interviewquestions/</url>
    <content><![CDATA[<h1 id="语言基础"><a href="#语言基础" class="headerlink" title="语言基础"></a>语言基础</h1><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h2><p>java中守护线程和本地线程的区别</p>
<p>java中ReadWriteLock是什么</p>
<p>volatile变量和atomic变量有什么区别</p>
<p>线程优先级的理解</p>
<span id="more"></span>

<h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><p>可达性分析算法中根节点有哪些</p>
<p>CMS和G1区别有哪些</p>
<p>怎样GC调优</p>
<p>怎样排查CPU彪高内存彪高</p>
<p>逃逸分析</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h1 id="框架类"><a href="#框架类" class="headerlink" title="框架类"></a>框架类</h1><h2 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h2><h3 id="spring-1"><a href="#spring-1" class="headerlink" title="spring"></a>spring</h3><p>spring循环依赖怎么解决</p>
<p>spring aop原理及相关的概念</p>
<p>springbean生命周期，设计思路及扩展</p>
<p>有哪些不同类型的IOC方式</p>
<h3 id="springboot"><a href="#springboot" class="headerlink" title="springboot"></a>springboot</h3><h3 id="springcloud"><a href="#springcloud" class="headerlink" title="springcloud"></a>springcloud</h3><h3 id="springmvc"><a href="#springmvc" class="headerlink" title="springmvc"></a>springmvc</h3><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><p>mybatis框架的缺点是什么</p>
<p>mybatis与hibernate有哪些不同</p>
<p>mybatis是如何进行分页的分页插件的原理是什么</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="分布式一致性问题"><a href="#分布式一致性问题" class="headerlink" title="分布式一致性问题"></a>分布式一致性问题</h2><h2 id="缓存及缓存一致性问题"><a href="#缓存及缓存一致性问题" class="headerlink" title="缓存及缓存一致性问题"></a>缓存及缓存一致性问题</h2><h2 id="分布式事务问题"><a href="#分布式事务问题" class="headerlink" title="分布式事务问题"></a>分布式事务问题</h2><h2 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h2><p>应用场景有哪些</p>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="reids"><a href="#reids" class="headerlink" title="reids"></a>reids</h2><p>redis数据类型</p>
<p>redisqps能上多少，怎么知道的</p>
<p>redis单线程为什么快</p>
<p>本地缓存需要高时效性怎么办</p>
<p>redis同步机制</p>
<p>redis如何实现分布式锁，他是怎么回事</p>
<h2 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h2><h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><p>tomcat的缺省端口是多少，怎么改</p>
<p>tomcat有哪几种connector运行模式（优化）？</p>
<p>tomcat有哪几种部署方式</p>
<p>tomca容器如何创建servlet类实例的，用了什么原理</p>
<p>tomcat如何优化</p>
<p>tomcat内存调优</p>
<p>垃圾回收策略调优</p>
<p>添加jms远程监控</p>
<p>专业点的分析工具有哪些</p>
<p>关于tomcat的session数目</p>
<p>监视tomcat的内存使用情况</p>
<p>tomcat的一个请求的完整过程</p>
<p>tomcat的工作模式</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h1 id="设计模式类"><a href="#设计模式类" class="headerlink" title="设计模式类"></a>设计模式类</h1><h1 id="场景类"><a href="#场景类" class="headerlink" title="场景类"></a>场景类</h1><h1 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h1><h2 id="mavne"><a href="#mavne" class="headerlink" title="mavne"></a>mavne</h2><p>maven有哪些优点和缺点</p>
<p>maven坐标</p>
<p>maven常见的依赖范围有哪些</p>
<p>maven的生命周期</p>
<p>依赖解析机制</p>
<p>插件解析机制</p>
<p>多模块如何聚合</p>
<p>对于一个多模块项目如何管理依赖版本</p>
<p>如何保证传递依赖不起冲突</p>
<p>常见的maven私服仓库类型</p>
<p>如何查询一个插件有哪些目标</p>
<p>maven和ant有什么区别</p>
<p>maven的工程类型有哪些</p>
<p>maven的常用命令有哪些</p>
<h1 id="管理类"><a href="#管理类" class="headerlink" title="管理类"></a>管理类</h1>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>questions</tag>
      </tags>
  </entry>
  <entry>
    <title>vmtoll</title>
    <url>/2022/08/26/java/arthas/</url>
    <content><![CDATA[<p>7490376  Approved<br>sc -d org.springframework.context.ApplicationContext<br>–线上执行代码</p>
<p>vmtool –action getInstances -c  6981e5e3 –className org.springframework.context.ApplicationContext –express ‘instances[1].getBean(“snReturnService”).approveReject(“5020059”)’</p>
<p>vmtool –action getInstances -c 2f9cd665 –className org.springframework.context.ApplicationContext –express ‘instances[1].getBean(“orderAdjustService”).approveFinishOrderAdjust(“4922565”,”reject_end”)’</p>
<p>vmtool –action getInstances -c 5950a341 –className org.springframework.context.ApplicationContext –express ‘instances[1].getBean(“activityService”).single(“snreturn_single_reject”,”4735433”)’</p>
<p>vmtool –action getInstances -c 5950a341 –className org.springframework.context.ApplicationContext –express ‘instances[1].getBean(“kfkCallBackEnterService”).dealMsg(“KM210317001134012”,”3”,”解冻完成”)’</p>
<p>vmtool –action getInstances -c 5950a341 –className org.springframework.context.ApplicationContext –express ‘instances[1].getBean(“agentContractService”).queryRedisAgContractFreeze()’</p>
<p>vmtool –action getInstances -c 2f9cd665 –className org.springframework.context.ApplicationContext –express ‘instances[1].getBean(“dataChangeActivityService”).compressColInfoDataChangeActivity(“4877809”,”Approved”)’</p>
<p>vmtool –action getInstances -c   2af28f0e –className org.springframework.context.ApplicationContext –express ‘#arr = new java.util.ArrayList&lt;java.lang.String&gt;(), #arr.add(“5020059”), instances[1].getBean(“activityService”).deleteInstance(#arr)’</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>arthas</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高可用</title>
    <url>/2021/09/22/java/redisha/</url>
    <content><![CDATA[<h2 id="Sentinel相关配置"><a href="#Sentinel相关配置" class="headerlink" title="Sentinel相关配置"></a>Sentinel相关配置</h2><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#绑定ip</span><br><span class="line">bind 12.3.10.222</span><br><span class="line">#sentinel 端口配置</span><br><span class="line">port 26377</span><br><span class="line">#默认情况下，Redis Sentinel不作为守护程序运行。 如果需要，可以设置为 yes。</span><br><span class="line">daemonize yes</span><br><span class="line"># 启用守护进程运行后，Redis将在/var/run/redis-sentinel.pid中写入一个pid文件</span><br><span class="line">pidfile /var/run/redis-sentinel.pid</span><br><span class="line"></span><br><span class="line"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line">#</span><br><span class="line"># 告诉Sentinel监听指定主节点，并且只有在至少&lt;quorum&gt;哨兵达成一致的情况下才会判断它 O_DOWN 状态。</span><br><span class="line">#</span><br><span class="line"># 副本是自动发现的，因此您无需指定副本。</span><br><span class="line"># Sentinel本身将重写此配置文件，使用其他配置选项添加副本。另请注意，当副本升级为主副本时，将重写配置文件。</span><br><span class="line">#</span><br><span class="line"># 注意：主节点（master）名称不能包含特殊字符或空格。</span><br><span class="line"># 有效字符可以是 A-z 0-9 和这三个字符 &quot;.-_&quot;.</span><br><span class="line">sentinel monitor mymaster 12.3.10.222 6377 2</span><br><span class="line"># 如果redis配置了密码，那这里必须配置认证，否则不能自动切换</span><br><span class="line">sentinel auth-pass mymaster cx</span><br><span class="line"># 主节点或副本在指定时间内没有回复PING，便认为该节点为主观下线 S_DOWN 状态。</span><br><span class="line"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line"># 在故障转移期间，多少个副本节点进行数据同步</span><br><span class="line"># sentinel parallel-syncs &lt;master-name&gt; &lt;numreplicas&gt;</span><br><span class="line">sentinel parallel-syncs mymaster 3</span><br><span class="line"># 指定故障转移超时（以毫秒为单位）。 默认3分钟</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line"># 指定日志文件名。 如果值为空，将强制Sentinel日志标准输出。守护进程下，如果使用标准输出进行日志记录，则日志将发送到/dev/null</span><br><span class="line">loglevel debug    </span><br><span class="line">logfile &quot;/usr/redis/log/sentinel-26377.log&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># sentinel announce-ip &lt;ip&gt;</span><br><span class="line"># sentinel announce-port &lt;port&gt;</span><br><span class="line"></span><br><span class="line"># dir &lt;working-directory&gt;</span><br><span class="line"># 每个长时间运行的进程都应该有一个明确定义的工作目录。对于Redis Sentinel来说，/tmp就是自己的工作目录。</span><br><span class="line">dir /tmp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动方式</p>
<ol>
<li><p>redis-sentinel /path/to/sentinel.conf</p>
</li>
<li><p>redis-server /path/to/sentinel.conf –sentinel</p>
</li>
</ol>
<h2 id="Sentinel及服务状态感知能力"><a href="#Sentinel及服务状态感知能力" class="headerlink" title="Sentinel及服务状态感知能力"></a>Sentinel及服务状态感知能力</h2><p>环境内信息共享，sentinel与主服务从服务之间建立命令链接及频道订阅发布链接，用以感知从服务器加入，新的sentinel加入</p>
<p>​    1. sentinel每10秒向主服务发送INFO命令收集信息，收集从服务信息，<strong>发现新的服务加入</strong>，并建立从服务数据结构，建立从服务命令及频道链接，</p>
<p>​    2. 建立好从服务链接后每10秒发送INFO命令收集从服务状态信息，并更新数据结构中从服务的状态信息</p>
<p>​    3. 向主服务器从服务器发布 __sentinel__:hello  频道  共享sentinel自身状态及主服务信息，所有sentinel发布信息到此频道</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUBLISH  __sentinel__:hello &quot;s_ip s_port s_runid s_epoch m_name m_ip m_port m_epoch&quot;</span><br><span class="line">s_ip s_port s_runid s_epoch  发送消息的sentinel信息</span><br><span class="line">m_name m_ip m_port m_epoch   发送消息的sentinel监测的master信息</span><br></pre></td></tr></table></figure>

<p>​    4. 订阅主服务器从服务器 __sentinel__:hello  频道  感知其他sentinel信息及主服务信息，所有sentinel订阅此频道，并接受消息</p>
<h2 id="状态检测：sentinel与所有服务包括主从服务sentinel服务保持命令链接"><a href="#状态检测：sentinel与所有服务包括主从服务sentinel服务保持命令链接" class="headerlink" title="状态检测：sentinel与所有服务包括主从服务sentinel服务保持命令链接"></a>状态检测：sentinel与所有服务包括主从服务sentinel服务保持命令链接</h2><p>​    sentinel除了和主服务从服务建立命令链接和频道链接外，还与其他sentinel建立命令链接，用于状态监测 PING命令执行</p>
<h3 id="主观下线状态监测-PING"><a href="#主观下线状态监测-PING" class="headerlink" title="主观下线状态监测 PING"></a>主观下线状态监测 PING</h3><ol>
<li><p>sentinel 和主从服务及其他sentinel建立连接后会以每秒一次的频率发送PING命令，并根据回复来判断实例是否下线，PING命令有固定的几个有效的回复，有效的回复有+PONG，-LOADING,-MASTERDOWN三种回复，除了三种回复的结果都是无效回复。</p>
</li>
<li><p>sentinel配置文件中 down-after-milliseconds 配置是sentinel判断主观下线所需的时间长度，在down-after-milliseconds毫秒内服务连续向sentinel返回无效回复，那么sentinel将实例结构中flags属性中打卡 SRI-S-DOWN标识，以此来表示实例进入主管下线状态。</p>
</li>
<li><p>down-after-milliseconds 配置不仅作用在判断主从服务下线检查，也作用在sentinel下线检查时长</p>
<p>sentinel monitor mymaster host  port  quorum(客观下线所支持的投票数量)</p>
<p>sentinel down-after-milliseconds mymaster  30000</p>
</li>
</ol>
<h3 id="客观下线状态监测-SENTINEL-is-master-down-by-addr-命令"><a href="#客观下线状态监测-SENTINEL-is-master-down-by-addr-命令" class="headerlink" title="客观下线状态监测 SENTINEL  is-master-down-by-addr 命令:"></a>客观下线状态监测 SENTINEL  is-master-down-by-addr 命令:</h3><p>当sentinel判断主服务器为主观下线的时候，会向别的监视主服务的sentinel进行询问，看他们是否也认为主服务器已进入了下线状态（可已是主观也可以是客观），<strong>当接收到足够数量的下线判断</strong>（quorum）后，sentinel会将服务器判定为客观下线并进行故障转移</p>
<p>询问是否已下线请求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">发送：SENTINEL is-master-down-by-addr ip port current_epoch  runid</span><br><span class="line">ip 被sentinel判断为主观下次的主服务ip</span><br><span class="line">port 被sentinel判断为主观下次的主服务端口</span><br><span class="line">current_epoch sentinel当前的配置纪元，用于sentinel领头选举</span><br><span class="line">runid *或者是sentinel运行id</span><br><span class="line"></span><br><span class="line">回复：down_state leader_runid leader_epoch</span><br><span class="line">down_state 1 服务已下线 0 服务未下线</span><br><span class="line">leader_runid  *或者是sentinel运行id，用于sentinel领头选举，询问阶段返回*</span><br><span class="line">leader_epoch  配置纪元，用于sentinel领头选举 询问阶段返回0</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="选举领头sentinel"><a href="#选举领头sentinel" class="headerlink" title="选举领头sentinel"></a>选举领头sentinel</h2><ul>
<li>当sentinel监测到主服务下线会进行leader选举，并由选举出的sentinel负责进行故障转移，选举的命令是通过SENTINEL is-master-down-by-addr 进行发送的，并根据返回结果进行收集，当超过半数的sentinel服务投票决定，那台sentinel将成为leader。</li>
<li>当客观quorum达到后sentinel会向别的sentinel（目标）发送SENTINEL is-master-down-by-addr ip port current_epoch  runid 命令，并携带current_epoch  ，runid </li>
<li>目标sentinel接收到is-master-down-by-addr  请求，如果当前sentinel未进行过投票，则返回发送自己的epoch  ，和请求投票的sentinel的runid表示投票，如果已经投过票，就拒绝请求</li>
<li>源sentinel接受到回复后，会比对leader_epoch 纪元是否和自己的相等，如果相等判断leader_runid是否是自己的runid如果是，表明投票给自己。</li>
<li>每个sentinel在每个纪元epoch内只能进行一次的投票，并且只能投票一次，根据请求到达的先后顺序，投票遵循先到先得，leader申请的sentinel根据的leader_runid，leader_epoch结果统计投票信息，并在过半后成为leader。</li>
<li>每个sentinel都有机会成为leader，每次lead选举无论成功或者失败epoch纪元都会增1</li>
<li>如果给定时限内没有一个sentinel被选举为leader，那么sentinel将在一段时间后再次进行选举，知道选举出leader为止。</li>
</ul>
<h2 id="实现故障转移"><a href="#实现故障转移" class="headerlink" title="实现故障转移"></a>实现故障转移</h2><p>在已下线的主服务器的从服务器里挑选一个从服务，并将其转换为主服务</p>
<ol>
<li>​     选择从服务规则（主服务中slaves列表）</li>
<li>​      删除已经下线的从服务</li>
<li>​      删除最近5秒内没有回复过leader的从服务</li>
<li>​      删除与主服务断开连接超过 down-after-milliseconds * 10 毫秒的从服务</li>
<li>​     根据从服务的优先级排序，选择优先级最高的从服务如果有多个，将按照复制偏移量最大的优先，如果优先级复制偏移量都一样，就按照runid进行排序 宣传runid最小的为主服务</li>
<li><pre><code> 向从服务发送 SLAVEOF no one 命令，调整从服务未主服务
</code></pre>
</li>
</ol>
<p>将已下线的主服务下的所有从服务，改为复制挑选出的主服务</p>
<ul>
<li>​    向未被选择的从服务发送 SLAVEOF new_master new_master_por 进行复制新的主服务命令，并调整配置文件</li>
</ul>
<p>将已下线的主服务器设置为新选择的主服务的从服务，当就的主服务重新上线是，他会成为新的主服务的从服务</p>
<ul>
<li>调整配置文件</li>
</ul>
<!--所有被调整过的服务，redis.conf 复制服务配置将被调整-->

<p>sentinel.c 关于sentinel的状态的数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Main state. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> myid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* This sentinel ID. */</span></span><br><span class="line">    <span class="type">uint64_t</span> current_epoch;         <span class="comment">/* Current epoch. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 报错所有被这个sentinel监视的服务 结构是sentinelRedisInstances */</span></span><br><span class="line">    dict *masters;      <span class="comment">/* Dictionary of master sentinelRedisInstances.</span></span><br><span class="line"><span class="comment">                           Key is the instance name, value is the</span></span><br><span class="line"><span class="comment">                           sentinelRedisInstance structure pointer. */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> tilt;           <span class="comment">/* Are we in TILT mode? */</span></span><br><span class="line">    <span class="type">int</span> running_scripts;    <span class="comment">/* Number of scripts in execution right now. */</span></span><br><span class="line">    <span class="type">mstime_t</span> tilt_start_time;       <span class="comment">/* When TITL started. */</span></span><br><span class="line">    <span class="type">mstime_t</span> previous_time;         <span class="comment">/* Last time we ran the time handler. */</span></span><br><span class="line">    <span class="built_in">list</span> *scripts_queue;            <span class="comment">/* Queue of user scripts to execute. */</span></span><br><span class="line">    <span class="type">char</span> *announce_ip;  <span class="comment">/* IP addr that is gossiped to other sentinels if</span></span><br><span class="line"><span class="comment">                           not NULL. */</span></span><br><span class="line">    <span class="type">int</span> announce_port;  <span class="comment">/* Port that is gossiped to other sentinels if</span></span><br><span class="line"><span class="comment">                           non zero. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> simfailure_flags; <span class="comment">/* Failures simulation. */</span></span><br><span class="line">&#125; sentinel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> flags;      <span class="comment">/* See SRI_... defines */</span></span><br><span class="line">    <span class="type">char</span> *name;     <span class="comment">/* Master name from the point of view of this sentinel. */</span></span><br><span class="line">    <span class="type">char</span> *runid;    <span class="comment">/* Run ID of this instance, or unique ID if is a Sentinel.*/</span></span><br><span class="line">    <span class="type">uint64_t</span> config_epoch;  <span class="comment">/* Configuration epoch. */</span></span><br><span class="line">    sentinelAddr *addr; <span class="comment">/* Master host. */</span></span><br><span class="line">    instanceLink *link; <span class="comment">/* Link to the instance, may be shared for Sentinels. */</span></span><br><span class="line">    <span class="type">mstime_t</span> last_pub_time;   <span class="comment">/* Last time we sent hello via Pub/Sub. */</span></span><br><span class="line">    <span class="type">mstime_t</span> last_hello_time; <span class="comment">/* Only used if SRI_SENTINEL is set. Last time</span></span><br><span class="line"><span class="comment">                                 we received a hello from this Sentinel</span></span><br><span class="line"><span class="comment">                                 via Pub/Sub. */</span></span><br><span class="line">    <span class="type">mstime_t</span> last_master_down_reply_time; <span class="comment">/* Time of last reply to</span></span><br><span class="line"><span class="comment">                                             SENTINEL is-master-down command. */</span></span><br><span class="line">    <span class="type">mstime_t</span> s_down_since_time; <span class="comment">/* Subjectively down since time. */</span></span><br><span class="line">    <span class="type">mstime_t</span> o_down_since_time; <span class="comment">/* Objectively down since time. */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 配置 sentinel down-after-milliseconds mymaster 30000 */</span></span><br><span class="line">    <span class="type">mstime_t</span> down_after_period; <span class="comment">/* Consider it down after that period. */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">mstime_t</span> info_refresh;  <span class="comment">/* Time at which we received INFO output from it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Role and the first time we observed it.</span></span><br><span class="line"><span class="comment">     * This is useful in order to delay replacing what the instance reports</span></span><br><span class="line"><span class="comment">     * with our own configuration. We need to always wait some time in order</span></span><br><span class="line"><span class="comment">     * to give a chance to the leader to report the new configuration before</span></span><br><span class="line"><span class="comment">     * we do silly things. */</span></span><br><span class="line">    <span class="type">int</span> role_reported;</span><br><span class="line">    <span class="type">mstime_t</span> role_reported_time;</span><br><span class="line">    <span class="type">mstime_t</span> slave_conf_change_time; <span class="comment">/* Last time slave master addr changed. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Master specific. */</span></span><br><span class="line">    dict *sentinels;    <span class="comment">/* Other sentinels monitoring the same master. */</span></span><br><span class="line">    dict *slaves;       <span class="comment">/* Slaves for this master instance. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> quorum;<span class="comment">/* Number of sentinels that need to agree on failure. */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 配置 sentinel parallel-syncs mymaster 3 */</span></span><br><span class="line">    <span class="type">int</span> parallel_syncs; <span class="comment">/* How many slaves to reconfigure at same time. */</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span> *auth_pass;    <span class="comment">/* Password to use for AUTH against master &amp; slaves. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Slave specific. */</span></span><br><span class="line">    <span class="type">mstime_t</span> master_link_down_time; <span class="comment">/* Slave replication link down time. */</span></span><br><span class="line">    <span class="type">int</span> slave_priority; <span class="comment">/* Slave priority according to its INFO output. */</span></span><br><span class="line">    <span class="type">mstime_t</span> slave_reconf_sent_time; <span class="comment">/* Time at which we sent SLAVE OF &lt;new&gt; */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> *<span class="title">master</span>;</span> <span class="comment">/* Master instance if it&#x27;s slave. */</span></span><br><span class="line">    <span class="type">char</span> *slave_master_host;    <span class="comment">/* Master host as reported by INFO */</span></span><br><span class="line">    <span class="type">int</span> slave_master_port;      <span class="comment">/* Master port as reported by INFO */</span></span><br><span class="line">    <span class="type">int</span> slave_master_link_status; <span class="comment">/* Master link status as reported by INFO */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> slave_repl_offset; <span class="comment">/* Slave replication offset. */</span></span><br><span class="line">    <span class="comment">/* Failover */</span></span><br><span class="line">    <span class="type">char</span> *leader;       <span class="comment">/* If this is a master instance, this is the runid of</span></span><br><span class="line"><span class="comment">                           the Sentinel that should perform the failover. If</span></span><br><span class="line"><span class="comment">                           this is a Sentinel, this is the runid of the Sentinel</span></span><br><span class="line"><span class="comment">                           that this Sentinel voted as leader. */</span></span><br><span class="line">    <span class="type">uint64_t</span> leader_epoch; <span class="comment">/* Epoch of the &#x27;leader&#x27; field. */</span></span><br><span class="line">    <span class="type">uint64_t</span> failover_epoch; <span class="comment">/* Epoch of the currently started failover. */</span></span><br><span class="line">    <span class="type">int</span> failover_state; <span class="comment">/* See SENTINEL_FAILOVER_STATE_* defines. */</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_state_change_time;</span><br><span class="line">    <span class="type">mstime_t</span> failover_start_time;   <span class="comment">/* Last failover attempt start time. */</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/*刷新故障迁移状态的最大时限 sentinel failover-timeout mymaster 180000 */</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_timeout;      <span class="comment">/* Max time to refresh failover state. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">mstime_t</span> failover_delay_logged; <span class="comment">/* For what failover_start_time value we</span></span><br><span class="line"><span class="comment">                                       logged the failover delay. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> *<span class="title">promoted_slave</span>;</span> <span class="comment">/* Promoted slave instance. */</span></span><br><span class="line">    <span class="comment">/* Scripts executed to notify admin or reconfigure clients: when they</span></span><br><span class="line"><span class="comment">     * are set to NULL no script is executed. */</span></span><br><span class="line">    <span class="type">char</span> *notification_script;</span><br><span class="line">    <span class="type">char</span> *client_reconfig_script;</span><br><span class="line">    sds info; <span class="comment">/* cached INFO output */</span></span><br><span class="line">&#125; sentinelRedisInstance;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************************************************** sentinel可执行的命令*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">sentinelcmds</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;ping&quot;</span>,pingCommand,<span class="number">1</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;sentinel&quot;</span>,sentinelCommand,<span class="number">-2</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;subscribe&quot;</span>,subscribeCommand,<span class="number">-2</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;unsubscribe&quot;</span>,unsubscribeCommand,<span class="number">-1</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;psubscribe&quot;</span>,psubscribeCommand,<span class="number">-2</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;punsubscribe&quot;</span>,punsubscribeCommand,<span class="number">-1</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;publish&quot;</span>,sentinelPublishCommand,<span class="number">3</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;info&quot;</span>,sentinelInfoCommand,<span class="number">-1</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;role&quot;</span>,sentinelRoleCommand,<span class="number">1</span>,<span class="string">&quot;l&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;client&quot;</span>,clientCommand,<span class="number">-2</span>,<span class="string">&quot;rs&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;shutdown&quot;</span>,shutdownCommand,<span class="number">-1</span>,<span class="string">&quot;&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h1><p>RedisServer中嵌入了Lua环境，Redis客户端可以使用lua脚本在服务器上执行多个redis命令。</p>
<p>server在启动后初始了lua环境，lua环境初始化中载入了多个lua函数库,并创建redis全局表格（其中就包含了redis.call(),redis.pcall），并且创建给lua环境脚本执行辅助的工具，命令执行伪客户端和脚本字典（脚本字典是实现SCRIPT EXISTS和脚本复制功能根本），</p>
<p>LUA脚本命令执行步骤： (EVAL)</p>
<p>​    定义脚本函数( f_SHA1CODE)载入lua环境</p>
<p>​    保存脚本到脚本字典lua_scripts（key:SHA1CODE,value:script）</p>
<p>​    执行脚本函数(redis命令会通过，伪客户端来向server发送指令来执行，然后结果返回给伪客户端，伪客户端返回结果到lua环境)</p>
<p>LUA环境脚本管理：</p>
<p>​    SCRIPT FLUSH:清空lua环境脚本函数，并销毁并重新构建一个lua环境</p>
<p>​    SCRIPT EXISTS：判断给定的SHA1值对应的脚本是否存在于lua环境</p>
<p>​    SCRIPT LOAD：加载一个lua脚本并，创建脚本函数并加载到lua环境，并将脚本加入到脚本字典</p>
<p>​    SCRIPT KILL：lua-time-limit 超时使用</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Thread</title>
    <url>/2022/05/19/java/thread/</url>
    <content><![CDATA[<h1 id="JAVA-Thread的状态："><a href="#JAVA-Thread的状态：" class="headerlink" title="JAVA Thread的状态："></a>JAVA Thread的状态：</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">State</span> &#123;</span><br><span class="line">       <span class="comment">//新建线程但是未进行start方法调用的线程</span></span><br><span class="line">        NEW,</span><br><span class="line">       <span class="comment">//一个正在JVM中运行的线程状态，以下两种情况都是运行状态</span></span><br><span class="line">       <span class="comment">//1：获得cpu时间分配执行状态，2:失去cpu时间分片后的就绪状态，等待系统资源的状态，如cpu处理器</span></span><br><span class="line">        RUNNABLE，</span><br><span class="line">       <span class="comment">//线程阻塞等待一个监视锁，获取锁后可再次执行</span></span><br><span class="line">       <span class="comment">// 1.如进入了synchronized 阻塞方法 </span></span><br><span class="line">       <span class="comment">// 2.在调用Object.wait后重入synchronized  </span></span><br><span class="line">            <span class="comment">//调用 wait 方法必须在同步块中，即是要先获取锁并进入同步块，这是第一次 enter</span></span><br><span class="line">            <span class="comment">//而调用 wait 之后则会释放该锁，并进入此锁的等待队列（wait set）中</span></span><br><span class="line">            <span class="comment">//当收到其它线程的 notify 或 notifyAll 通知之后，等待线程并不能立即恢复执行，因为停止的地方是在同步块内，而锁已               经释放了，所以它要重新获取锁才能再次进入（reenter）同步块，然后从上次 wait 的地方恢复执行。这是第二次 enter，               所以叫 reenter</span></span><br><span class="line">        BLOCKED,</span><br><span class="line">        <span class="comment">//线程处于等待其他线程的一个状态</span></span><br><span class="line">        	<span class="comment">//不带有等待时间的Object.wait，等待别的线程唤醒，Object.notify()，Object.notifyAll(),</span></span><br><span class="line">        	<span class="comment">//不带有时间的Thread.join，等待合并线程的执行完成</span></span><br><span class="line">    		<span class="comment">//或者LockSupport.park</span></span><br><span class="line">        WAITING，</span><br><span class="line">        <span class="comment">//线程处于有限期等待状态</span></span><br><span class="line">        <span class="comment">//带有等待时间的</span></span><br><span class="line">              <span class="comment">// Thread.sleep(long),</span></span><br><span class="line">    		 <span class="comment">// Object.wait(long),</span></span><br><span class="line">              <span class="comment">// Thread.join(long),</span></span><br><span class="line">    		 <span class="comment">// LockSupport.parkNanos,</span></span><br><span class="line">   			 <span class="comment">// LockSupport.parkUntil</span></span><br><span class="line">        TIMED_WAITING,</span><br><span class="line">        <span class="comment">//线程处于完成终止状态</span></span><br><span class="line">        TERMINATED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="JavaThread的操作"><a href="#JavaThread的操作" class="headerlink" title="JavaThread的操作"></a>JavaThread的操作</h1><ul>
<li><p>静态方法</p>
<p>public static void sleep(long millis, int nanos) throws InterruptedException</p>
<p>如果是临界区代码段，那么线程<strong>不会释放监视器锁资源</strong></p>
</li>
<li><p>成员方法<br>public final void join() throws InterruptedException<br>public final synchronized void join(long millis, int nanos)throws InterruptedException<br>public final synchronized void join(long millis) throws InterruptedException </p>
<p>如果是临界区代码段，那么线程<strong>不会释放监视器锁资源</strong></p>
<p>public void interrupt()<br>public boolean isInterrupted() </p>
<p>对于正在执行的线程，终端操作只是将线程的终端标识设置为true，表示已中断，并不会做其他的操作，线程可在内部根据isInterrupted 来判断线程释放继续执行</p>
<p>对于阻塞的线程，终端操作会直接使线程抛出InterruptedException 异常，线程根据情况判断是否继续进行线程操作</p>
</li>
<li><p>LockSupport：<br>LockSupport.park<br>LockSupport.unpark<br>LockSupport.parkNanos,<br>LockSupport.parkUntil</p>
</li>
<li><p>Object：<br>Object.wait(long)<br>Object.wait</p>
<p>如果是临界区代码段，那么<strong>线程释放监视器锁资源</strong></p>
</li>
<li><p>Object.notify()，<br>Object.notifyAll(),</p>
<p>通知其他等待线程，锁已释放，重新竞争锁资源</p>
</li>
</ul>
<h1 id="线程创建的和使用的几种方式："><a href="#线程创建的和使用的几种方式：" class="headerlink" title="线程创建的和使用的几种方式："></a>线程创建的和使用的几种方式：</h1><h3 id="继承方式："><a href="#继承方式：" class="headerlink" title="继承方式："></a>继承方式：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       log.info(<span class="string">&quot;线程运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createThread</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">OThread</span> <span class="variable">ot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OThread</span>();</span><br><span class="line">	ot.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行对象方式"><a href="#执行对象方式" class="headerlink" title="执行对象方式"></a>执行对象方式</h3><p>Runnable对象可作为线程的执行对象来传递到线程内部并执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">targ</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Runnable线程运行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">runTarget1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(targ);</span><br><span class="line"><span class="type">Thread</span> <span class="variable">runTarget2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(targ);</span><br><span class="line">runTarget1.start();</span><br><span class="line">runTarget2.start();</span><br></pre></td></tr></table></figure>

<h3 id="FutureTask方式"><a href="#FutureTask方式" class="headerlink" title="FutureTask方式:"></a>FutureTask方式:</h3><p>Future接口支持我们获取异步执行的结果，并可以在执行的过程中进行cancel操作，但是无法作为线程的执行对象</p>
<p>Runnable可以作为线程的执行对象，但是无法获取到执行的结果，</p>
<p>那RunnableFuture就结合了Runnable和Future接口的对两者的功能进行了融合，既可以作为Thread的执行对象也可以获取到异步执行结果，FutureTask就是RunnableFuture的实现，来作为线程执行对象，并支持获取执行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">FutureTask</span> <span class="variable">fttask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;String&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;FutureTask result&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="type">Thread</span> <span class="variable">ft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(fttask);</span><br><span class="line"> ft.start();</span><br><span class="line">log.info(<span class="string">&quot;FutureTask:&#123;&#125;&quot;</span>,fttask.get());</span><br></pre></td></tr></table></figure>

<h3 id="线程池方式："><a href="#线程池方式：" class="headerlink" title="线程池方式："></a>线程池方式：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单线程，无解队列线程池LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">//队列无线，当任务无线大时会导致内存溢出，RejectedExecutionHandler</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorServiceSingleThreadExecutor</span> <span class="operator">=</span>  Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//无限线程容量,SynchronousQueue队列，RejectedExecutionHandler</span></span><br><span class="line"><span class="comment">//对线程没有限制，有keepAliveTime60秒</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorServiceCachedThreadPool</span> <span class="operator">=</span>  Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//固定数量线程，无界队列线程池LinkedBlockingQueue</span></span><br><span class="line"><span class="comment">//队列无线，当任务无线大时会导致内存溢出，RejectedExecutionHandler</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorServiceFixedThreadPool</span> <span class="operator">=</span>  Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//计划任务线程池 DelayedWorkQueue优先级队列</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorServiceScheduledThreadPool</span> <span class="operator">=</span>  Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//抢占式线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executorWorkStealingPool</span> <span class="operator">=</span>  Executors.newWorkStealingPool();</span><br><span class="line"></span><br><span class="line">Future&lt;String&gt; poolF = executorServiceSingleThreadExecutor.submit(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;executorServiceSingleThreadExecutor&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">log.info(<span class="string">&quot;executorServiceSingleThreadExecutor:&#123;&#125;&quot;</span>, poolF.get());</span><br></pre></td></tr></table></figure>



<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>synchronized 内置锁</p>
<ol>
<li>无锁</li>
<li>偏向锁,threadid</li>
<li>轻量级自旋锁,cas,</li>
<li>重量级锁 cxq,entrylist,waiteset,monitor</li>
</ol>
<p>原子性操作：</p>
<ol>
<li>unsafe cas volatile</li>
<li>cas 优化 LongAddr 分段锁</li>
</ol>
<p>可见性与有序性：volatile</p>
<p>as-is-Serial 保障单内核指令重排序后执行结果的正确性原则，不能保证多内核以及夸cpu指令重排序之后的执行结果正确性</p>
<p>内存屏障     保障多核指令重排序之后程序结果正确性方法</p>
<h1 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h1><p> 内存模型</p>
<p>  对象的创建</p>
<p>  堆内存分配 指针碰撞(Serial,ParNew)，空闲列表(CMS)</p>
<p>  内存分配线程并发  同步锁，TLAB</p>
<p>  对象引用：直接指针，引用句柄</p>
<p>内存溢出：堆溢出 元数据区溢出，栈溢出 直接内存溢出</p>
<h1 id="垃圾收集器及内存分配策略"><a href="#垃圾收集器及内存分配策略" class="headerlink" title="垃圾收集器及内存分配策略"></a>垃圾收集器及内存分配策略</h1><p>哪些内存需要回收</p>
<ol>
<li>   哪些区域需要回收？（堆，元数据区），（方法栈 本地方法栈 程序计数器）</li>
<li>   哪些对象需要回收？</li>
</ol>
<ul>
<li>​        对象已死么？引用计数法，可达性分析法</li>
<li>​        可达性分析法</li>
</ul>
<p>​    对象已死么-GCRoot条件：</p>
<ul>
<li><p>​        虚拟机栈中引用的变量（栈帧中的本地变量）</p>
</li>
<li><p>​        元数据区中静态属性引用的对象</p>
</li>
<li><p>​        元数据区中常量引用的对象</p>
</li>
<li><p>​        本地方法栈JNI（native方法）引用的对象</p>
<p> 对象已死么-可达性分析法-引用：</p>
</li>
<li><p>​        强引用</p>
</li>
<li><p>​        软引用</p>
</li>
<li><p>​        弱引用</p>
</li>
<li><p>​        虚引用</p>
</li>
</ul>
<p>​    对象已死么-是否对象已死</p>
<ul>
<li>​        两次标记</li>
<li>​        逃脱死亡的最后机会finalize</li>
</ul>
<p>​    回收元数据区：-Xnoclassgc</p>
<p>垃圾回收算法：</p>
<p>​            标记清除算法</p>
<p>​            复制算法</p>
<p>​            标记整理算法</p>
<p>什么时候回收</p>
<p>​    枚举根节点：</p>
<p>​               类加载完成的时候对象内通过Oopmap数据结构记录引用信息,gc过程中直接遍历oopmap结构，解决因堆和元数据区内存比较大，导致root节点遍历时间过长。</p>
<p>​     安全点：因为root节点的对象包含线程运行栈</p>
<p>​     安全区域：修改oopmap结构的区域</p>
<p>​    </p>
<h1 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h1><p>模板方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> private transient volatile Node head;</span><br><span class="line"> private transient volatile Node tail;</span><br><span class="line"> private volatile int state;</span><br><span class="line"></span><br><span class="line">public final void acquire(int arg)</span><br><span class="line">public final boolean tryAcquireNanos(int arg, long nanosTimeout)throws InterruptedException</span><br><span class="line">public final void acquireInterruptibly(int arg)throws InterruptedException</span><br><span class="line">public final boolean release(int arg) </span><br><span class="line"></span><br><span class="line">public final void acquireShared(int arg)</span><br><span class="line">public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)throws InterruptedException</span><br><span class="line">public final void acquireSharedInterruptibly(int arg)throws InterruptedException </span><br><span class="line">public final boolean releaseShared(int arg) </span><br><span class="line"></span><br><span class="line">protected boolean tryAcquire(int arg)</span><br><span class="line">protected boolean tryRelease(int arg)</span><br><span class="line">protected int tryAcquireShared(int arg)</span><br><span class="line">protected boolean tryReleaseShared(int arg)</span><br><span class="line"></span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux limit</title>
    <url>/2022/07/14/linux/limit/</url>
    <content><![CDATA[<h1 id="Linux-limit-系统资源限制相关配置信息及其含义介绍"><a href="#Linux-limit-系统资源限制相关配置信息及其含义介绍" class="headerlink" title="Linux limit 系统资源限制相关配置信息及其含义介绍"></a>Linux limit 系统资源限制相关配置信息及其含义介绍</h1><h2 id="资源限制范围"><a href="#资源限制范围" class="headerlink" title="资源限制范围"></a>资源限制范围</h2><p>资源限制分为系统级别和用户界别</p>
<ol>
<li><p>/etc/sysctl.conf 文件用于设置系统范围的资源限制</p>
</li>
<li><p>/etc/security/limits.conf 为 Oracle、MariaDB 和 Apache 等特定用户设置资源限制</p>
</li>
</ol>
<h2 id="sysctl-介绍"><a href="#sysctl-介绍" class="headerlink" title="sysctl 介绍"></a>sysctl 介绍</h2><p>sysctl 用来设置系统的核心参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a 显示当前所有设置</span><br><span class="line">-A 以表格的形式显示</span><br><span class="line">-e 模糊模式</span><br><span class="line">-n 忽略关键词</span><br><span class="line">-w 设置变量值</span><br><span class="line">-p&lt;文件&gt; 指定配置文件</span><br><span class="line">-h 显示帮助信息</span><br><span class="line">-V 版本信息  </span><br></pre></td></tr></table></figure>

<p><em>sysctl -a   #显示系统核心设置</em></p>
<p><em>sysctl -w net.ipv4.tcp_max_syn_backlog=256 #设置环境变量</em></p>
<p><em>sysctl -p   #立马生效</em></p>
<h2 id="1-系统级别限制配置"><a href="#1-系统级别限制配置" class="headerlink" title="1. 系统级别限制配置"></a>1. 系统级别限制配置</h2><ul>
<li> 下次重启之前有效 修改系统级限制配置</li>
</ul>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">sysctl -w fs.file-max=100000</span><br></pre></td></tr></table></figure>

<ul>
<li>无需注销和重新启动配置 修改系统级别限制配置</li>
</ul>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">vi /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">fs.file-max = 100000                       #最大打开文件数</span><br><span class="line">fs.file-nr = 2080       0       1621092    #文件描述符数量</span><br><span class="line"></span><br><span class="line">sysctl -p #使上述更改立即生效</span><br><span class="line"></span><br><span class="line">cat /proc/sys/fs/file-max #验证新的更改是否生效</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">或者</span></span><br><span class="line">sysctl -a|grep file</span><br></pre></td></tr></table></figure>
<ul>
<li>查看系统相关配置<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">cat  /proc/sys/fs/file-nr #系统打开文件数描述符限制</span><br><span class="line"></span><br><span class="line">cat /proc/sys/fs/file-max #系统打开文件数限制</span><br><span class="line"></span><br><span class="line">sysctl -a|grep file</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-用户及系统限制"><a href="#2-用户及系统限制" class="headerlink" title="2. 用户及系统限制"></a>2. 用户及系统限制</h2><ul>
<li>ulimit指令 控制shell程序的资源</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> -a 　显示目前资源限制的设定。 </span><br><span class="line">  -c  　设定core文件的最大值，单位为区块。 </span><br><span class="line">  -d &lt;数据节区大小&gt; 　程序数据节区的最大值，单位为KB。 </span><br><span class="line">  -f &lt;文件大小&gt; 　shell所能建立的最大文件，单位为区块。 </span><br><span class="line">  -H 　设定资源的硬性限制，也就是管理员所设下的限制。 </span><br><span class="line">  -m &lt;内存大小&gt; 　指定可使用内存的上限，单位为KB。 </span><br><span class="line">  -n &lt;文件数目&gt; 　指定同一时间最多可开启的文件数。 </span><br><span class="line">  -p &lt;缓冲区大小&gt; 　指定管道缓冲区的大小，单位512字节。 </span><br><span class="line">  -s &lt;堆叠大小&gt; 　指定线程栈大小的上限，单位为KB。 </span><br><span class="line"></span><br><span class="line">  -S 　设定资源的弹性限制。 </span><br><span class="line"></span><br><span class="line">  -t  　指定CPU使用时间的上限，单位为秒。 </span><br><span class="line">  -u &lt;程序数目&gt; 　用户最多可开启的程序数目。 </span><br><span class="line">  -v &lt;虚拟内存大小&gt; 　指定可使用的虚拟内存上限，单位为KB。</span><br><span class="line"></span><br><span class="line">ulimit -n –&gt; 显示打开文件数限制</span><br><span class="line">ulimit -c –&gt; 显示核心转储文件大小</span><br><span class="line">umilit -u –&gt; 显示登录用户的最大用户进程数限制</span><br><span class="line">ulimit -f –&gt; 显示用户可以拥有的最大文件大小</span><br><span class="line">umilit -m –&gt; 显示登录用户的最大内存大小</span><br><span class="line">ulimit -v –&gt; 显示最大内存大小限制</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -a                    #显示系统资源的设置</span><br><span class="line"></span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 3846</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 3846</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ulimit -u 65525				 #设置单一用户程序数目上限</span><br><span class="line"></span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 3846</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 65525		   #已改变</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>检查登录用户打开文件数量的硬限制和软限制</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shashi@Ubuntu ~&#125;$ ulimit -Hn</span><br><span class="line">1048576</span><br><span class="line">shashi@Ubuntu ~&#125;$ ulimit -Sn</span><br><span class="line">1024</span><br></pre></td></tr></table></figure>

<ul>
<li>设置用户级资源限制</li>
</ul>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hard <span class="built_in">limit</span> <span class="keyword">for</span> max opened files <span class="keyword">for</span> linuxtechi user</span></span><br><span class="line">linuxtechi       hard    nofile          4096</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">soft <span class="built_in">limit</span> <span class="keyword">for</span> max opened files <span class="keyword">for</span> linuxtechi user</span></span><br><span class="line">linuxtechi       soft    nofile          1024</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hard <span class="built_in">limit</span> <span class="keyword">for</span> max number of process <span class="keyword">for</span> oracle user</span></span><br><span class="line">oracle           hard    nproc          8096</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">soft <span class="built_in">limit</span> <span class="keyword">for</span> max number of process <span class="keyword">for</span> oracle user</span></span><br><span class="line">oracle           soft    nproc          4096</span><br></pre></td></tr></table></figure>

<ul>
<li>设置用户组级资源限制</li>
</ul>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hard <span class="built_in">limit</span> <span class="keyword">for</span> max opened files <span class="keyword">for</span> sysadmin group</span></span><br><span class="line">@sysadmin        hard         nofile            4096 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">soft <span class="built_in">limit</span> <span class="keyword">for</span> max opened files <span class="keyword">for</span> sysadmin group</span></span><br><span class="line">@sysadmin        soft         nofile            1024</span><br></pre></td></tr></table></figure>


<ul>
<li>切换用户并验证配置</li>
</ul>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">su - linuxtechi</span><br><span class="line"></span><br><span class="line">ulimit -n -H #打开文件最大限制数硬限制</span><br><span class="line">4096</span><br><span class="line"></span><br><span class="line">ulimit -n -S #打开文件最大限制数软限制</span><br><span class="line">1024</span><br><span class="line"></span><br><span class="line">su - oracle</span><br><span class="line"></span><br><span class="line">ulimit -H -u #最大线程数</span><br><span class="line">8096</span><br><span class="line"></span><br><span class="line">ulimit -S -u #最大线程数</span><br><span class="line">4096</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>使配置生效到配置用户</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/security/limits.conf</span><br><span class="line">#</span><br><span class="line">#Each line describes a limit for a user in the form:</span><br><span class="line">#</span><br><span class="line">#&lt;domain&gt;        &lt;type&gt;  &lt;item&gt;  &lt;value&gt;</span><br><span class="line">#</span><br><span class="line">#Where:</span><br><span class="line">#&lt;domain&gt; can be:</span><br><span class="line">#        - an user name</span><br><span class="line">#        - a group name, with @group syntax</span><br><span class="line">#        - the wildcard *, for default entry</span><br><span class="line">#        - the wildcard %, can be also used with %group syntax,</span><br><span class="line">#                 for maxlogin limit</span><br><span class="line">#</span><br><span class="line">#&lt;type&gt; can have the two values:</span><br><span class="line">#        - &quot;soft&quot; for enforcing the soft limits  软限制(soft limit) 设定资源的软限制。警告的设定，可以超过这个设定值，但是若超过则有警告信息</span><br><span class="line">#        - &quot;hard&quot; for enforcing hard limits      硬限制(hard limit) 设定资源的硬性限制，也就是管理员所设下的限制。严格的设定，必定不能超过这个设定的数值</span><br><span class="line">#</span><br><span class="line">#&lt;item&gt; can be one of the following:</span><br><span class="line">#        - core - limits the core file size (KB) core文件其实就是内存的映像，当程序崩溃时，存储内存的相应信息，主用用于对程序进行调试。当程序崩溃时便会产生core文件，其实准确的应该说是core dump 文件,默认生成位置与可执行程序位于同一目录下，文件名为core.***,其中***是某一数字。</span><br><span class="line">#        - data - max data size (KB)</span><br><span class="line">#        - fsize - maximum filesize (KB)  所能建立的最大文件，单位为区块。</span><br><span class="line">#        - memlock - max locked-in-memory address space (KB)</span><br><span class="line">#        - nofile - max number of open files  指定同一时间最多可开启的文件数。</span><br><span class="line">#        - rss - max resident set size (KB)</span><br><span class="line">#        - stack - max stack size (KB)</span><br><span class="line">#        - cpu - max CPU time (MIN)</span><br><span class="line">#        - nproc - max number of processes  程序孵出的最大子进程数量 </span><br><span class="line">#        - as - address space limit (KB)  地址空间限制  进程可用的内存的最大数量，包括堆栈、全局变量、动态内存</span><br><span class="line">#        - maxlogins - max number of logins for this user 此用户允许登录的最大数目</span><br><span class="line">#        - maxsyslogins - max number of logins on the system 系统最大同时在线用户数</span><br><span class="line">#        - priority - the priority to run user process with 运行用户进程的优先级</span><br><span class="line">#        - locks - max number of file locks the user can hold 用户可以持有的文件锁的最大数量</span><br><span class="line">#        - sigpending - max number of pending signals</span><br><span class="line">#        - msgqueue - max memory used by POSIX message queues (bytes)</span><br><span class="line">#        - nice - max nice priority allowed to raise to values: [-20, 19]</span><br><span class="line">#        - rtprio - max realtime priority</span><br><span class="line">#</span><br><span class="line">#&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>shell if 条件判断</title>
    <url>/2022/07/20/linux/shellif/</url>
    <content><![CDATA[<p>Shell  语言中的if条件</p>
<h1 id="一、if的基本语法"><a href="#一、if的基本语法" class="headerlink" title="一、if的基本语法:"></a>一、if的基本语法:</h1><p>if [ command ];then</p>
<p>   符合该条件执行的语句</p>
<p>elif [ command ];then</p>
<p>   符合该条件执行的语句</p>
<p>else</p>
<p>   符合该条件执行的语句</p>
<p>fi</p>
<h1 id="二、文件-文件夹-目录-判断"><a href="#二、文件-文件夹-目录-判断" class="headerlink" title="二、文件/文件夹(目录)判断"></a>二、文件/文件夹(目录)判断</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。</span><br><span class="line">[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。</span><br><span class="line">[ -d DIR ] 如果 FILE 存在且是一个目录则为真。</span><br><span class="line">[ -e FILE ] 如果 FILE 存在则为真。</span><br><span class="line">[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。</span><br><span class="line">[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。</span><br><span class="line">[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。</span><br><span class="line">[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。</span><br><span class="line">[ -r FILE ] 如果 FILE 存在且是可读的则为真。</span><br><span class="line">[ -s FILE ] 如果 FILE 存在且大小不为0则为真。</span><br><span class="line">[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。</span><br><span class="line">[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。</span><br><span class="line">[ -w FILE ] 如果 FILE存在且是可写的则为真。</span><br><span class="line">[ -x FILE ] 如果 FILE 存在且是可执行的则为真。</span><br><span class="line">[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。</span><br><span class="line">[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。</span><br><span class="line">[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。</span><br><span class="line">[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。</span><br><span class="line">[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。</span><br><span class="line">[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。</span><br><span class="line">[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。</span><br><span class="line">[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="三、字符串判断"><a href="#三、字符串判断" class="headerlink" title="三、字符串判断"></a>三、字符串判断</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[ -z STRING ] 如果STRING的长度为零则为真 ，即判断是否为空，空即是真；</span><br><span class="line">[ -n STRING ] 如果STRING的长度非零则为真 ，即判断是否为非空，非空即是真；</span><br><span class="line">[ STRING1 = STRING2 ] 如果两个字符串相同则为真 ；</span><br><span class="line">[ STRING1 != STRING2 ] 如果字符串不相同则为真 ；</span><br><span class="line">[ STRING1 ]　 如果字符串不为空则为真,与-n类似</span><br></pre></td></tr></table></figure>
<h1 id="四、数值判断"><a href="#四、数值判断" class="headerlink" title="四、数值判断"></a>四、数值判断</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INT1 -eq INT2           INT1和INT2两数相等为真 ,=</span><br><span class="line">INT1 -ne INT2           INT1和INT2两数不等为真 ,&lt;&gt;</span><br><span class="line">INT1 -gt INT2            INT1大于INT1为真 ,&gt;</span><br><span class="line">INT1 -ge INT2           INT1大于等于INT2为真,&gt;=</span><br><span class="line">INT1 -lt INT2             INT1小于INT2为真 ,&lt;&lt;/div&gt;</span><br><span class="line">INT1 -le INT2             INT1小于等于INT2为真,&lt;=</span><br></pre></td></tr></table></figure>
<p>#五、复杂逻辑判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># -a 与 &amp;&amp;</span><br><span class="line"># -o 或 ||</span><br><span class="line"># !  非</span><br></pre></td></tr></table></figure>
<p>#六、举例</p>
<h2 id="6-1-if利用read传参判断"><a href="#6-1-if利用read传参判断" class="headerlink" title="6.1 if利用read传参判断"></a>6.1 if利用read传参判断</h2><p>exp2:查看分数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#echo -n &quot;please input your score:&quot;</span><br><span class="line">#read score</span><br><span class="line">#echo &quot;input score is $ score &quot;</span><br><span class="line">read -p &quot;please input a score:&quot; score</span><br><span class="line">echo -e &quot;your score [$score] is judging by sys now&quot;</span><br><span class="line">if [ &quot;$score&quot; -ge &quot;0&quot; ]&amp;&amp;[ &quot;$score&quot; -lt &quot;60&quot; ];then</span><br><span class="line">        echo &quot;sorry,you are lost!&quot;</span><br><span class="line">elif [ &quot;$score&quot; -ge &quot;60&quot; ]&amp;&amp;[ &quot;$score&quot; -lt &quot;85&quot; ];then</span><br><span class="line">        echo &quot;just soso!&quot;</span><br><span class="line">elif [ &quot;$score&quot; -le &quot;100&quot; ]&amp;&amp;[ &quot;$score&quot; -ge &quot;85&quot; ];then</span><br><span class="line">        echo &quot;good job!&quot;</span><br><span class="line">else</span><br><span class="line">        echo &quot;input score is wrong , the range is [0-100]!&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<h2 id="shell-if-和-区别-amp-amp"><a href="#shell-if-和-区别-amp-amp" class="headerlink" title="shell if [[ ]]和[ ]区别 || &amp;&amp;"></a>shell if [[ ]]和[ ]区别 || &amp;&amp;</h2><h3 id="和test"><a href="#和test" class="headerlink" title="[]和test"></a>[]和test</h3><p>两者是一样的，在命令行里test expr和[ expr ]的效果相同。</p>
<p>test的三个基本作用是判断文件、判断字符串、判断整数。支持使用 ”与或非“ 将表达式连接起来。</p>
<p>test中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq, -gt这种形式。</p>
<p>无论是字符串比较还是整数比较都千万不要使用大于号小于号。当然，如果你实在想用也是可以的，对于字符串比较可以使用尖括号的转义形式， 如果比较”ab”和”bc”：[ ab &lt; bc ]，结果为真，也就是返回状态为0.</p>
<h3 id=""><a href="#" class="headerlink" title="[[ ]]"></a>[[ ]]</h3><p>这是内置在shell中的一个命令，它就比刚才说的test强大的多了。支持字符串的模式匹配（使用=~操作符时甚至支持shell的正则表达 式）。逻辑组合可以不使用test的-a,-o而使用&amp;&amp; ||。<br>字符串比较时可以把右边的作为一个模式（这是右边的字符串不加双引号的情况下。如果右边的字符串加了双引号，则认为是一个文本字符串。），而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。</p>
<p>注意：使用[]和[[]]的时候不要吝啬空格，每一项两边都要有空格，[[ 1 == 2 ]]的结果为“假”，但[[ 1==2 ]]的结果为“真”！<br>let和(())</p>
<p>两者也是一样的(或者说基本上是一样的，双括号比let稍弱一些)。主要进行算术运算(上面的两个都不行)，也比较适合进 行整数比较，可以直接使用熟悉的&lt;,&gt;等比较运算符。可以直接使用变量名如var而不需要$var这样的形式。支持分号隔开的多个表达式</p>
<hr>
<ol>
<li>首先，尽管很相似，但是从概念上讲，二者是不同层次的东西。</li>
</ol>
<p>“[[“，是关键字，许多shell(如ash bsh)并不支持这种方式。ksh, bash(据说从2.02起引入对[[的支持)等支持。</p>
<p>“[“是一条命令， 与test等价，大多数shell都支持。在现代的大多数sh实现中，”[“与”test”是内部(builtin)命令，换句话说执行”test”/“[“时不会调用/some/path/to/test这样的外部命令(如果有这样的命令的话)。</p>
<p>2.[[]]结构比Bash版本的[]更通用。在[[和]]之间的所有的字符都不会被文件扩展或是标记分割，但是会有参数引用和命令替换。</p>
<p>用[[ … ]]测试结构比用[ … ]更能防止脚本里的许多逻辑错误。比如说，&amp;&amp;,||,&lt;和&gt;操作符能在一个[[]]测试里通过，但在[]结构会发生错误。</p>
<p>3.(( ))结构扩展并计算一个算术表达式的值。如果表达式值为0，会返回1或假作为退出状态码。一个非零值的表达式返回一个0或真作为退出状态码。这个结构和先前test命令及[]结构的讨论刚好相反。</p>
<p>4.[ … ]为shell命令，所以在其中的表达式应是它的命令行参数，所以串比较操作符”&gt;” 与”&lt;”必须转义，否则就变成IO改向操作符了(请参看上面2中的例子)。在[[中”&lt;”与”&gt;”不需转义；<br>由于”[[“是关键字，不会做命令行扩展，因而相对的语法就稍严格些。例如</p>
<p>在[ … ]中可以用引号括起操作符，因为在做命令行扩展时会去掉这些引号，而在[[ … ]]则不允许这样做。</p>
<p>5.[[ … ]]进行算术扩展，而[ … ]不做</p>
<p>6.[[ … &amp;&amp; … &amp;&amp; …  ]] 和 [ … -a … -a …] 不一样，[[ ]] 是逻辑短路操作，而 [ ] 不会进行逻辑短路</p>
<p>1）在ksh中的test</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数字的运算可使用let、(( )) ，其中运算时不需要变量$符号，运算符为 +、-、*、/、% ，不建议使用expr</span><br><span class="line">数字的比较使用 (( )) ，其运算符 &gt;、&gt;=、&lt;、&lt;=、==、!=</span><br><span class="line">可以使用算术扩展，如：(( 99+1 &lt;= 101 ))</span><br><span class="line">字符表达式的比较使用 [[ ]] ，其运算符 =、!=、-n、-z</span><br><span class="line">文件表达式的测试使用 [[ ]] ，其运算符 -r、-l、-w、-x、-f、-d、-s、-nt、-ot</span><br><span class="line">逻辑表达式的测试使用 [[ ]] ，其运算符 !、&amp;&amp;、||</span><br><span class="line">数字比较、字符比较、逻辑测试可以组合，如$ [[ &quot;a&quot; != &quot;b&quot; &amp;&amp; 4 -gt 3 ]]</span><br><span class="line">支持bash中的通配符扩展，如：[[ hest = h??t ]] 、[ hest = h*t ]]</span><br><span class="line">使用 (( )) 时，不需要空格分隔各值和运算符，使用 [[ ]] 时需要用空格分隔各值和运算符。</span><br><span class="line">2）bash与ksh中的 [[ ]] 不同</span><br><span class="line"></span><br><span class="line">在redhat9的bash中也可以使用 [[ ]] 符号。但是建议严格按照上面的原则使用。</span><br><span class="line">在bash中，数字的比较最好使用 (( ))，虽说可以使用 [[ ]]，但若在其内使用运算符 &gt;、&gt;=、&lt;、&lt;=、==、!= 时，其结果经常是错误的，不过若在 [[ ]] 中使用 [ ] 中的运算符“-eq、-ne、-le、-lt、-gt、-ge”等，还尚未发现有错。因此诸如$ [[ &quot; a&quot; != “b” &amp;&amp; 4 &gt; 3 ]] 这类组合（见上）也不可以在bash中使用，其出错率很高。</span><br><span class="line">例：[[ &quot;a&quot; != &quot;b&quot; &amp;&amp; 10 &gt; 2 ]] 判断结果就不正常。</span><br><span class="line">诸如 [ 2 \&lt; 10 ]、[[ 2 &lt; 10 ]] 都是不要使用。使用算术扩展最好用 (( 99+1 == 100 )) ，而不要使用[[ 99+1 -eq 100 ]] 。</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="运算符-描述-示例"><a href="#运算符-描述-示例" class="headerlink" title="运算符 描述 示例"></a>运算符 描述 示例</h2><p>文件比较运算符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-e filename	如果 filename 存在，则为真	[ -e /var/log/syslog ]</span><br><span class="line">-d filename	如果 filename 为目录，则为真	[ -d /tmp/mydir ]</span><br><span class="line">-f filename	如果 filename 为常规文件，则为真	[ -f /usr/bin/grep ]</span><br><span class="line">-L filename	如果 filename 为符号链接，则为真	[ -L /usr/bin/grep ]</span><br><span class="line">-r filename	如果 filename 可读，则为真	[ -r /var/log/syslog ]</span><br><span class="line">-w filename	如果 filename 可写，则为真	[ -w /var/mytmp.txt ]</span><br><span class="line">-x filename	如果 filename 可执行，则为真	[ -L /usr/bin/grep ]</span><br><span class="line">filename1 -nt filename2	如果 filename1 比 filename2 新，则为真	[ /tmp/install/etc/services -nt /etc/services ]</span><br><span class="line">filename1 -ot filename2	如果 filename1 比 filename2 旧，则为真	[ /boot/bzImage -ot arch/i386/boot/bzImage ]</span><br></pre></td></tr></table></figure>
<p>字符串比较运算符 （请注意引号的使用，这是防止空格扰乱代码的好方法）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-z string	如果 string 长度为零，则为真	[ -z &quot;$myvar&quot; ]</span><br><span class="line">-n string	如果 string 长度非零，则为真	[ -n &quot;$myvar&quot; ]</span><br><span class="line">string1 = string2	如果 string1 与 string2 相同，则为真	[ &quot;$myvar&quot; = &quot;one two three&quot; ]</span><br><span class="line">string1 != string2	如果 string1 与 string2 不同，则为真	[ &quot;$myvar&quot; != &quot;one two three&quot; ]</span><br></pre></td></tr></table></figure>
<p>算术比较运算符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">num1 -eq num2	等于	[ 3 -eq $mynum ]</span><br><span class="line">num1 -ne num2	不等于	[ 3 -ne $mynum ]</span><br><span class="line">num1 -lt num2	小于	[ 3 -lt $mynum ]</span><br><span class="line">num1 -le num2	小于或等于	[ 3 -le $mynum ]</span><br><span class="line">num1 -gt num2	大于	[ 3 -gt $mynum ]</span><br><span class="line">num1 -ge num2	大于或等于	[ 3 -ge $mynum ]</span><br></pre></td></tr></table></figure>
<p>测试命令</p>
<h1 id="test命令用于检查某个条件是否成立，它可以进行数值、字符和文件3个方面的测试，其测试符和相应的功能分别如下。"><a href="#test命令用于检查某个条件是否成立，它可以进行数值、字符和文件3个方面的测试，其测试符和相应的功能分别如下。" class="headerlink" title="test命令用于检查某个条件是否成立，它可以进行数值、字符和文件3个方面的测试，其测试符和相应的功能分别如下。"></a>test命令用于检查某个条件是否成立，它可以进行数值、字符和文件3个方面的测试，其测试符和相应的功能分别如下。</h1><p>##（1）数值测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-eq 等于则为真。</span><br><span class="line"></span><br><span class="line">-ne 不等于则为真。</span><br><span class="line"></span><br><span class="line">-gt 大于则为真。</span><br><span class="line"></span><br><span class="line">-ge 大于等于则为真。</span><br><span class="line"></span><br><span class="line">-lt 小于则为真。</span><br><span class="line"></span><br><span class="line">-le 小于等于则为真。</span><br></pre></td></tr></table></figure>
<p>##（2）字串测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">= 等于则为真。</span><br><span class="line"></span><br><span class="line">!= 不相等则为真。</span><br><span class="line"></span><br><span class="line">-z字串 字串长度伪则为真。</span><br><span class="line"></span><br><span class="line">-n字串 字串长度不伪则为真。</span><br></pre></td></tr></table></figure>
<p>##（3）文件测试：</p>
<p>-e文件名 如果文件存在则为真。</p>
<p>-r文件名 如果文件存在且可读则为真。</p>
<p>-w文件名 如果文件存在且可写则为真。</p>
<p>-x文件名 如果文件存在且可执行则为真。</p>
<p>-s文件名 如果文件存在且至少有一个字符则为真。</p>
<p>-d文件名 如果文件存在且为目录则为真。</p>
<p>-f文件名 如果文件存在且为普通文件则为真。</p>
<p>-c文件名 如果文件存在且为字符型特殊文件则为真。</p>
<p>-b文件名 如果文件存在且为块特殊文件则为真</p>
<p>条件变量替换:<br>Bash Shell可以进行变量的条件替换,既只有某种条件发生时才进行替换,替换条件放在{}中.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) $&#123;value:-word&#125; </span><br><span class="line"></span><br><span class="line">当变量未定义或者值为空时,返回值为word的内容,否则返回变量的值. </span><br><span class="line"></span><br><span class="line">(2) $&#123;value:=word&#125; </span><br><span class="line"></span><br><span class="line">与前者类似,只是若变量未定义或者值为空时,在返回word的值的同时将word赋值给value </span><br><span class="line"></span><br><span class="line">(3) $&#123;value:?message&#125; </span><br><span class="line"></span><br><span class="line">若变量以赋值的话,正常替换.否则将消息message送到标准错误输出(若此替换出现在Shell程序中,那么该程序将终止运行) </span><br><span class="line"></span><br><span class="line">(4) $&#123;value:+word&#125; </span><br><span class="line">若变量以赋值的话,其值才用word替换,否则不进行任何替换 </span><br><span class="line"></span><br><span class="line">(5) $&#123;value:offset&#125; </span><br><span class="line">       $&#123;value:offset:length&#125;从变量中提取子串,这里offset和length可以是算术表达式. </span><br><span class="line"></span><br><span class="line">(6) $&#123;#value&#125; </span><br><span class="line"></span><br><span class="line">变量的字符个数 </span><br><span class="line"></span><br><span class="line">(7) $&#123;value#pattern&#125; 和 $&#123;value##pattern&#125; </span><br><span class="line">1. 去掉value中与pattern相匹配的部分,条件是value的开头与pattern相匹配</span><br><span class="line">2. ‘#’与‘##’的区别在于一个是最短匹配模式,一个是最长匹配模式. </span><br><span class="line"></span><br><span class="line">(8) $&#123;value%pattern&#125; 和 $&#123;value%%pattern&#125; </span><br><span class="line">于(7)类似,只是是从value的尾部于pattern相匹配,%与%%的区别与#与##一样 </span><br><span class="line"></span><br><span class="line">(9) $&#123;value/pattern/string&#125; 和 $&#123;value//pattern/string&#125; </span><br><span class="line">进行变量内容的替换,把与pattern匹配的部分替换为string的内容,/与//的区别与上同 </span><br><span class="line">注意: 上述条件变量替换中,除(2)外,其余均不影响变量本身的值 </span><br></pre></td></tr></table></figure>
<p>示例集合</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">var1=&quot;1&quot;</span><br><span class="line">var2=&quot;2&quot;</span><br><span class="line"></span><br><span class="line">下面是并且的运算符-a，另外注意，用一个test命令就可以了，还有if条件后面的分号</span><br><span class="line"></span><br><span class="line">if test $var1 = &quot;1&quot;-a $var2 = &quot;2&quot; ; then</span><br><span class="line">   echo &quot;equal&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">下面是或运算符 -o，有一个为真就可以</span><br><span class="line"></span><br><span class="line">if test $var1 != &quot;1&quot; -o $var2 != &quot;3&quot; ; then</span><br><span class="line">   echo &quot;not equal&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">下面是非运算符 ！</span><br><span class="line">if条件是为真的时候执行，如果使用！运算符，那么原表达式必须为false</span><br><span class="line"></span><br><span class="line">if ! test $var1 != &quot;1&quot;; then</span><br><span class="line">   echo &quot;not 1&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>以上三个if都为真，所以三个echo都会打印</p>
<p>在一个文档把这几个运算法说的一塌糊涂，于是自己动手实验了一下</p>
<p>shell字符串比较、判断是否为数字</p>
<p>二元比较操作符,比较变量或者比较数字.注意数字与字符串的区别.</p>
<p>整数比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-eq       等于,如:if [ &quot;$a&quot; -eq &quot;$b&quot; ]</span><br><span class="line">-ne       不等于,如:if [ &quot;$a&quot; -ne &quot;$b&quot; ]</span><br><span class="line">-gt       大于,如:if [ &quot;$a&quot; -gt &quot;$b&quot; ]</span><br><span class="line">-ge       大于等于,如:if [ &quot;$a&quot; -ge &quot;$b&quot; ]</span><br><span class="line">-lt       小于,如:if [ &quot;$a&quot; -lt &quot;$b&quot; ]</span><br><span class="line">-le       小于等于,如:if [ &quot;$a&quot; -le &quot;$b&quot; ]</span><br><span class="line">&lt;       小于(需要双括号),如:((&quot;$a&quot; &lt; &quot;$b&quot;))</span><br><span class="line">&lt;=       小于等于(需要双括号),如:((&quot;$a&quot; &lt;= &quot;$b&quot;))</span><br><span class="line">&gt;       大于(需要双括号),如:((&quot;$a&quot; &gt; &quot;$b&quot;))</span><br><span class="line">&gt;=       大于等于(需要双括号),如:((&quot;$a&quot; &gt;= &quot;$b&quot;))</span><br><span class="line">字符串比较</span><br><span class="line"></span><br><span class="line">=       等于,如:if [ &quot;$a&quot; = &quot;$b&quot; ]</span><br><span class="line">==       等于,如:if [ &quot;$a&quot; == &quot;$b&quot; ],与=等价</span><br><span class="line">       注意:==的功能在[[]]和[]中的行为是不同的,如下:</span><br><span class="line">       1 [[ $a == z* ]]    # 如果$a以&quot;z&quot;开头(模式匹配)那么将为true</span><br><span class="line">       2 [[ $a == &quot;z*&quot; ]] # 如果$a等于z*(字符匹配),那么结果为true</span><br><span class="line">       3</span><br><span class="line">       4 [ $a == z* ]      # File globbing 和word splitting将会发生</span><br><span class="line">       5 [ &quot;$a&quot; == &quot;z*&quot; ] # 如果$a等于z*(字符匹配),那么结果为true</span><br><span class="line">       一点解释,关于File globbing是一种关于文件的速记法,比如&quot;*.c&quot;就是,再如~也是.</span><br><span class="line">       但是file globbing并不是严格的正则表达式,虽然绝大多数情况下结构比较像.</span><br><span class="line">!=       不等于,如:if [ &quot;$a&quot; != &quot;$b&quot; ]</span><br><span class="line">       这个操作符将在[[]]结构中使用模式匹配.</span><br><span class="line">&lt;       小于,在ASCII字母顺序下.如:</span><br><span class="line">       if [[ &quot;$a&quot; &lt; &quot;$b&quot; ]]</span><br><span class="line">       if [ &quot;$a&quot; \&lt; &quot;$b&quot; ]</span><br><span class="line">       注意:在[]结构中&quot;&lt;&quot;需要被转义.</span><br><span class="line">&gt;       大于,在ASCII字母顺序下.如:</span><br><span class="line">       if [[ &quot;$a&quot; &gt; &quot;$b&quot; ]]</span><br><span class="line">       if [ &quot;$a&quot; \&gt; &quot;$b&quot; ]</span><br><span class="line">       注意:在[]结构中&quot;&gt;&quot;需要被转义.</span><br><span class="line">       具体参考Example 26-11来查看这个操作符应用的例子.</span><br><span class="line">-z       字符串为&quot;null&quot;.就是长度为0.</span><br><span class="line">-n       字符串不为&quot;null&quot;</span><br><span class="line">       注意:</span><br><span class="line">       使用-n在[]结构中测试必须要用&quot;&quot;把变量引起来.使用一个未被&quot;&quot;的字符串来使用! -z</span><br><span class="line">       或者就是未用&quot;&quot;引用的字符串本身,放到[]结构中。虽然一般情况下可</span><br><span class="line">       以工作,但这是不安全的.习惯于使用&quot;&quot;来测试字符串是一种好习惯.</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>linux用户及权限</title>
    <url>/2021/09/22/linux/userp/</url>
    <content><![CDATA[<p>linux 用户管理</p>
<p>文件解压</p>
<p>tar -xvf  压缩文件 -C /指定目录</p>
<p>-x : –extract，–get 解开tar文件。</p>
<p>-v : –verbose 列出每一步处理涉及的文件的信息，只用一个“v”时，仅列出文件名，使用两个“v”时，列出权限、所有者、大小、时间、文件名等信息。</p>
<p>-f : –file [主机名:]文件名 指定要处理的文件名。可以用“-”代表标准输出或标准输入</p>
<p>文件属性：</p>
<p>lsattr</p>
<p>chattr</p>
<p>yum -y install e2fsprogs</p>
<p>任务：</p>
<p>/etc/crontab </p>
<p>/var/spool/cron/user</p>
<h3 id="系统时间相关"><a href="#系统时间相关" class="headerlink" title="系统时间相关"></a>系统时间相关</h3><p>依次显示了系统当前时间 、系统到目前为止已运行的时间、当前登录系统的用户数量</p>
<h3 id="平均负载"><a href="#平均负载" class="headerlink" title="平均负载"></a>平均负载</h3><p>系统负载(任务队列的平均长度)三个值分别为1分钟、5分钟、15分钟前到现在的平均值（根据cpu数量去判断。如果平均负载始终在1.2一下，而你有2颗cup的机器。那么基本不会出现cpu不够用的情况。也就是Load平均要小于Cpu的数量，一般性负载超过cpu的个数的5倍则表示已经超负载了）</p>
<h3 id="进程相关参数"><a href="#进程相关参数" class="headerlink" title="进程相关参数"></a>进程相关参数</h3><p>Tasks: 288 total（总进程数）,  2 running（运行中的进程数）, 286 sleeping（挂起的进程数）,  0 stopped（停止的进程数）,  0 zombie（僵尸进程数）</p>
<h3 id="cpu相关参数"><a href="#cpu相关参数" class="headerlink" title="cpu相关参数"></a>cpu相关参数</h3><p>Cpu(s): 32.0%us（用户使用cpu占比）, 2.0%sy（系统使用cpu占比）, 0.0%ni（用户空间内改变过优先级的进程占用CPU百分比）, 65.3%id（空闲cpu占比）, 0.1%wa（等待输入输出CPU时间百分比）, 0.1%hi（CPU服务于硬件中断所耗费的时间总额）, 0.5%si（CPU服务软中断所耗费的时间总额）, 0.0%st（Steal Time）</p>
<h3 id="内存相关参数"><a href="#内存相关参数" class="headerlink" title="内存相关参数"></a>内存相关参数</h3><p>Mem: 16466536k total（物理内存总量）, 7943976k used（已使用的物理内存）, 8522560k free（剩余的物理内存）,  404760k buffers（缓冲区内存）</p>
<h3 id="交换分区相关参数"><a href="#交换分区相关参数" class="headerlink" title="交换分区相关参数"></a>交换分区相关参数</h3><p>Swap: 4194300k total（交换分区总量）,    0k used（已使用交换分区）, 4194300k free（交换分区剩余量）, 2228400k cached（缓冲的交换分区总量）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PID（进程PID） </span><br><span class="line">USER（进程所有者）      </span><br><span class="line">PR（优先级）  </span><br><span class="line">NI（nice值，负值表示高优先级，正值表示低优先级）  </span><br><span class="line">VIRT（进程使用的虚拟内存总量，VIRT=SWAP+RES）  </span><br><span class="line">RES（进程使用的、未被换出的物理内存大小）  </span><br><span class="line">SHR（共享内存大小） </span><br><span class="line">S（进程状态，D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程） </span><br><span class="line">%CPU（上次更新到现在的CPU时间占用百分比） </span><br><span class="line">%MEM（进程使用的物理内存百分比）    </span><br><span class="line">TIME+（进程使用CPU总时间）  </span><br><span class="line">COMMAND（命令名、命令行）</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2021/11/09/markdown/jibenyufa/</url>
    <content><![CDATA[<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section"># 这是一级标题</span></span><br><span class="line"><span class="section">## 这是二级标题</span></span><br><span class="line"><span class="section">### 这是三级标题</span></span><br><span class="line"><span class="section">#### 这是四级标题</span></span><br><span class="line"><span class="section">##### 这是五级标题</span></span><br><span class="line"><span class="section">###### 这是六级标题</span></span><br></pre></td></tr></table></figure>

<h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul>
<li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5></li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5></li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5></li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="strong">**这是加粗的文字**</span></span><br><span class="line"><span class="emphasis">*这是倾斜的文字*</span>`</span><br><span class="line"><span class="strong">**<span class="emphasis">*这是斜体加粗的文字*</span>**</span></span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 这是引用的内容</span></span><br><span class="line">&gt;&gt; 这是引用的内容</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 这是引用的内容</span><br></pre></td></tr></table></figure>

<h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="section">---</span></span><br><span class="line">----</span><br><span class="line"><span class="strong">***</span></span><br><span class="line"><span class="strong">**</span><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure>

<h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">图片alt</span>](<span class="link">图片地址 &#x27;&#x27;图片title&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">[<span class="string">超链接名</span>](<span class="link">超链接地址 &quot;超链接title&quot;</span>)</span><br><span class="line"></span><br><span class="line">[<span class="string">简书</span>](<span class="link">http://jianshu.com</span>)</span><br><span class="line">[<span class="string">百度</span>](<span class="link">http://baidu.com</span>)</span><br></pre></td></tr></table></figure>

<h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>无序列表用 - + * 任何一种都可以</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> 列表内容</span><br><span class="line"><span class="bullet">+</span> 列表内容</span><br><span class="line"><span class="bullet">*</span> 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">1.</span> 列表内容</span><br><span class="line"><span class="bullet">2.</span> 列表内容</span><br><span class="line"><span class="bullet">3.</span> 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<h5 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h5><p><strong>上一级和下一级之间敲三个空格即可</strong></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>保持模型的完整性</title>
    <url>/2023/11/26/softwareeng/DDD/</url>
    <content><![CDATA[<h2 id="界限上下文之间的集成策略（界限上下文之间的关系）"><a href="#界限上下文之间的集成策略（界限上下文之间的关系）" class="headerlink" title="界限上下文之间的集成策略（界限上下文之间的关系）"></a>界限上下文之间的集成策略（界限上下文之间的关系）</h2><p>限界上下文定义领域边界，以确保每个上下文含义在它特定的边界内都具有唯一的含义，领域模型则存在于这个边界之内。<br>不同的上下文之间出现相同含义的领域模型该如何保持每个上下文中的模型完整？新系统与老系统之间的集成该如何保证模型的完成？多个子系统集成该用那种策略？</p>
<h3 id="1-共享内核模式-Shared-Kernel"><a href="#1-共享内核模式-Shared-Kernel" class="headerlink" title="1. 共享内核模式(Shared Kernel)"></a>1. 共享内核模式(Shared Kernel)</h3><p>   提高服用能力，减少持续集成和模型转换所带来的开销，是共享内核模式主要目的</p>
<p>   当不同的团队开发一些紧密相关的应用程序时，如果团队之间不进行协调，即使短时间内能够有快速的进展，但是他们开发出来的产品可能也无法结合到一起，最后可能不得不耗费大量精力进行模型转换，这也是持续集成的必要性。</p>
<p>   在很多项目中，不同的团队能够共享基础设施，领域工作也可以采用类似的方式，以得到很好的效果。因为保持模型和代码的完全同步的开销可能太高了，但从系统中仔细挑选出一部分保持同步，就能以较小的代价获得较大的收益。</p>
<p>   因此<br>   从领域模型中挑选出两个团队都同意共享的子集，除了模型还有代码子集，数据库设计子集，来作为共享的基础设施，这部分明确共享的内容具有特殊的地位，团队之间如果没有商量好的情况下事不应擅自更改。<br>   这要求两个团队之间需要紧密的合作关系</p>
<h3 id="2-客户供应商模式（Customer-Supplier）"><a href="#2-客户供应商模式（Customer-Supplier）" class="headerlink" title="2. 客户供应商模式（Customer/Supplier）"></a>2. 客户供应商模式（Customer/Supplier）</h3><p>   明确客户供应商关系是关键</p>
<p>   在很多项目中，如果下游团队对比变更具有否决权，或请求并更的程序爱太复杂，那么上游团队的开发自由度就会很受限制。由于担心破坏下系统，上游团队甚至会受到抑制。同时由于上游团队掌握优先权，下游团队有时候也无能为力。（下游团队依赖上游团队，但是上游团队却不负责下游团队的产品交付）</p>
<p>   因此<br>   在两个团队之间建立一个明确的客户供应商关系，在计划会议中，下游团队相当于上游团队的客户。根据下游团队的需求来协商需要执行的任务。<br>   两个团队需要归属于同一个管理者指挥</p>
<h3 id="3-追随者模式（Conformist）"><a href="#3-追随者模式（Conformist）" class="headerlink" title="3. 追随者模式（Conformist）"></a>3. 追随者模式（Conformist）</h3><p>   当两个团队并不归属于同一管理者指挥，两个团队在管理层次中相各很远，或者主管不关心两个团队之间的关系，客户供应商模式将无法达到其效果。<br>   也许上游团队成员做出承诺，但他们可能不会履行承诺。下游团队项目只能被搁置，直到最终学会利用现有条件自力更生。</p>
<p>   有三种解决途径<br>   1). 完全放弃上游，<br>       做这种选择时候，绝不要假定上游会满足下游系统需求，有时候我们会高估这种依赖的价值，低估他的成本。<br>   2). 上游模型设计难用，自行设计模型，并负责模型转换<br>   3). 上游设计质量不是很差，而且风格也能兼容，最好不要再次开发独立模型，可采用追随者模式</p>
<p>   因此<br>   通过严格遵从上游团队的模型，可以消除在上下文之间进行转换的复杂性，尽管这会限制下游设计人员的风格，而且不会得到很理想的模型，但他简化了集成。</p>
<h3 id="4-防腐层模式（Anti-corruption-layer）"><a href="#4-防腐层模式（Anti-corruption-layer）" class="headerlink" title="4. 防腐层模式（Anti-corruption layer）"></a>4. 防腐层模式（Anti-corruption layer）</h3><p>   新系统集成遗留系统或与其他系统集成，这些系统都有自己的模型，当把参与集成的界限上下文实际完善并且团队相互合作时，转换层可能很简单，甚至很优雅。而且当边界那侧发生渗透<br>   时，转换层就要承担起更多的防护职责。</p>
<blockquote>
<p>①遗留系统模型偏弱，②模型转换简单，③团队相互配合，防腐层还有防止模型侵入的优点</p>
</blockquote>
<p>   因此<br>   创建一个隔离层，以便根据客户自己的领域模型为客户相关功能，这个层通过另一个系统现有接口与其进行对话，而只需要对那个系统做出少量修改甚至无需修改。在内部这个层在两个模型之间进行必要的双向转换。</p>
<p>   实现：门面模式（Facade） 适配器模式(Adapter)</p>
<h3 id="5-开放主机模式-（OPENHOST）"><a href="#5-开放主机模式-（OPENHOST）" class="headerlink" title="5. 开放主机模式 （OPENHOST）"></a>5. 开放主机模式 （OPENHOST）</h3><p>   一次性集成可以采用防腐层的方式开发对应的模型转换，但是当遇到子系统要与大量的其他系统集成的时候，为每个集成都定制一个转换层可能会减慢团队的工作进度。<br>   团队可能正在反复坐着同样的事情，如果一个子系统有某种内聚性，那么或者可以把他描述为一组Service,这组Service满足了其他子系统的公共需求。</p>
<p>   因此<br>   定义一个协议，把子系统作为一组service供其他系统访问（可通过某种配置定位服务），开放协议，以便所有需要与你的子系统集成的人都可以使用它。</p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>软件开发方法学</title>
    <url>/2022/06/05/softwareeng/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%E5%AD%A6/</url>
    <content><![CDATA[<p>(1)生命周期法。软件开发严格按系统调查与分析、系统设计、系统实现、系统调试、运行维护和废弃等阶段进行。这种方法要求系统说明书应准确地表达用户的要求，并且在以后阶段不会发生变化。<br>　　<br>生命周期法采用结构化系统分析与设计的思想，其突出优点是强调系统开发过程的整体性和全局性，避免了开发过程中的混乱状态。其主要缺陷是开发周期长，工作效率低，难以适应新型开发工具的发展，但其基本思想在其他开发方法仍然适用。<br>　　<br>(2)原型法。开发人员首先构造系统初步模型，运行这个模型并根据用户的要求不断修改、补充，直到取得一个用户完全满意的原型为止，最后实现系统。  </p>
<p>原型法的主要优点是开发周期短、见效快，可以边开发边使用，比较适合于管理体制和结构不稳定，需要经常变化的环境。其缺点是初始原型设计比较困难，容易陷入软件危机，对于大型复杂的应用系统一般不宜采用。<br>　　<br>(3)面向对象法。简称OO，其基本思想是：客观事物都是由对象组成的，对象具有属性和方法，属性反映对象的特征，方法则是改变属性的各种动作；对象之间的联系主要通过传递消息来实现；对象可以按属性归为类，类有一定的结构，而且可以有子类，对象与类之间的层次关系是通过继承来维持的。<br>　　<br>按照上述思想，OO方法分为四个阶段：系统调查和需求分析，解决系统干什么；面向对象分析，识别出对象及其行为、结构、属性和方法，简称OOA；面向对象设计，对分析结果进一步抽象、归类和整理，最终以范式的形式确定下来，简称OOD；面向对象编程，利用面向对象程序设计语言编制应用程序，简称OOP。  </p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>开发方法</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper</title>
    <url>/2022/05/28/java/zk/</url>
    <content><![CDATA[<h1 id="ZK集群"><a href="#ZK集群" class="headerlink" title="ZK集群"></a>ZK集群</h1><h2 id="ZK相关配置"><a href="#ZK相关配置" class="headerlink" title="ZK相关配置"></a>ZK相关配置</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">tickTime</span>=<span class="string">2000</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dataDir</span>=<span class="string">/var/lib/zookeeper/data</span></span><br><span class="line"></span><br><span class="line"><span class="attr">dataLogDir</span>=<span class="string">/var/lib/zookeeper/datalog</span></span><br><span class="line"></span><br><span class="line"><span class="attr">clientPort</span>=<span class="string">2181</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initLimit</span>=<span class="string">5</span></span><br><span class="line"></span><br><span class="line"><span class="attr">syncLimit</span>=<span class="string">2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">maxClientCnxns</span>=<span class="string">60</span></span><br><span class="line"></span><br><span class="line"><span class="attr">peerType</span>=<span class="string">observer  #observer配置</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#dataDir目录中新增myid文件，myid配置范围1-255，端口1leader进行通信和数据同步的端口，端口2位选举投票接口</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.1</span>=<span class="string">10.3.60.151:2888:3888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.2</span>=<span class="string">10.3.60.152:2888:3888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.3</span>=<span class="string">10.3.60.153:2888:3888</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server.x</span>=<span class="string">host:port1:port2:observer #observer配置</span></span><br></pre></td></tr></table></figure>



<h2 id="ZK中Leader选举"><a href="#ZK中Leader选举" class="headerlink" title="ZK中Leader选举"></a>ZK中Leader选举</h2><p><strong>集群中节点角色</strong></p>
<table>
<thead>
<tr>
<th>角色</th>
<th>读写</th>
<th>选举</th>
<th>过半写</th>
</tr>
</thead>
<tbody><tr>
<td>Leader</td>
<td>负责客户端读写</td>
<td>参与leader选举</td>
<td>参与过半写成功</td>
</tr>
<tr>
<td>Follower</td>
<td>负责客户端读</td>
<td>参与leader选举</td>
<td>参与过半写成功</td>
</tr>
<tr>
<td>Observer</td>
<td>负责客户端读</td>
<td>不参与leader选举</td>
<td>不参与过半写成功</td>
</tr>
</tbody></table>
<blockquote>
<p>Observer 在不影响写性能的条件下，提升集群的读性能</p>
</blockquote>
<p><strong>相关属性：</strong></p>
<p>SID:服务编号，及dataDir目录下myid编号</p>
<p>ZXID：事务编号，改变zookeeper几圈状态的操作，数据节点创建及删除，数据变更，客户单建立链接，及链接失效等变更都会产生新的事务编号。一般情况先会选ZXID大的节点为Leader ,如果都一样会选择SID大的节点为Leader</p>
<p>QUORUM：过半计数器</p>
<p>EPOCH：每个leader的纪元，生成新的leader都会生成一个新的增长的纪元。</p>
<h2 id="脑裂问题"><a href="#脑裂问题" class="headerlink" title="脑裂问题"></a>脑裂问题</h2><p><strong>脑裂问题描述：</strong><br>对于一个集群，想要提高这个集群的可用性，通常会采用多机房部署，比如现在有一个由6台zkServer所组成的一个集群，部署在了两个机房：</p>
<img src="/2022/05/28/java/zk/zk1.png" class="" title="脑裂问题">

<p>&emsp;&emsp;正常情况下，此集群只会有一个Leader，那么如果机房之间的网络断了之后，两个机房内的zkServer还是可以相互通信的，如果不考虑过半机制，那么就会出现每个机房内部都将选出一个Leader。</p>
<img src="/2022/05/28/java/zk/zk2.png" class="" title="脑裂问题">

<p>&emsp;&emsp;这就相当于原本一个集群，被分成了两个集群，出现了两个”大脑”，这就是所谓的”脑裂”现象。对于这种情况，其实也可以看出来，原本应该是统一的一个集群对外提供服务的，现在变成了两个集群同时对外提供服务，如果过了一会，断了的网络突然联通了，那么此时就会出现问题了，两个集群刚刚都对外提供服务了，数据该怎么合并，数据冲突怎么解决等等问题。刚刚在说明脑裂场景时有一个前提条件就是没有考虑过半机制.所以实际上Zookeeper集群中是不会轻易出现脑裂问题的，原因在于过半机制.</p>
<img src="/2022/05/28/java/zk/zk3.png" class="" title="脑裂问题">

<p>&emsp;&emsp;zookeeper的过半机制（Quorums (法定人数) 方式）：在领导者选举的过程中，如果某台zkServer获得了超过半数的选票，则此zkServer就可以成为Leader了。举个简单的例子：如果现在集群中有5台zkServer，那么half=5/2=2，那么也就是说，领导者选举的过程中至少要有三台zkServer投了同一个zkServer，才会符合过半机制，才能选出来一个Leader。</p>
<blockquote>
<p>过半机制很好的杜绝了脑列的问题</p>
</blockquote>
<h2 id="ZK作为master选举脑裂导致数据一致性问题："><a href="#ZK作为master选举脑裂导致数据一致性问题：" class="headerlink" title="ZK作为master选举脑裂导致数据一致性问题："></a>ZK作为master选举脑裂导致数据一致性问题：</h2><p>&emsp;&emsp;kafka将数据以主题划分，并且每个主题可以有多个分片，每个分片可以有多个副本，在多个副本中需要选择出主副本和副本，有主副本完成数据的操作，副本分片完成数据同步。<br>那么当出现主副本与zk因为网络问题，导致zk认为主副本掉线，重新选举主副本，但是此时主副本没有死掉，所以导致了主副本的假死现象。<br>&emsp;&emsp;如果客户端还未完成副本列表切换，那么会导致数据写入假死的副本，而完成了切换的节点数会写入到新的主副本，那么就导致了数据不一致,<br>&emsp;&emsp;Epoch leader纪元或者版本号或者叫做leader周期，当产生新的Leader后纪元会随之增加，那么老的leader数据不会同步到新的集群范围内，通过Epoch来控制集群的数据不一致性，及通过集群状态的版本号</p>
<h2 id="过半机制"><a href="#过半机制" class="headerlink" title="过半机制:"></a>过半机制:</h2><p>&emsp;&emsp;过半机制很好的杜绝了脑列的问题,过半验证还提高了系统效率，在写操作或者投票过程中不需要所有节点都完成，只要过半就完成投票或者写操作。</p>
<p><strong>容忍度问题：容忍度为n,那么集群建议的部署节点为2N+1</strong></p>
<p>&emsp;&emsp;一般情况下我们建议集群部署的节点为奇数个节点。至于为什么最好为奇数个节点？这样是为了以最大容错服务器个数的条件下，能节省资源。比如，最大容错为2的情况下，对应的zookeeper服务数，奇数为5，而偶数为6，也就是6个zookeeper服务的情况下最多能宕掉2个服务，所以从节约资源的角度看，没必要部署6（偶数）个zookeeper服务节点</p>
<h2 id="ZK权限认证方式"><a href="#ZK权限认证方式" class="headerlink" title="ZK权限认证方式"></a>ZK权限认证方式</h2><p>ACL全称为Access Control List（访问控制列表），用于控制资源的访问权限,可以控制节点的读写操作,保证数据的安全性 。</p>
<p>ZooKeeper使用ACL来控制对其znode的防问。</p>
<p>Zookeeper ACL 权限设置分为 3 部分组成，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）</p>
<p>基于scheme:id:permission的方式进行权限控制： scheme表示授权模式、id模式对应值、permission即具体的增删改权限位。</p>
<h3 id="权限模式（Scheme）"><a href="#权限模式（Scheme）" class="headerlink" title="权限模式（Scheme）"></a>权限模式（Scheme）</h3><table>
<thead>
<tr>
<th>方案</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>world</td>
<td>开放模式，world表示全世界都可以访问（这是默认设置）</td>
<td></td>
</tr>
<tr>
<td>ip</td>
<td>ip模式，限定客户端IP防问</td>
<td></td>
</tr>
<tr>
<td>auth</td>
<td>用户密码认证模式，只有在会话中添加了认证才可以防问</td>
<td></td>
</tr>
<tr>
<td>digest</td>
<td>与auth类似，区别在于auth用明文密码，而digest 用sha-1+base64加密后的密码。在实际使用中digest 更常见。</td>
<td></td>
</tr>
<tr>
<td>super</td>
<td>管理员</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>范围验证 范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。我们可以让一个 IP 地址为“ip：192.168.11.123”的机器对服务器上的某个数据节点具有写入的权限。或者也可以通过“ip:192.168.0.1/24”给一段 IP 地址的机器赋权。</p>
</blockquote>
<h3 id="授权对象（ID）"><a href="#授权对象（ID）" class="headerlink" title="授权对象（ID）"></a>授权对象（ID）</h3><p>授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，</p>
<ol>
<li><p>如果我们 选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段</p>
</li>
<li><p>使用 Digest 或 Super 方式，则对应于一个用户名</p>
</li>
<li><p>World 模式，是授权系统中所有的用户</p>
</li>
</ol>
<h3 id="权限信息（Permission）"><a href="#权限信息（Permission）" class="headerlink" title="权限信息（Permission）"></a>权限信息（Permission）</h3><p>权限就是指我们可以在数据节点上执行的操作种类，如下所示：在 ZooKeeper 中已经定义好的权限有 5 种：</p>
<ul>
<li>数据节点（c: create）创建权限，授予权限的对象可以在数据节点下创建子节点；</li>
<li>数据节点（w: wirte）更新权限，授予权限的对象可以更新该数据节点；</li>
<li>数据节点（r: read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的列表信息；</li>
<li>数据节点（d: delete）删除权限，授予权限的对象可以删除该数据节点的子节点；</li>
<li>数据节点（a: admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。</li>
</ul>
<h3 id="ACL相关命令"><a href="#ACL相关命令" class="headerlink" title="ACL相关命令"></a>ACL相关命令</h3><table><thead><tr><th style="text-align:left"><div><div class="table-header"><p>命令</p></div></div></th><th style="text-align:left"><div><div class="table-header"><p>使用方式</p></div></div></th><th style="text-align:left"><div><div class="table-header"><p>描述</p></div></div></th></tr></thead><tbody><tr><td style="text-align:left"><div><div class="table-cell"><p>getAcl</p></div></div></td><td style="text-align:left"><div><div class="table-cell"><p>getAcl path</p></div></div></td><td style="text-align:left"><div><div class="table-cell"><p>读取ACL权限</p></div></div></td></tr><tr><td style="text-align:left"><div><div class="table-cell"><p>setAcl</p></div></div></td><td style="text-align:left"><div><div class="table-cell"><p>setAcl path acl</p></div></div></td><td style="text-align:left"><div><div class="table-cell"><p>设置ACL权限</p></div></div></td></tr><tr><td style="text-align:left"><div><div class="table-cell"><p>addauth</p></div></div></td><td style="text-align:left"><div><div class="table-cell"><p>addauth scheme auth</p></div></div></td><td style="text-align:left"><div><div class="table-cell"><p>添加认证用户</p></div></div></td></tr></tbody></table>

<img src="/2022/05/28/java/zk/zk4.png" class="" title="ACL相关命令">

<h3 id="跳过ACL检测"><a href="#跳过ACL检测" class="headerlink" title="跳过ACL检测"></a>跳过ACL检测</h3><p>可以通过系统参数zookeeper.skipACL=yes进行配置，默认是no,可以配置为true, 则配置过的ACL将不再进行权限检测</p>
<p>zkServer.sh</p>
<img src="/2022/05/28/java/zk/zk.png" class="" title="ACL相关命令">

<h3 id="权限扩展体系"><a href="#权限扩展体系" class="headerlink" title="权限扩展体系"></a>权限扩展体系</h3><p><a href="https://zookeeper.apache.org/doc/r3.8.0/zookeeperProgrammers.html#sc_ZooKeeperPluggableAuthentication"></a></p>
<p>1: zookeeper支持自定义权限扩展，只需要集成通用的标准接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthenticationProvider</span> &#123;</span><br><span class="line">    String <span class="title function_">getScheme</span><span class="params">()</span>;</span><br><span class="line">    KeeperException.Code <span class="title function_">handleAuthentication</span><span class="params">(ServerCnxn cnxn, <span class="type">byte</span> authData[])</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String id)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(String id, String aclExpr)</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isAuthenticated</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2: 插件配置 (两种方式只有一个起作用)<br>方式1 系统变量</p>
<p>-Dzookeeeper.authProvider.X=com.f.MyAuth</p>
<p>方式2 配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">authProvider.1</span>=<span class="string">com.f.MyAuth</span></span><br><span class="line"><span class="attr">authProvider.2</span>=<span class="string">com.f.MyAuth2</span></span><br></pre></td></tr></table></figure>

<h2 id="实操ACL"><a href="#实操ACL" class="headerlink" title="实操ACL"></a>实操ACL</h2><h3 id="生成授权ID"><a href="#生成授权ID" class="headerlink" title="生成授权ID"></a>生成授权ID</h3><ul>
<li>方式一 Code<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateSuperDigest</span><span class="params">()</span> <span class="keyword">throws</span> NoSuchAlgorithmException &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sId</span> <span class="operator">=</span> DigestAuthenticationProvider.generateDigest(<span class="string">&quot;artisan:xgj&quot;</span>);</span><br><span class="line">    System.out.println(sId); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>方式二 shell命令<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo -n &lt;user&gt;:&lt;password&gt; | openssl dgst -binary -sha1 | openssl base64</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]# echo -n artisan:xgj | openssl dgst -binary -sha1 | openssl base64</span><br><span class="line">Xe7+HMYId2eNV48821ZrcFwIqIE=</span><br><span class="line">[root@localhost bin]# </span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="方式一-digest-密文授权"><a href="#方式一-digest-密文授权" class="headerlink" title="方式一 digest 密文授权"></a>方式一 digest 密文授权</h3><p>创建Node的时候 设置acl</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 10] create /artisan_node artisan_value digest:artisan:Xe7+HMYId2eNV48821ZrcFwIqIE=:cdrwa</span><br><span class="line">Created /artisan_node</span><br><span class="line">[zk: localhost:2181(CONNECTED) 11] get /artisan_node  # 直接查看没有访问权限的 </span><br><span class="line">org.apache.zookeeper.KeeperException$NoAuthException: KeeperErrorCode = NoAuth for /artisan_node</span><br><span class="line">[zk: localhost:2181(CONNECTED) 12] </span><br></pre></td></tr></table></figure>
<p>创建node的时候不指定acl ,然后用setAcl 设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setAcl /artisan_node digest:artisan:Xe7+HMYId2eNV48821ZrcFwIqIE=:cdrwa</span><br></pre></td></tr></table></figure>
<p>如何才能有访问权限呢？ 因为是给artisan这个用户赋权的<br>【访问前需要添加授权信息】addauth</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 12] addauth digest artisan:xgj</span><br><span class="line">[zk: localhost:2181(CONNECTED) 13] get /artisan_node</span><br><span class="line">artisan_value</span><br><span class="line">[zk: localhost:2181(CONNECTED) 14] </span><br></pre></td></tr></table></figure>
<h3 id="方式二-auth-明文授权"><a href="#方式二-auth-明文授权" class="headerlink" title="方式二 auth 明文授权"></a>方式二 auth 明文授权</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 14] addauth digest aaa:passwddd</span><br><span class="line">[zk: localhost:2181(CONNECTED) 15] create /artisanNNN  nodeValue auth:aaa:passwddd:cdwra   # 这是aaa用户授权信息会被zk保存，可以认为当前的授权用户为aaa</span><br><span class="line">Created /artisanNNN</span><br><span class="line">[zk: localhost:2181(CONNECTED) 16] get /artisanNNN</span><br><span class="line">nodeValue</span><br><span class="line">[zk: localhost:2181(CONNECTED) 17] </span><br></pre></td></tr></table></figure>
<h3 id="方式三-IP授权模式"><a href="#方式三-IP授权模式" class="headerlink" title="方式三 IP授权模式"></a>方式三 IP授权模式</h3><p>创建时设置ip的权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">create /node-ip  data  ip:192.168.11.123:cdwra</span><br></pre></td></tr></table></figure>
<p>或者创建完成以后 手工调用setAcl</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">setAcl /node-ip ip:192.168.11.123:cdwra</span><br></pre></td></tr></table></figure>
<h3 id="方式四-Super-超级管理员模式"><a href="#方式四-Super-超级管理员模式" class="headerlink" title="方式四 Super 超级管理员模式"></a>方式四 Super 超级管理员模式</h3><p>是一种特殊的Digest模式， 在Super模式下超级管理员用户可以对Zookeeper上的节点进行任何的操作.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-Dzookeeper.DigestAuthenticationProvider.superDigest=super:&lt;base64encoded(SHA1(password))</span><br></pre></td></tr></table></figure>

<img src="/2022/05/28/java/zk/zk5.png" class="">

<h2 id="Zookeeper应用场景"><a href="#Zookeeper应用场景" class="headerlink" title="Zookeeper应用场景"></a>Zookeeper应用场景</h2>]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringWebMvc-HandlerAdapter</title>
    <url>/2021/09/08/spring/HandlerAdapter/</url>
    <content><![CDATA[<p>HandlerAdapter负责调用映射到请求的处理程序，HandlerAdapter主要目的是隐藏调用细节，简化DispatcherServlet，让DispatcherServlet专注于流程控制.</p>
<p>DispatcherServlet在处理请求的时候从维护的handler适配器列表中获取并选择合适的适配器执行器去执行，那HandlerAdapter是如何注册到DispatcherServlet中的呢 </p>
<p>HandlerMapping中映射着具体的处理器handler类型繁多（如HandlerMethod Controller HandlerFunction Servlet HttpRequestHandler等），功能各异，那这些处理程序的执行各有不同，执行方式也各有不同，DispatcherServlet是如何根据handler找到指定的HandlerAdapter并完成执行请求的呢</p>
<p>HandlerAdapter要处理的具体执行器有多重类型（如HandlerMethod Controller HandlerFunction Servlet HttpRequestHandler等）那么他们是通过哪些HandlerAdapter具体实现来处理的呢 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">/******支持处理程序检测******/</span></span><br><span class="line">	<span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span>;</span><br><span class="line">    <span class="comment">/******处理请求调用******/</span></span><br><span class="line">	ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">    <span class="comment">/******返回最后修改时间******/</span></span><br><span class="line">	<span class="type">long</span> <span class="title function_">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="HandlerAdapter探测"><a href="#HandlerAdapter探测" class="headerlink" title="HandlerAdapter探测"></a>HandlerAdapter探测</h1><p>DispatcherServlet 继承自FrameworkServlet ，并且实现了onRefresh 监听WebApplicationContext刷新方法，完成MVC各个处理节点处理策略的初始化，其中HandlerAdapter就是其中之一，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">		initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>完成探测并维护HandlerAdapter到DispatcherServlet的handlerAdapters中：</p>
<ol>
<li>根据detectAllHandlerAdapters（是否探测所有的HandlerAdapter）属性 true 完成 从bean容器中获取所有的HandlerAdapter</li>
<li>根据detectAllHandlerAdapters（是否探测所有的HandlerAdapter）属性 false 完成 从bean容器中获取beanName 为handlerAdapter类型为HandlerAdapter</li>
<li>如果都没有，就从默认DispatcherServlet.properties 配置中获取，spring-webmvc 包下配置了默认的策略规则HandlerAdapter的默认策略规则为</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.web.servlet.HandlerAdapter</span>=<span class="string">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span></span><br><span class="line"><span class="string">   org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span></span><br><span class="line"><span class="string">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\</span></span><br><span class="line"><span class="string">   org.springframework.web.servlet.function.support.HandlerFunctionAdapter</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerAdapters</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.handlerAdapters = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerAdapters) &#123;</span><br><span class="line">			Map&lt;String, HandlerAdapter&gt; matchingBeans =</span><br><span class="line">					BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">				<span class="built_in">this</span>.handlerAdapters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchingBeans.values());</span><br><span class="line">				AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerAdapters);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);</span><br><span class="line">				<span class="built_in">this</span>.handlerAdapters = Collections.singletonList(ha);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters == <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="built_in">this</span>.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h1 id="DispatcherServlet根据handler匹配到HandlerAdapter并完成请求执行"><a href="#DispatcherServlet根据handler匹配到HandlerAdapter并完成请求执行" class="headerlink" title="DispatcherServlet根据handler匹配到HandlerAdapter并完成请求执行"></a>DispatcherServlet根据handler匹配到HandlerAdapter并完成请求执行</h1><p>DispatcherServlet根据请求完成HandlerExecutionChain构建之后，DispatcherServlet已经知道了需要哪个执行器去执行并且需要执行哪些拦截器，剩下的需要Adapter接管具体的Handler执行操作。</p>
<p>程序从Mapping阶段 （根据请求映射到确定handler和HandlerInterceptor）进入Adapter阶段(根据具体的handler确定具体的适配执行器),在适配阶段，DispatcherServlet根据具体的Handler由HandlerAdapter 自行适配handler。并告知DispatcherServlet，是否能处理，如果HandlerAdapter 告知DispatcherServlet支持此当前请求的handler，那么DispatcherServlet将采用，并在后续的方法中将执行操作委派给HandlerAdapter </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerAdapter <span class="title function_">getHandlerAdapter</span><span class="params">(Object handler)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.handlerAdapters != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (HandlerAdapter adapter : <span class="built_in">this</span>.handlerAdapters) &#123;</span><br><span class="line">				<span class="keyword">if</span> (adapter.supports(handler)) &#123;</span><br><span class="line">					<span class="keyword">return</span> adapter;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******根据具体的handler确定具体的适配执行器******/</span></span><br><span class="line"><span class="type">HandlerAdapter</span> <span class="variable">ha</span> <span class="operator">=</span> getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"><span class="comment">/******拦截器PreHandle ******/</span></span><br><span class="line"><span class="keyword">if</span> (!handlerExecutionChain.applyPreHandle(processedRequest, response)) &#123;<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="comment">/******将执行操作委派给HandlerAdapter ******/</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"><span class="comment">/******拦截器PostHandle ******/</span></span><br><span class="line">handlerExecutionChain.applyPostHandle(processedRequest, response, mv);</span><br></pre></td></tr></table></figure>

<h1 id="处理器Handler类型及与之对应的HandlerAdapter"><a href="#处理器Handler类型及与之对应的HandlerAdapter" class="headerlink" title="处理器Handler类型及与之对应的HandlerAdapter"></a>处理器Handler类型及与之对应的HandlerAdapter</h1><img src="/2021/09/08/spring/HandlerAdapter/HandlerAdapterClassH.png" class="" title="HandlerAdapter结构图">

<h2 id="Handler类型"><a href="#Handler类型" class="headerlink" title="Handler类型"></a>Handler类型</h2><ol>
<li><p>Handler类型org.springframework.web.method.HandlerMethod对应AbstractHandlerMethodAdapter (RequestMappingHandlerAdapter)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractHandlerMethodAdapter</span> <span class="keyword">extends</span> <span class="title class_">WebContentGenerator</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span>, Ordered &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HandlerMethod &amp;&amp; supportsInternal((HandlerMethod) handler));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Handler类型 org.springframework.web.servlet.mvc.Controller 对应 SimpleControllerHandlerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Handler类型 org.springframework.web.servlet.function.HandlerFunction  对应 HandlerFunctionAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HandlerFunctionAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span>, Ordered &#123;</span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> handler <span class="keyword">instanceof</span> HandlerFunction;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest servletRequest,HttpServletResponse servletResponse,Object handler)</span> <span class="keyword">throws</span></span><br><span class="line">        Exception &#123;</span><br><span class="line">		HandlerFunction&lt;?&gt; handlerFunction = (HandlerFunction&lt;?&gt;) handler;</span><br><span class="line">		<span class="type">ServerRequest</span> <span class="variable">serverRequest</span> <span class="operator">=</span> getServerRequest(servletRequest);</span><br><span class="line">		<span class="type">ServerResponse</span> <span class="variable">serverResponse</span> <span class="operator">=</span> handlerFunction.handle(serverRequest);</span><br><span class="line">		<span class="keyword">return</span> serverResponse.writeTo(servletRequest, servletResponse,<span class="keyword">new</span> <span class="title class_">ServerRequestContext</span>(serverRequest));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>子类</p>
<ul>
<li>ResourceHandlerFunction，资源文件处理器</li>
</ul>
</li>
<li><p>Handler类型 javax.servlet.Servlet.Servlet  对应 SimpleServletHandlerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleServletHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Servlet);</span><br><span class="line">	&#125;  </span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		((Servlet) handler).service(request, response);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Handler类型 org.springframework.web.servlet.mvc.HttpRequestHandler 对应 HttpRequestHandlerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRequestHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpRequestHandler);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		((HttpRequestHandler) handler).handleRequest(request, response);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  子类</p>
<ul>
<li><p>ResourceHttpRequestHandler</p>
</li>
<li><p>DefaultServletHttpRequestHandler </p>
</li>
<li><p>HttpInvokerServiceExporter </p>
</li>
<li><p>HessianServiceExporter</p>
</li>
</ul>
</li>
</ol>
<h1 id="AbstractHandlerMethodAdapter如何执行"><a href="#AbstractHandlerMethodAdapter如何执行" class="headerlink" title="AbstractHandlerMethodAdapter如何执行"></a>AbstractHandlerMethodAdapter如何执行</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">handleInternal</span><span class="params">(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span></span><br><span class="line">Exception &#123;</span><br><span class="line">		ModelAndView mav;</span><br><span class="line">		checkRequest(request);</span><br><span class="line">		mav = invokeHandlerMethod(request, response, handlerMethod);</span><br><span class="line">		<span class="keyword">return</span> mav;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">invokeHandlerMethod</span><span class="params">(HttpServletRequest request,HttpServletResponse response, HandlerMethod handlerMethod)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">ServletWebRequest</span> <span class="variable">webRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletWebRequest</span>(request, response);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">WebDataBinderFactory</span> <span class="variable">binderFactory</span> <span class="operator">=</span> getDataBinderFactory(handlerMethod);</span><br><span class="line">			<span class="type">ModelFactory</span> <span class="variable">modelFactory</span> <span class="operator">=</span> getModelFactory(handlerMethod, binderFactory);</span><br><span class="line"></span><br><span class="line">			<span class="type">ServletInvocableHandlerMethod</span> <span class="variable">invocableMethod</span> <span class="operator">=</span> createInvocableHandlerMethod(handlerMethod);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.argumentResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">				invocableMethod.setHandlerMethodArgumentResolvers(<span class="built_in">this</span>.argumentResolvers);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.returnValueHandlers != <span class="literal">null</span>) &#123;</span><br><span class="line">				invocableMethod.setHandlerMethodReturnValueHandlers(<span class="built_in">this</span>.returnValueHandlers);</span><br><span class="line">			&#125;</span><br><span class="line">			invocableMethod.setDataBinderFactory(binderFactory);</span><br><span class="line">			invocableMethod.setParameterNameDiscoverer(<span class="built_in">this</span>.parameterNameDiscoverer);</span><br><span class="line"></span><br><span class="line">			<span class="type">ModelAndViewContainer</span> <span class="variable">mavContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndViewContainer</span>();</span><br><span class="line">			mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));</span><br><span class="line">			modelFactory.initModel(webRequest, mavContainer, invocableMethod);</span><br><span class="line">			mavContainer.setIgnoreDefaultModelOnRedirect(<span class="built_in">this</span>.ignoreDefaultModelOnRedirect);</span><br><span class="line"></span><br><span class="line">			invocableMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line">			<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> getModelAndView(mavContainer, modelFactory, webRequest);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			webRequest.requestCompleted();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="HandlerMethodArgumentResolver"><a href="#HandlerMethodArgumentResolver" class="headerlink" title="HandlerMethodArgumentResolver"></a>HandlerMethodArgumentResolver</h2><p>对HandlerMethod对应方法中的参数进行逐个的解析，并赋值</p>
<h2 id="HandlerMethodReturnValueHandler"><a href="#HandlerMethodReturnValueHandler" class="headerlink" title="HandlerMethodReturnValueHandler"></a>HandlerMethodReturnValueHandler</h2><p>对返回的结果进行处理</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>全局异常处理器HandlerExceptionResolver</title>
    <url>/2021/09/19/spring/HandlerExceptionResolver/</url>
    <content><![CDATA[<p>处理器异常解析器，是 DispatcherServlet 在请求转发<strong>处理过程中出现异常</strong>（请求映射处理器，处理链，处理适配器，处理器执行）的时候对异常进行处理的最后一步，，<strong>如果抛出的异常没有被处理器异常解析器HandlerExceptionResolver</strong>处理并且解析成<strong>ModelAndView</strong>，那么异常 将被抛出并交给上层容器来处理，如：我们在容器中配置的错误码映射视图</p>
<span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 根据状态码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>500<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">location</span>&gt;</span>/500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 根据异常类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">exception-type</span>&gt;</span>java.lang.RuntimeException<span class="tag">&lt;/<span class="name">exception-type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">location</span>&gt;</span>/500.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>/index<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="SpringMvc异常处理方式"><a href="#SpringMvc异常处理方式" class="headerlink" title="SpringMvc异常处理方式"></a>SpringMvc异常处理方式</h1><ol>
<li><p>handler内部捕获处理，不往上层程序抛异常，单独处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;testExp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">testExp</span><span class="params">()</span><span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>@ExceptionHandler注解方式。注解方式也有两种用法： </p>
<ul>
<li>使用在<code>Controller</code>内部 ，可以在Controller<strong>局部</strong>异常统一处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HalloWordController</span> &#123;</span><br><span class="line">  <span class="comment">//可以对HalloWordController 内部所有映射的处理器进行异常捕获，他只处理HalloWordController内部抛出的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handlerException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置<code>@ControllerAdvice</code>一起使用实现<strong>全局</strong>处理,或者<strong>部分区域</strong>异常处理，<strong>取决于扫描包</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice(basePackages=&#123;&quot;com.cx.user.controller&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HalloWordController</span> &#123;</span><br><span class="line">    <span class="comment">//可以对com.cx.user.controller包 内部所有映射的处理器进行异常捕获，他只处理HalloWordController内部抛出的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">handlerException</span><span class="params">(Exception e)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>实现视图与异常进行映射处理SimpleMappingExceptionResolver</p>
</li>
<li><p>实现<code>HandlerExceptionResolver</code>方式实现<strong>全局</strong>处理</p>
</li>
</ol>
<h1 id="全局异常处理器HandlerExceptionResolver"><a href="#全局异常处理器HandlerExceptionResolver" class="headerlink" title="全局异常处理器HandlerExceptionResolver"></a>全局异常处理器HandlerExceptionResolver</h1><ol>
<li><p>doDispatch请求处理程序抛出异常，包含了整个请求处理边界</p>
</li>
<li><p>非ModelAndViewDefiningException异常的所有可捕获异常都将交给全局异常处理器里处理</p>
</li>
<li><p>异常处理器<strong>集合</strong>返回view，并将view渲染给用户,如果所有的异常处理器都未给出要渲染的view，那MVC框架将不再处理这个异常，那这个异常将抛出到上层容器来处理。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="type">Exception</span> <span class="variable">dispatchException</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//请求处理器映射</span></span><br><span class="line">          <span class="comment">//处理链构造</span></span><br><span class="line">          <span class="comment">//处理链前置执行</span></span><br><span class="line">          <span class="comment">//执行handler</span></span><br><span class="line">          mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">          <span class="comment">//处理链后置执行</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">         dispatchException = ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">         dispatchException = <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler dispatch failed&quot;</span>, err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//这里对整个的处理记过进行处理,如果MVC内部处理流程出现异常，那么将在processDispatchResult 来处理</span></span><br><span class="line">      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">      triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">NestedServletException</span>(<span class="string">&quot;Handler processing failed&quot;</span>, err));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理转发结果，异常解析，视图渲染</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> HandlerExecutionChain mappedHandler, <span class="meta">@Nullable</span> ModelAndView mv,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> Exception exception)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">boolean</span> <span class="variable">errorView</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果抛出异常将在这里处理</span></span><br><span class="line">   <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</span><br><span class="line">         mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> (mappedHandler != <span class="literal">null</span> ? mappedHandler.getHandler() : <span class="literal">null</span>);</span><br><span class="line">          <span class="comment">//异常处理并解析成对应的view，如果handler没有返回mv，执行的过程中抛出了异常，那么这里的异常处理器必须返回view，</span></span><br><span class="line">          <span class="comment">//如果不返回，异常将抛到上层容器，此处返回错误异常界面，后续程序将对异常界面进行渲染</span></span><br><span class="line">         mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">         errorView = (mv != <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mv != <span class="literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">      render(mv, request, response);</span><br><span class="line">      <span class="keyword">if</span> (errorView) &#123;</span><br><span class="line">         WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> ModelAndView <span class="title function_">processHandlerException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">      <span class="meta">@Nullable</span> Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">ModelAndView</span> <span class="variable">exMv</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.handlerExceptionResolvers != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">//遍历处理异常解析器，并进行处理，直到有一个返回了view</span></span><br><span class="line">      <span class="keyword">for</span> (HandlerExceptionResolver resolver : <span class="built_in">this</span>.handlerExceptionResolvers) &#123;</span><br><span class="line">         exMv = resolver.resolveException(request, response, handler, ex);</span><br><span class="line">         <span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (exMv != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">//返回view</span></span><br><span class="line">      <span class="keyword">return</span> exMv;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//抛出异常,</span></span><br><span class="line">   <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="常用实现以及如何探测"><a href="#常用实现以及如何探测" class="headerlink" title="常用实现以及如何探测"></a>常用实现以及如何探测</h1><img src="/2021/09/19/spring/HandlerExceptionResolver/3F1EF206-8765-4d0d-8B39-B09305F9A347.png" class="" title="ExceptionResolver结构图">

<ul>
<li><p>SimpleMappingExceptionResolver</p>
<p>​    根据异常类和视图之间的映射配置来判断是否处理异常，匹配成功就返回对应的视图和对应的响应吗</p>
</li>
<li><p>ExceptionHandlerExceptionResolver</p>
<p>​    对处理器是HandlerMethod类型处理器异常进行处理，只处理一下两种情况</p>
<p>​          1. 处理器内部有@ExceptionHandler注解异常处理器，支持处理器内部区域异常处理</p>
<p>​          2. @ControllerAdvice支持全局或者部分区域（包扫描）内@ExceptionHandler注解异常处理器</p>
</li>
<li><p>DefaultHandlerExceptionResolver</p>
<p>​    处理mvc框架内部异常的处理</p>
</li>
<li><p>ResponseStatusExceptionResolver</p>
<p>​    根据国际化资源对ResponseStatusException异常进行处理</p>
</li>
<li><p>DefaultErrorAttributes</p>
<p>​     异常存储处理器不返回任何错误视图</p>
</li>
</ul>
<h2 id="SpringBoot自动装配MVC中ExceptionResolver的装配"><a href="#SpringBoot自动装配MVC中ExceptionResolver的装配" class="headerlink" title="SpringBoot自动装配MVC中ExceptionResolver的装配"></a>SpringBoot自动装配MVC中ExceptionResolver的装配</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#异常处理自动装配</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<h3 id="装配DefaultErrorAttributes和BasicErrorController"><a href="#装配DefaultErrorAttributes和BasicErrorController" class="headerlink" title="装配DefaultErrorAttributes和BasicErrorController"></a>装配DefaultErrorAttributes和BasicErrorController</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//异常信息及解析器记录异常</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line"><span class="keyword">public</span> DefaultErrorAttributes <span class="title function_">errorAttributes</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultErrorAttributes</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)</span></span><br><span class="line"><span class="keyword">public</span> BasicErrorController <span class="title function_">basicErrorController</span><span class="params">(ErrorAttributes errorAttributes, ObjectProvider&lt;ErrorViewResolver&gt; errorViewResolvers)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BasicErrorController</span>(errorAttributes, <span class="built_in">this</span>.serverProperties.getError(),errorViewResolvers.orderedStream().collect(Collectors.toList()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="装配ExceptionHandlerExceptionResolver和ResponseStatusExceptionResolver"><a href="#装配ExceptionHandlerExceptionResolver和ResponseStatusExceptionResolver" class="headerlink" title="装配ExceptionHandlerExceptionResolver和ResponseStatusExceptionResolver"></a>装配ExceptionHandlerExceptionResolver和ResponseStatusExceptionResolver</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WebMvcAutoConfiguration -&gt;EnableWebMvcConfiguration -&gt;DelegatingWebMvcConfiguration -&gt;WebMvcConfigurationSupport</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">addDefaultHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; exceptionResolvers,</span></span><br><span class="line"><span class="params">      ContentNegotiationManager mvcContentNegotiationManager)</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="type">ExceptionHandlerExceptionResolver</span> <span class="variable">exceptionHandlerResolver</span> <span class="operator">=</span> createExceptionHandlerExceptionResolver();</span><br><span class="line">   exceptionHandlerResolver.setContentNegotiationManager(mvcContentNegotiationManager);</span><br><span class="line">   exceptionHandlerResolver.setMessageConverters(getMessageConverters());</span><br><span class="line">   exceptionHandlerResolver.setCustomArgumentResolvers(getArgumentResolvers());</span><br><span class="line">   exceptionHandlerResolver.setCustomReturnValueHandlers(getReturnValueHandlers());</span><br><span class="line">   <span class="keyword">if</span> (jackson2Present) &#123;</span><br><span class="line">      exceptionHandlerResolver.setResponseBodyAdvice(</span><br><span class="line">            Collections.singletonList(<span class="keyword">new</span> <span class="title class_">JsonViewResponseBodyAdvice</span>()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">this</span>.applicationContext != <span class="literal">null</span>) &#123;</span><br><span class="line">      exceptionHandlerResolver.setApplicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">   &#125;</span><br><span class="line">   exceptionHandlerResolver.afterPropertiesSet();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册ExceptionHandlerExceptionResolver，</span></span><br><span class="line">    <span class="comment">//处理@ExceptionHandler注解的内部异常处理器</span></span><br><span class="line">    <span class="comment">//@ControllerAdvice内@ExceptionHandler注解的异常处理器，支持全局或者部分区域内部（包扫描）异常处理，</span></span><br><span class="line">   exceptionResolvers.add(exceptionHandlerResolver);</span><br><span class="line"></span><br><span class="line">   <span class="type">ResponseStatusExceptionResolver</span> <span class="variable">responseStatusResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ResponseStatusExceptionResolver</span>();</span><br><span class="line">   responseStatusResolver.setMessageSource(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">   exceptionResolvers.add(responseStatusResolver);</span><br><span class="line">   <span class="comment">//注册ResponseStatusExceptionResolver</span></span><br><span class="line">   exceptionResolvers.add(<span class="keyword">new</span> <span class="title class_">DefaultHandlerExceptionResolver</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="自定义全区异常处理器"><a href="#自定义全区异常处理器" class="headerlink" title="自定义全区异常处理器"></a>自定义全区异常处理器</h1><h3 id="SimpleMappingExceptionResolver映射异常处理器"><a href="#SimpleMappingExceptionResolver映射异常处理器" class="headerlink" title="SimpleMappingExceptionResolver映射异常处理器"></a>SimpleMappingExceptionResolver映射异常处理器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(Integer.MAX_VALUE)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> , InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties exceptionMappings;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties statusCodes;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载映射配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        exceptionMappings = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        statusCodes = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        exceptionMappings.load(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;exceptionMappings.properties&quot;</span>).getInputStream());</span><br><span class="line">        statusCodes.load(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">&quot;statusCodes.properties&quot;</span>).getInputStream());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configureHandlerExceptionResolvers</span><span class="params">(List&lt;HandlerExceptionResolver&gt; resolvers)</span> &#123;</span><br><span class="line">        <span class="type">SimpleMappingExceptionResolver</span> <span class="variable">simpleMappingExceptionResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleMappingExceptionResolver</span>();</span><br><span class="line">        simpleMappingExceptionResolver.setExceptionMappings(exceptionMappings);</span><br><span class="line">        simpleMappingExceptionResolver.setStatusCodes(statusCodes);</span><br><span class="line">        simpleMappingExceptionResolver.setDefaultErrorView(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">        simpleMappingExceptionResolver.setDefaultStatusCode(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);</span><br><span class="line">        resolvers.add(simpleMappingExceptionResolver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异常视图映射配置：exceptionMappings.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">异常对应视图</span></span><br><span class="line"><span class="attr">java.lang.Exception</span>=<span class="string">500</span></span><br></pre></td></tr></table></figure>

<p>视图响应码配置：statusCodes.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#视图对应响应码</span></span><br><span class="line"><span class="attr">500</span>=<span class="string">500</span></span><br></pre></td></tr></table></figure>

<img src="/2021/09/19/spring/HandlerExceptionResolver/DE0925E8-7B94-40e2-8E5B-78EF1C311FBF.png" class="" title="500视图">

<h3 id="自定义实现HandlerExceptionResolver异常处理"><a href="#自定义实现HandlerExceptionResolver异常处理" class="headerlink" title="自定义实现HandlerExceptionResolver异常处理"></a>自定义实现HandlerExceptionResolver异常处理</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GobalExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span><br><span class="line"><span class="params">                                     Object handler,Exception ex)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;服务暂停&quot;</span>;</span><br><span class="line">        <span class="comment">//如果是HandlerMethod，那么检查是否是返回ResponseBody，确定是返回界面还是json数据</span></span><br><span class="line">        <span class="keyword">if</span>(ex!=<span class="literal">null</span> &amp;&amp; handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</span><br><span class="line">            <span class="type">HandlerMethod</span> <span class="variable">hdlm</span> <span class="operator">=</span>  (HandlerMethod)handler;</span><br><span class="line">            <span class="type">ResponseBody</span> <span class="variable">have_rb</span> <span class="operator">=</span> AnnotationUtils.findAnnotation(hdlm.getBeanType(),ResponseBody.class);</span><br><span class="line">            <span class="comment">//返回json视图</span></span><br><span class="line">            <span class="keyword">if</span>(hdlm.hasMethodAnnotation(ResponseBody.class) || have_rb!=<span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="type">ModelAndView</span> <span class="variable">mv</span> <span class="operator">=</span>   <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">                <span class="type">MappingJackson2JsonView</span> <span class="variable">mappingJackson2JsonView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappingJackson2JsonView</span>();</span><br><span class="line">                mv.setView(mappingJackson2JsonView);</span><br><span class="line">                mv.addObject(<span class="string">&quot;msg&quot;</span>,msg);</span><br><span class="line">                <span class="keyword">return</span> mv;</span><br><span class="line">           <span class="comment">//返回view视图 html     </span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回模式视图</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>(<span class="string">&quot;error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringWebMvc-HandlerMapping</title>
    <url>/2021/09/08/spring/HandlerMapping/</url>
    <content><![CDATA[<p>   HandlerMapping 将请求映射到具体的处理程序（如HandlerMethod Controller HandlerFunction Servlet HttpRequestHandler等），并缓存映射关系，当请求进入DispatcherServlet后，DispatcherServlet 遍历 注册 HandlerMapping 根据请求情况获取HandlerExecutionChain，HandlerExecutionChain中包含了具体的处理程序和拦截器列表<strong>，后续的执行中就直接使用了HandlerExecutionChain来处理，</strong>此时HandlerMapping  就完成了任务，就是构建HandlerExecutionChain。</p>
<span id="more"></span>

<p>   请求是通过DispatcherServlet 来进行统一处理的，那么DispatcherServlet  是如何探测到HandlerMapping的呢，我们如何才能注册自己的HandlerMapping呢</p>
<p>   HandlerMapping 只定义了根据请求获取处理链的接口方法，那么HandlerMapping 主要目的就是构建处理链，提供具体的处理器和拦截器链，那么拦截器是如何注册，处理器是如何注册的，并且是如何通过url匹配到拦截器和处理器，并封装成HandlerExecutionChain 就是HandlerMapping 要做的事</p>
<p>   SprignMvc中能够处理请求的处理器有很多，那么都有哪些可用的线程的处理器呢，如果不使用现有的处理器类型，如何实现自己的处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerMapping</span> &#123;</span><br><span class="line">	HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HandlerMapping探测"><a href="#HandlerMapping探测" class="headerlink" title="HandlerMapping探测"></a>HandlerMapping探测</h1><p>DispatcherServlet 继承自FrameworkServlet ，并且实现了onRefresh 监听WebApplicationContext刷新方法，完成MVC各个处理节点处理策略的初始化，其中HandlerMapping就是其中之一，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onRefresh</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">		initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initStrategies</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体探测步骤是</p>
<ol>
<li>根据detectAllHandlerMappings（是否探测所有的HandlerMapping）属性 true 完成 从bean容器中获取所有的HandlerMapping</li>
<li>根据detectAllHandlerMappings（是否探测所有的HandlerMapping）属性 false 完成 从bean容器中获取beanName 为handlerMapping 类型为HandlerMapping</li>
<li>如果都没有，就从默认DispatcherServlet.properties 配置中获取，spring-webmvc 包下配置了默认的策略规则HandlerMapping的默认策略规则为</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.web.servlet.HandlerMapping</span>=<span class="string">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span></span><br><span class="line"><span class="string">   org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\</span></span><br><span class="line"><span class="string">   org.springframework.web.servlet.function.support.RouterFunctionMapping</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.handlerMappings = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.detectAllHandlerMappings)</span><br><span class="line"><span class="comment">//探测所有的HandlerMapping</span></span><br><span class="line">			Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">					BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">			<span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">				<span class="built_in">this</span>.handlerMappings = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(matchingBeans.values());</span><br><span class="line"><span class="comment">//执行order排序</span></span><br><span class="line">				AnnotationAwareOrderComparator.sort(<span class="built_in">this</span>.handlerMappings);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">HandlerMapping</span> <span class="variable">hm</span> <span class="operator">=</span> context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line">				<span class="built_in">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.handlerMappings == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//默认策略配置</span></span><br><span class="line">			<span class="built_in">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h1 id="HandlerInterceptor-探测"><a href="#HandlerInterceptor-探测" class="headerlink" title="HandlerInterceptor 探测"></a>HandlerInterceptor 探测</h1><img src="/2021/09/08/spring/HandlerMapping/HandlerMappingClassH.png" class="" title="HandlerMapping结构图">

<h2 id="HandlerMapping顶级实现类AbstractHandlerMapping"><a href="#HandlerMapping顶级实现类AbstractHandlerMapping" class="headerlink" title="HandlerMapping顶级实现类AbstractHandlerMapping"></a>HandlerMapping顶级实现类AbstractHandlerMapping</h2><p>AbstractHandlerMapping是HandlerMapping的顶级实现类，所有的子类都直接或者间接的继承自这个类，AbstractHandlerMapping因为继承自WebApplicationObjectSupport抽象类，那么他就有了ServletContext （ServletContextAware setServletContext 接口方法）感知能力和ApplicationContext感知能力（initApplicationContext方法），<strong>那么HandlerInterceptor 就是在AbstractHandlerMapping的initApplicationContext中直接从bean容器中检测HandlerInterceptor  类型的</strong> 获取的类型为（**<u>MappedInterceptor</u>**）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SkipPathExtensionContentNegotiation</span></span><br><span class="line">	extendInterceptors(<span class="built_in">this</span>.interceptors);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//检测容器中的HandlerMapping 并缓存</span></span><br><span class="line">	detectMappedInterceptors(<span class="built_in">this</span>.adaptedInterceptors);</span><br><span class="line">	</span><br><span class="line"><span class="comment">//合并extendInterceptors和detectMappedInterceptors 到adaptedInterceptors 中进行缓存</span></span><br><span class="line">	initInterceptors();</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检测容器中的HandlerMapping</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectMappedInterceptors</span><span class="params">(List&lt;HandlerInterceptor&gt; mappedInterceptors)</span> &#123;</span><br><span class="line">	mappedInterceptors.addAll(BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), 																					MappedInterceptor.class,<span class="literal">true</span>, <span class="literal">false</span>).values());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>MappedInterceptor</strong> 内部缓存了匹配资源和排除匹配资源，并且支持提供匹配函数来对请求的资源进行匹配判断，支持针对不同的资源进行不同的拦截，通常情况下我们使用的就是这种匹配型拦截器，定义HandlerInterceptor   并把它放入MappedInterceptor，并配置MappedInterceptor的匹配属性，进行使用。</p>
<p>匹配型拦截器：includePatterns ，excludePatterns interceptor，</p>
<p>非匹配性拦截器： interceptor</p>
<p>构建HandlerExecutionChain: 来收集请求对应的拦截器，如果是匹配型的就进行请求匹配，否自直接添加到处理链中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> &#123;</span><br><span class="line">   <span class="type">HandlerExecutionChain</span> <span class="variable">chain</span> <span class="operator">=</span> (handler <span class="keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">         (HandlerExecutionChain) handler : <span class="keyword">new</span> <span class="title class_">HandlerExecutionChain</span>(handler));</span><br><span class="line">   <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> <span class="built_in">this</span>.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH);</span><br><span class="line">   <span class="keyword">for</span> (HandlerInterceptor interceptor : <span class="built_in">this</span>.adaptedInterceptors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">         <span class="type">MappedInterceptor</span> <span class="variable">mappedInterceptor</span> <span class="operator">=</span> (MappedInterceptor) interceptor;</span><br><span class="line">          <span class="comment">//如果是匹配型就先匹配</span></span><br><span class="line">         <span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="built_in">this</span>.pathMatcher)) &#123;</span><br><span class="line">            chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//否自直接加入到处理器链</span></span><br><span class="line">         chain.addInterceptor(interceptor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>向容器中注册拦截器 xml方式：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--匹配性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/ag/*&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.ryx.credit.cms.intercept.AgentConfirmInterceptor&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--非匹配型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;localeChangeInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>WebMvcConfigurer 方式：</li>
</ul>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">     <span class="comment">//添加注册器 InterceptorRegistration</span></span><br><span class="line">     registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">HandlerInterceptor</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception &#123; <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br><span class="line"> </span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line"> </span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception &#123;&#125;</span><br><span class="line">     &#125;)    </span><br><span class="line">     .addPathPatterns(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">     .excludePathPatterns(<span class="string">&quot;/a&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InterceptorRegistration</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//如果未添加匹配路劲也未添加排除匹配就默认为非匹配型拦截器</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.includePatterns.isEmpty() &amp;&amp; <span class="built_in">this</span>.excludePatterns.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] include = StringUtils.toStringArray(<span class="built_in">this</span>.includePatterns);</span><br><span class="line">    String[] exclude = StringUtils.toStringArray(<span class="built_in">this</span>.excludePatterns);</span><br><span class="line">    <span class="type">MappedInterceptor</span> <span class="variable">mappedInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MappedInterceptor</span>(include, exclude, <span class="built_in">this</span>.interceptor);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.pathMatcher != <span class="literal">null</span>) &#123;</span><br><span class="line">        mappedInterceptor.setPathMatcher(<span class="built_in">this</span>.pathMatcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mappedInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="请求映射到具体的处理程序关系初始化"><a href="#请求映射到具体的处理程序关系初始化" class="headerlink" title="请求映射到具体的处理程序关系初始化"></a>请求映射到具体的处理程序关系初始化</h1><h2 id="如何注册请求处理器"><a href="#如何注册请求处理器" class="headerlink" title="如何注册请求处理器"></a>如何注册请求处理器</h2><ul>
<li>被@Controller或者@RequestMapping 注解标注的容器Bean的内部 被@RequestMapping注解标注方法 并构建成<u>HandlerMethod</u>（class,method）</li>
<li>以”/“开头的或者别名是以”/“开头的容器内的任意Bean (<u>Controller HandlerFunction Servlet HttpRequestHandler</u>)</li>
</ul>
<h2 id="AbstractHandlerMapping-有两个子类AbstractUrlHandlerMapping-和-AbstractHandlerMethodMapping"><a href="#AbstractHandlerMapping-有两个子类AbstractUrlHandlerMapping-和-AbstractHandlerMethodMapping" class="headerlink" title="AbstractHandlerMapping 有两个子类AbstractUrlHandlerMapping 和 AbstractHandlerMethodMapping"></a>AbstractHandlerMapping 有两个子类AbstractUrlHandlerMapping 和 AbstractHandlerMethodMapping</h2><ul>
<li><p>其中AbstractUrlHandlerMapping  维护了 <strong>Map&lt;String, Object&gt; handlerMap</strong> 映射关系并提供注册映射关系的方法，具体的注册逻辑交给了子类来处理，</p>
<p>子类的注册时机是在AbstractHandlerMapping 中的 已实现了的initApplicationContext 中，子类中调用父类的initApplicationContext 后初始化映射</p>
</li>
<li><p>其中AbstractHandlerMethodMapping 维护了 <strong>MappingRegistry mappingRegistry</strong> 映射关系并提供注册映射关系的方法，并实现了注册逻辑的模板反方，并预留了是否需要注册的接口留给了子类去实现</p>
</li>
</ul>
<p>AbstractHandlerMethodMapping 注册的模板方法 是在InitializingBean   afterPropertiesSet() 接口方法中实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line">	initHandlerMethods();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initHandlerMethods</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//获取容器中候选的beanName</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : getCandidateBeanNames()) &#123;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//排除scopedTarget.</span></span><br><span class="line">        <span class="keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;     </span><br><span class="line">			<span class="comment">//注册        </span></span><br><span class="line">        	processCandidateBean(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processCandidateBean</span><span class="params">(String beanName)</span> &#123;</span><br><span class="line"></span><br><span class="line"> 	Class&lt;?&gt; beanType = beanType = obtainApplicationContext().getType(beanName);  </span><br><span class="line">    </span><br><span class="line">	<span class="comment">//isHandler 交给了子类去实现</span></span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="literal">null</span> &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//探测bean内部那些方法是handler,</span></span><br><span class="line">     detectHandlerMethods(beanName);</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="AbstractHandlerMethodMapping子类RequestMappingHandlerMapping"><a href="#AbstractHandlerMethodMapping子类RequestMappingHandlerMapping" class="headerlink" title="AbstractHandlerMethodMapping子类RequestMappingHandlerMapping"></a>AbstractHandlerMethodMapping子类RequestMappingHandlerMapping</h2><ul>
<li>RequestMappingHandlerMapping映射那些被 Controller 或者RequestMapping 注解的类 ,并交由AbstractHandlerMethodMapping  来解析这些类下的方法为handler，并注册到 mappingRegistry</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHandler</span><span class="params">(Class&lt;?&gt; beanType)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||</span><br><span class="line">         AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>并且解析Method  RequestMappingInfo</li>
</ul>
<h2 id="AbstractUrlHandlerMapping"><a href="#AbstractUrlHandlerMapping" class="headerlink" title="AbstractUrlHandlerMapping"></a>AbstractUrlHandlerMapping</h2><p>AbstractUrlHandlerMapping   缓存了映射关系并提供了请求与处理器注册的方法registerHandler ，并且注册处理器过程中设置ROOThandler 和默认的 defaultHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">	setRootHandler(resolvedHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (urlPath.equals(<span class="string">&quot;/*&quot;</span>)) &#123;</span><br><span class="line">	setDefaultHandler(resolvedHandler);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.handlerMap.put(urlPath, resolvedHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="AbstractUrlHandlerMapping-子类AbstractDetectingUrlHandlerMapping"><a href="#AbstractUrlHandlerMapping-子类AbstractDetectingUrlHandlerMapping" class="headerlink" title="AbstractUrlHandlerMapping  子类AbstractDetectingUrlHandlerMapping"></a>AbstractUrlHandlerMapping  子类AbstractDetectingUrlHandlerMapping</h3><p>AbstractDetectingUrlHandlerMapping 在探测处理器过程中，定义了探测的源也就是容器内的bean，并预留了抽象方法 String[] determineUrlsForHandler(String beanName) 来确定bean名称是否可作为handler   ,</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initApplicationContext</span><span class="params">()</span> <span class="keyword">throws</span> ApplicationContextException &#123;</span><br><span class="line">		<span class="built_in">super</span>.initApplicationContext();</span><br><span class="line">		detectHandlers();</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">detectHandlers</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> obtainApplicationContext();</span><br><span class="line">    String[] beanNames = (<span class="built_in">this</span>.detectHandlersInAncestorContexts ?</span><br><span class="line">    BeanFactoryUtils.beanNamesForTypeIncludingAncestors(applicationContext, Object.class) :</span><br><span class="line">    applicationContext.getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/*********determineUrlsForHandler 方法为抽象方法，子类觉得bean的是否可以作为Handler来注册******/</span></span><br><span class="line">        String[] urls = determineUrlsForHandler(beanName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(urls)) &#123;</span><br><span class="line">        registerHandler(urls, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有一个默认的实现类 BeanNameUrlHandlerMapping，BeanNameUrlHandlerMapping 的 方法定义了那些bean的名字可以被注册映射关系，那些以 “/”  开始 或者别名以 ‘/“ 开始的都可以注册为一个请求和处理的映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> String[] determineUrlsForHandler(String beanName) &#123;</span><br><span class="line">		List&lt;String&gt; urls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">if</span> (beanName.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">			urls.add(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		String[] aliases = obtainApplicationContext().getAliases(beanName);</span><br><span class="line">		<span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">			<span class="keyword">if</span> (alias.startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">				urls.add(alias);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> StringUtils.toStringArray(urls);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractUrlHandlerMapping-子类SimpleUrlHandlerMapping"><a href="#AbstractUrlHandlerMapping-子类SimpleUrlHandlerMapping" class="headerlink" title="AbstractUrlHandlerMapping  子类SimpleUrlHandlerMapping"></a>AbstractUrlHandlerMapping  子类SimpleUrlHandlerMapping</h3><p>SimpleUrlHandlerMapping 维护这一个url与处理器的映射关系  Map&lt;String, Object&gt; urlMap</p>
<p>我们常用的ResourceHandler 就采用了这个HandlerMapping，其中handler 采用的是HttpRequestHandler   , ResourceHandlerRegistry内部分代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> AbstractHandlerMapping <span class="title function_">getHandlerMapping</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.registrations.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;String, HttpRequestHandler&gt; urlMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (ResourceHandlerRegistration registration : <span class="built_in">this</span>.registrations) &#123;</span><br><span class="line">			<span class="keyword">for</span> (String pathPattern : registration.getPathPatterns()) &#123;</span><br><span class="line">				<span class="type">ResourceHttpRequestHandler</span> <span class="variable">handler</span> <span class="operator">=</span> registration.getRequestHandler();</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">this</span>.pathHelper != <span class="literal">null</span>) &#123;</span><br><span class="line">					handler.setUrlPathHelper(<span class="built_in">this</span>.pathHelper);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">this</span>.contentNegotiationManager != <span class="literal">null</span>) &#123;</span><br><span class="line">					handler.setContentNegotiationManager(<span class="built_in">this</span>.contentNegotiationManager);</span><br><span class="line">				&#125;</span><br><span class="line">				handler.setServletContext(<span class="built_in">this</span>.servletContext);</span><br><span class="line">				handler.setApplicationContext(<span class="built_in">this</span>.applicationContext);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					handler.afterPropertiesSet();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanInitializationException</span>(<span class="string">&quot;Failed to init ResourceHttpRequestHandler&quot;</span>, ex);</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">//将资源映射到处理器</span></span><br><span class="line">				urlMap.put(pathPattern, handler);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//构建资源映射处理器</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleUrlHandlerMapping</span>(urlMap, <span class="built_in">this</span>.order);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h3 id="AbstractUrlHandlerMapping-子类WelcomePageHandlerMapping"><a href="#AbstractUrlHandlerMapping-子类WelcomePageHandlerMapping" class="headerlink" title="AbstractUrlHandlerMapping  子类WelcomePageHandlerMapping"></a>AbstractUrlHandlerMapping  子类WelcomePageHandlerMapping</h3><p>WelcomePageHandlerMapping 未做任何映射，只是设置了AbstractUrlHandlerMapping   “/“   RootHandler </p>
<h3 id="Handler处理程序"><a href="#Handler处理程序" class="headerlink" title="Handler处理程序"></a>Handler处理程序</h3><ol>
<li><p>Controller </p>
<p>执行适配程序 SimpleControllerHandlerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Controller</span> &#123;</span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   ModelAndView <span class="title function_">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleControllerHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Controller);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="comment">//返回试图</span></span><br><span class="line">		<span class="keyword">return</span> ((Controller) handler).handleRequest(request, response);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>HandlerFunction (Flux)</p>
<p>执行适配程序 HandlerFunctionAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HandlerFunction</span>&lt;T <span class="keyword">extends</span> <span class="title class_">ServerResponse</span>&gt; &#123;</span><br><span class="line">   T <span class="title function_">handle</span><span class="params">(ServerRequest request)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Servlet </p>
<p>执行适配程序SimpleServletHandlerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleServletHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> Servlet);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">         <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//未返回试图</span></span><br><span class="line">      ((Servlet) handler).service(request, response);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>HttpRequestHandler</p>
<p>执行适配程序 HttpRequestHandlerAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpRequestHandlerAdapter</span> <span class="keyword">implements</span> <span class="title class_">HandlerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">supports</span><span class="params">(Object handler)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (handler <span class="keyword">instanceof</span> HttpRequestHandler);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Nullable</span></span><br><span class="line">   <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line">         <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">//未返回试图</span></span><br><span class="line">      ((HttpRequestHandler) handler).handleRequest(request, response);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>HandlerMethod</p>
</li>
</ol>
<h1 id="HandlerMapping接口方法getHandler"><a href="#HandlerMapping接口方法getHandler" class="headerlink" title="HandlerMapping接口方法getHandler"></a>HandlerMapping接口方法getHandler</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> HandlerExecutionChain <span class="title function_">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="comment">//子类实现方法-通过缓存的映射关系，获取具体的处理器 Handler</span></span><br><span class="line">   <span class="type">Object</span> <span class="variable">handler</span> <span class="operator">=</span> getHandlerInternal(request);</span><br><span class="line">   <span class="comment">//获取默认的处理器</span></span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      handler = getDefaultHandler();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//如果是String类型从容器中获取bean</span></span><br><span class="line">   <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">handlerName</span> <span class="operator">=</span> (String) handler;</span><br><span class="line">      handler = obtainApplicationContext().getBean(handlerName);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/******构建HandlerExecutionChain,放入处理器，并根据请求url，匹配填充MappedInterceptor 列表******/</span></span><br><span class="line">   <span class="type">HandlerExecutionChain</span> <span class="variable">executionChain</span> <span class="operator">=</span> getHandlerExecutionChain(handler, request);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) &#123;</span><br><span class="line">      <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> (<span class="built_in">this</span>.corsConfigurationSource != <span class="literal">null</span> ? <span class="built_in">this</span>.corsConfigurationSource.getCorsConfiguration(request) : <span class="literal">null</span>);</span><br><span class="line">      <span class="type">CorsConfiguration</span> <span class="variable">handlerConfig</span> <span class="operator">=</span> getCorsConfiguration(handler, request);</span><br><span class="line">      config = (config != <span class="literal">null</span> ? config.combine(handlerConfig) : handlerConfig);</span><br><span class="line">      executionChain = getCorsHandlerExecutionChain(request, executionChain, config);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">/******返回处理器链，内部包含了Handelr 和 匹配的拦截器列表******/</span></span><br><span class="line">   <span class="keyword">return</span> executionChain;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> HandlerExecutionChain <span class="title function_">getHandlerExecutionChain</span><span class="params">(Object handler, HttpServletRequest request)</span> &#123;</span><br><span class="line">   <span class="type">HandlerExecutionChain</span> <span class="variable">chain</span> <span class="operator">=</span> (handler <span class="keyword">instanceof</span> HandlerExecutionChain ?</span><br><span class="line">         (HandlerExecutionChain) handler : <span class="keyword">new</span> <span class="title class_">HandlerExecutionChain</span>(handler));</span><br><span class="line"></span><br><span class="line">   <span class="type">String</span> <span class="variable">lookupPath</span> <span class="operator">=</span> <span class="built_in">this</span>.urlPathHelper.getLookupPathForRequest(request, LOOKUP_PATH);</span><br><span class="line">   <span class="keyword">for</span> (HandlerInterceptor interceptor : <span class="built_in">this</span>.adaptedInterceptors) &#123;</span><br><span class="line">      <span class="keyword">if</span> (interceptor <span class="keyword">instanceof</span> MappedInterceptor) &#123;</span><br><span class="line">         <span class="type">MappedInterceptor</span> <span class="variable">mappedInterceptor</span> <span class="operator">=</span> (MappedInterceptor) interceptor;</span><br><span class="line">         <span class="comment">/******填充匹配的拦截器列表******/</span></span><br><span class="line">         <span class="keyword">if</span> (mappedInterceptor.matches(lookupPath, <span class="built_in">this</span>.pathMatcher)) &#123;</span><br><span class="line">            chain.addInterceptor(mappedInterceptor.getInterceptor());</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         chain.addInterceptor(interceptor);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>springmvc</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud负载均衡之客户端RestTemplate</title>
    <url>/2022/05/15/spring/RestTemplate/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-负载均衡框架描述"><a href="#Spring-Cloud-负载均衡框架描述" class="headerlink" title="Spring Cloud 负载均衡框架描述"></a>Spring Cloud 负载均衡框架描述</h1><p>服务的治理：</p>
<p>服务治理的参与方有 服务提供方，服务消费方，注册中心，服务提供方将自己作为服务提供者注册到注册中心，服务消费方从注册中心获取订阅的服务列表，注册中心完成服务的健康检查<br>服务停止注册中心就停止租约，服务启动重新在注册中心续租。</p>
<p>客服端服务端调用：</p>
<p>客户端服务调用是在客户端持有服务列表并与注册中心保持通信，并获取注册中心的服务对应主机列表，<em><strong>然后通过请求的过程中完成客户单请求的信息重写</strong></em>，完成负载均衡功能。</p>
<h1 id="客户端调用服务端模板工具-spring-web包-RestTemplate"><a href="#客户端调用服务端模板工具-spring-web包-RestTemplate" class="headerlink" title="客户端调用服务端模板工具 spring-web包 RestTemplate"></a>客户端调用服务端模板工具 spring-web包 RestTemplate</h1><p>RestTemplate 是同步调用HTTP请求的模板方法工具类，是通过底层HTTP客户端库实现，他定义了我们请求的通用过程，是一个模板工具。支持POST GET PUT等http请求方法。并提供了不同的结构类型。如 getForEntity 返回http请求结果对象，其中包含了响应的头，响应状态等请求相关数据 getForObject 返回指定的数据类型，既将结果转化为给定的对象。其底层都调用了模板方法 doExecute.<br>执行流程为（主要分析请求创建过程及请求处理过程）</p>
<ol>
<li>完成请求创建 主要分析请求创建过程</li>
<li>请求设置</li>
<li>请求执行</li>
<li>异常处理</li>
<li>响应结果提取</li>
</ol>
<img src="/2022/05/15/spring/RestTemplate/RestTemplate.png" class="" title="类图结构">

<ol>
<li>HttpAccessor http访问器 是RestTemplate 类机构中最顶层的类，内部成员及方法如下，其包含了基本的客户端请求工厂 并包含通用的请求初始化器，对所有请求有效, 其包含了创建请求的能力，并使用请求初始器对请求进行初始化。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HttpAccessor</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 创建Request工厂</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">ClientHttpRequestFactory</span> <span class="variable">requestFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleClientHttpRequestFactory</span>();</span><br><span class="line"><span class="comment">//对创建的请求进行初始化</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;ClientHttpRequestInitializer&gt; clientHttpRequestInitializers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	 <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过 请求url method 创建请求，内部受保护的方法，底层使用 ClientHttpRequestFactory 完成request的创建</span></span><br><span class="line">	<span class="keyword">protected</span> ClientHttpRequest <span class="title function_">createRequest</span><span class="params">(URI url, HttpMethod method)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取工厂并完成请求创建</span></span><br><span class="line">		<span class="type">ClientHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> getRequestFactory().createRequest(url, method);</span><br><span class="line">		initialize(request);</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;HTTP &quot;</span> + method.name() + <span class="string">&quot; &quot;</span> + url);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> request;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initialize</span><span class="params">(ClientHttpRequest request)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.clientHttpRequestInitializers.forEach(initializer -&gt; initializer.initialize(request));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>InterceptingHttpAccessor 继承http访问器HttpAccessor  并做了扩展，持有拦截器列表，并重写了 父类的getRequestFactory 方法，此类返回的是InterceptingClientHttpRequestFactory 工厂类，并内部持有父类的 SimpleClientHttpRequestFactory</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterceptingHttpAccessor</span> <span class="keyword">extends</span> <span class="title class_">HttpAccessor</span> &#123;</span><br><span class="line"><span class="comment">//拦截器列表</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;ClientHttpRequestInterceptor&gt; interceptors = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//拦截器工厂私有成员</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> ClientHttpRequestFactory interceptingRequestFactory;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> ClientHttpRequestFactory <span class="title function_">getRequestFactory</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="comment">//获取拦截器</span></span><br><span class="line">		List&lt;ClientHttpRequestInterceptor&gt; interceptors = getInterceptors();</span><br><span class="line">		<span class="keyword">if</span> (!CollectionUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">			<span class="type">ClientHttpRequestFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptingRequestFactory;</span><br><span class="line">			<span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//构建请求工厂，内部持有拦截器列表</span></span><br><span class="line">				factory = <span class="keyword">new</span> <span class="title class_">InterceptingClientHttpRequestFactory</span>(<span class="built_in">super</span>.getRequestFactory(), interceptors);</span><br><span class="line">				<span class="built_in">this</span>.interceptingRequestFactory = factory;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> factory;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">super</span>.getRequestFactory();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>RestTemplate 继承http访问器InterceptingHttpAccessor ，RestTemplate默认具有拦截器能力，创建请求的能力<em><strong>重写了父类的能力</strong></em>，初始化请求的能力，<br>自带 消息转换 messageConverters 异常处理 errorHandler 结果提取能力 headersExtractor。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplate</span> <span class="keyword">extends</span> <span class="title class_">InterceptingHttpAccessor</span> <span class="keyword">implements</span> <span class="title class_">RestOperations</span>&#123;</span><br><span class="line"><span class="comment">//消息转换器列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//异常处理器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">ResponseErrorHandler</span> <span class="variable">errorHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultResponseErrorHandler</span>();</span><br><span class="line"><span class="comment">//url处理模板</span></span><br><span class="line">	<span class="keyword">private</span> UriTemplateHandler uriTemplateHandler;</span><br><span class="line"><span class="comment">//结果提取器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ResponseExtractor&lt;HttpHeaders&gt; headersExtractor = <span class="keyword">new</span> <span class="title class_">HeadersExtractor</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板方法</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doExecute</span><span class="params">(URI url, <span class="meta">@Nullable</span> HttpMethod method, <span class="meta">@Nullable</span> RequestCallback requestCallback,<span class="meta">@Nullable</span> ResponseExtractor&lt;T&gt; responseExtractor)</span> <span class="keyword">throws</span> RestClientException &#123;</span><br><span class="line">		<span class="type">ClientHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//创建请求命令  通过分析 createRequest 这里拿到的是 InterceptingClientHttpRequest</span></span><br><span class="line">			<span class="type">ClientHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> createRequest(url, method);</span><br><span class="line">			<span class="keyword">if</span> (requestCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">				requestCallback.doWithRequest(request);</span><br><span class="line">			&#125;</span><br><span class="line"><span class="comment">//请求执行 InterceptingClientHttpRequest.execute()</span></span><br><span class="line">			response = request.execute();</span><br><span class="line"><span class="comment">//异常处理</span></span><br><span class="line">			handleResponse(url, method, response);</span><br><span class="line"><span class="comment">//结果提取</span></span><br><span class="line">			<span class="keyword">return</span> (responseExtractor != <span class="literal">null</span> ? responseExtractor.extractData(response) : <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//...</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//创建请求命令</span></span><br><span class="line">    <span class="keyword">protected</span> ClientHttpRequest <span class="title function_">createRequest</span><span class="params">(URI url, HttpMethod method)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//调用 父类 InterceptingHttpAccessor 方法 得到 InterceptingClientHttpRequestFactory(内部持有SimpleClientHttpRequestFactory) 创建  ClientHttpRequest(InterceptingClientHttpRequest)</span></span><br><span class="line">		<span class="type">ClientHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> getRequestFactory().createRequest(url, method);</span><br><span class="line"><span class="comment">//使用HttpAccessor 方法完成初始化</span></span><br><span class="line">		initialize(request);</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;HTTP &quot;</span> + method.name() + <span class="string">&quot; &quot;</span> + url);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> request;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RestTemplate类及父类都是通过ClientHttpRequestFactory工厂来创建请求，并在不同的父类中，工厂类有所不同，InterceptingHttpAccessor 中有ClientHttpRequestFactory (InterceptingClientHttpRequestFactory) 创建 InterceptingClientHttpRequest 有了拦截器能力，HttpAccessor中有ClientHttpRequestFactory （SimpleClientHttpRequestFactory)有通过HttpURLConnection发送http请求发送能力</p>
<img src="/2022/05/15/spring/RestTemplate/RestTemplate%E5%88%9B%E5%BB%BARequest%E8%BF%87%E7%A8%8B.jpg" class="" title="RestTemplate创建Request过程">
<blockquote>
<p>那么 ClientHttpRequestFactory 如何创建 request 并且ClientHttpRequest 是如何在执行的时候，执行拦截器，并完成最后的http请求的呢？</p>
</blockquote>
<img src="/2022/05/15/spring/RestTemplate/ClientHttpRequestFactory.png" class="" title="类图结构">

<img src="/2022/05/15/spring/RestTemplate/HttpRequest.png" class="" title="类图结构">

<h1 id="ClientHttpRequestFactory-通过URI和HttpMethod创建请求"><a href="#ClientHttpRequestFactory-通过URI和HttpMethod创建请求" class="headerlink" title="ClientHttpRequestFactory 通过URI和HttpMethod创建请求"></a>ClientHttpRequestFactory 通过URI和HttpMethod创建请求</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClientHttpRequestFactory</span> &#123;</span><br><span class="line">	ClientHttpRequest <span class="title function_">createRequest</span><span class="params">(URI uri, HttpMethod httpMethod)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *包装类， 内部持有实际工厂</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClientHttpRequestFactoryWrapper</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestFactory</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ClientHttpRequestFactory requestFactory;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> ClientHttpRequest <span class="title function_">createRequest</span><span class="params">(URI uri, HttpMethod httpMethod)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//调用内部方法</span></span><br><span class="line">		<span class="keyword">return</span> createRequest(uri, httpMethod, <span class="built_in">this</span>.requestFactory);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//由子类创建请求，并将包装的工厂，传递给子类</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> ClientHttpRequest <span class="title function_">createRequest</span><span class="params">( URI uri, HttpMethod httpMethod, ClientHttpRequestFactory requestFactory)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带有拦截器的工厂类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterceptingClientHttpRequestFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractClientHttpRequestFactoryWrapper</span> &#123;</span><br><span class="line"><span class="comment">// 拦截器列表</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;ClientHttpRequestInterceptor&gt; interceptors;</span><br><span class="line"><span class="comment">//持有包装的工厂类 和 拦截器构造方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">InterceptingClientHttpRequestFactory</span><span class="params">(ClientHttpRequestFactory requestFactory,</span></span><br><span class="line"><span class="params">			<span class="meta">@Nullable</span> List&lt;ClientHttpRequestInterceptor&gt; interceptors)</span> &#123;</span><br><span class="line">		<span class="built_in">super</span>(requestFactory);</span><br><span class="line">		<span class="built_in">this</span>.interceptors = (interceptors != <span class="literal">null</span> ? interceptors : Collections.emptyList());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里实现了 父类 AbstractClientHttpRequestFactoryWrapper 的 createRequest 参数 requestFactory </span></span><br><span class="line"><span class="comment">//正式父类持有的包装类 也就是InterceptingClientHttpRequestFactory 构造函数传递进去的被包装的类，</span></span><br><span class="line"><span class="comment">//根据 InterceptingHttpAccessor 分析 此处被包装的类是 HttpAccessor 类中的 SimpleClientHttpRequestFactory</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> ClientHttpRequest <span class="title function_">createRequest</span><span class="params">(URI uri, HttpMethod httpMethod, ClientHttpRequestFactory requestFactory)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InterceptingClientHttpRequest</span>(requestFactory, <span class="built_in">this</span>.interceptors, uri, httpMethod);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="ClientHttpRequest-完成拦截器功能及底层的http请求"><a href="#ClientHttpRequest-完成拦截器功能及底层的http请求" class="headerlink" title="ClientHttpRequest 完成拦截器功能及底层的http请求"></a>ClientHttpRequest 完成拦截器功能及底层的http请求</h1><img src="/2022/05/15/spring/RestTemplate/HTTPmessage.png" class="" title="类图结构">
<img src="/2022/05/15/spring/RestTemplate/HttpRequest.png" class="" title="类图结构">

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *通用消息定义</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpMessage</span> &#123;</span><br><span class="line">	HttpHeaders <span class="title function_">getHeaders</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *输出消息</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpOutputMessage</span> <span class="keyword">extends</span> <span class="title class_">HttpMessage</span> &#123;</span><br><span class="line">	OutputStream <span class="title function_">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *输入消息</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpInputMessage</span> <span class="keyword">extends</span> <span class="title class_">HttpMessage</span> &#123;</span><br><span class="line">	InputStream <span class="title function_">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *http请求</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpRequest</span> <span class="keyword">extends</span> <span class="title class_">HttpMessage</span> &#123;</span><br><span class="line"><span class="comment">//请求方法</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">default</span> HttpMethod <span class="title function_">getMethod</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> HttpMethod.resolve(getMethodValue());</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//请求方法</span></span><br><span class="line">	String <span class="title function_">getMethodValue</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//请求URI</span></span><br><span class="line">	URI <span class="title function_">getURI</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的客户端http请求 继承了 HttpRequest HttpOutputMessage 命令模式可被执行（包含http命令的内容 body 包含http headers 包含 请求方法 请求URI)</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClientHttpRequest</span> <span class="keyword">extends</span> <span class="title class_">HttpRequest</span>, HttpOutputMessage &#123;</span><br><span class="line">	ClientHttpResponse <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的客户端http请求 默认的抽象ClientHttpRequest实现类，持有HttpHeaders成员变量</span></span><br><span class="line"><span class="comment"> * 实现 execute 方法，生成 executeInternal抽象方法    扩展execute 新增Httpheaders参数，提供子类执行http请求必要数据</span></span><br><span class="line"><span class="comment"> * 实现 getBody 方法， 生成  getBodyInternal抽象方法  扩展getBody 新增Httpheaders参数，提供子类执行getBody请求必要数据</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClientHttpRequest</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequest</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpHeaders</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">executed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> HttpHeaders <span class="title function_">getHeaders</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">this</span>.executed ? HttpHeaders.readOnlyHttpHeaders(<span class="built_in">this</span>.headers) : <span class="built_in">this</span>.headers);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> OutputStream <span class="title function_">getBody</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		assertNotExecuted();</span><br><span class="line">		<span class="keyword">return</span> getBodyInternal(<span class="built_in">this</span>.headers);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> ClientHttpResponse <span class="title function_">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		assertNotExecuted();</span><br><span class="line">		<span class="type">ClientHttpResponse</span> <span class="variable">result</span> <span class="operator">=</span> executeInternal(<span class="built_in">this</span>.headers);</span><br><span class="line">		<span class="built_in">this</span>.executed = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> OutputStream <span class="title function_">getBodyInternal</span><span class="params">(HttpHeaders headers)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> ClientHttpResponse <span class="title function_">executeInternal</span><span class="params">(HttpHeaders headers)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的客户端http请求 实现了抽象类AbstractClientHttpRequest，持有消息体 </span></span><br><span class="line"><span class="comment"> * 实现 executeInternal 并扩展  executeInternal 除了HttpHeaders 新增bufferedOutput参数，提供子类执行http请求必要数据</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBufferingClientHttpRequest</span> <span class="keyword">extends</span> <span class="title class_">AbstractClientHttpRequest</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">ByteArrayOutputStream</span> <span class="variable">bufferedOutput</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(<span class="number">1024</span>);</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> OutputStream <span class="title function_">getBodyInternal</span><span class="params">(HttpHeaders headers)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">this</span>.bufferedOutput;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> ClientHttpResponse <span class="title function_">executeInternal</span><span class="params">(HttpHeaders headers)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">byte</span>[] bytes = <span class="built_in">this</span>.bufferedOutput.toByteArray();</span><br><span class="line"><span class="comment">//添加内容长度</span></span><br><span class="line">		<span class="keyword">if</span> (headers.getContentLength() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			headers.setContentLength(bytes.length);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">ClientHttpResponse</span> <span class="variable">result</span> <span class="operator">=</span> executeInternal(headers, bytes);</span><br><span class="line">		<span class="built_in">this</span>.bufferedOutput = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//子类实现 此类提供请求头和请求体</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> ClientHttpResponse <span class="title function_">executeInternal</span><span class="params">(HttpHeaders headers, <span class="type">byte</span>[] bufferedOutput)</span><span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端http请求 实现了拦截器链功能的请求 实现了抽象类AbstractBufferingClientHttpRequest，持有消息体，持有消息头，并且完成了 executeInternal实现，是一个具体可被执行的http请求</span></span><br><span class="line"><span class="comment"> *  1：执行委派给了拦截器处理链</span></span><br><span class="line"><span class="comment"> *  2：拦截器链顺序执行 拦截器列表，拦截器完成对请求对象的相关处理 如负载均衡</span></span><br><span class="line"><span class="comment"> *  3：拦截器链执行完毕后最终执行 SimpleClientHttpRequestFactory 创建请求，完成真正的请求执行</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InterceptingClientHttpRequest</span> <span class="keyword">extends</span> <span class="title class_">AbstractBufferingClientHttpRequest</span> &#123;</span><br><span class="line">    <span class="comment">//有包装工厂 InterceptingClientHttpRequestFactory 提供的  SimpleClientHttpRequestFactory</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ClientHttpRequestFactory requestFactory;</span><br><span class="line">    <span class="comment">//有包装工厂 InterceptingClientHttpRequestFactory 提供的  拦截器处理链</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;ClientHttpRequestInterceptor&gt; interceptors;</span><br><span class="line">    <span class="comment">//请求URI及请求方法</span></span><br><span class="line">	<span class="keyword">private</span> HttpMethod method;</span><br><span class="line">	<span class="keyword">private</span> URI uri;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//具体执行委派给了处理链</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> ClientHttpResponse <span class="title function_">executeInternal</span><span class="params">(HttpHeaders headers, <span class="type">byte</span>[] bufferedOutput)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="type">InterceptingRequestExecution</span> <span class="variable">requestExecution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterceptingRequestExecution</span>();</span><br><span class="line">		<span class="comment">//拦截器链执行 拦截器列表以此执行并最终发返回 InterceptingRequestExecution 最终的HTTP最终请求</span></span><br><span class="line">		<span class="keyword">return</span> requestExecution.execute(<span class="built_in">this</span>, bufferedOutput);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拦截器链执行器</span></span><br><span class="line"> 	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">InterceptingRequestExecution</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestExecution</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;ClientHttpRequestInterceptor&gt; iterator;</span><br><span class="line">		<span class="keyword">public</span> <span class="title function_">InterceptingRequestExecution</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">//处理链持有 InterceptingClientHttpRequest 中的 拦截器迭代器</span></span><br><span class="line">			<span class="built_in">this</span>.iterator = interceptors.iterator();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> ClientHttpResponse <span class="title function_">execute</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		    <span class="comment">//执行拦截器，拦截器中持有处理链，并在拦截器链中继续执行拦截器链</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.iterator.hasNext()) &#123;</span><br><span class="line">				<span class="type">ClientHttpRequestInterceptor</span> <span class="variable">nextInterceptor</span> <span class="operator">=</span> <span class="built_in">this</span>.iterator.next();</span><br><span class="line">				<span class="keyword">return</span> nextInterceptor.intercept(request, body, <span class="built_in">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">//处理链执行完毕执行真正的请求</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">HttpMethod</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">                <span class="comment">//将经过一系列处理的请求，最终数据委派SimpleClientHttpRequestFactory 创建请求来执行</span></span><br><span class="line">				<span class="type">ClientHttpRequest</span> <span class="variable">delegate</span> <span class="operator">=</span> requestFactory.createRequest(request.getURI(), method);</span><br><span class="line">                <span class="comment">//将请求数据设置到委派的请求中</span></span><br><span class="line">				request.getHeaders().forEach((key, value) -&gt; delegate.getHeaders().addAll(key, value));</span><br><span class="line">				<span class="keyword">if</span> (body.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> StreamingHttpOutputMessage) &#123;</span><br><span class="line">						<span class="type">StreamingHttpOutputMessage</span> <span class="variable">streamingOutputMessage</span> <span class="operator">=</span> (StreamingHttpOutputMessage) delegate;</span><br><span class="line">						streamingOutputMessage.setBody(outputStream -&gt; StreamUtils.copy(body, outputStream));</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						StreamUtils.copy(body, delegate.getBody());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> delegate.execute();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//拦截器</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;</span><br><span class="line">	ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body, ClientHttpRequestExecution execution)</span><span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Request 执行过程</p>
<img src="/2022/05/15/spring/RestTemplate/InterceptingClientHttpRequestexec.jpg" class="" title="Request执行过程">
<h1 id="总-结"><a href="#总-结" class="headerlink" title="总 结"></a>总 结</h1><ol>
<li>RestTemplate 通过模板方法来控制整个执行过程</li>
<li>RestTemplate 包含了 父类 HttpAccessor (创建基础HTTP请求能力-SimpleClientHttpRequestFactory) 和 父类InterceptingHttpAccessor（创建带有拦截器功能的HTTP请求的能力-InterceptingClientHttpRequestFactory)</li>
<li>RestTemplate createRequest 使用 InterceptingClientHttpRequestFactory 创建了 InterceptingClientHttpRequest。InterceptingClientHttpRequestFactory 是一个装饰类 里边装饰了 SimpleClientHttpRequestFactory，并且持有拦截器列表，并创建InterceptingClientHttpRequest请求，InterceptingClientHttpRequest中持有了SimpleClientHttpRequestFactory，这使得InterceptingClientHttpRequest完成处理拦截器链的请求执行完成后可执行基础的HTTP请求。</li>
<li>InterceptingClientHttpRequest 内部类 InterceptingRequestExecution 使用拦截器列表迭代器，顺序执行拦截器列表，并在最后使用SimpleClientHttpRequestFactory创建请求完成基础HTTP请求</li>
</ol>
<h3 id="spring-cloud-commons-包负载均衡自动化配置"><a href="#spring-cloud-commons-包负载均衡自动化配置" class="headerlink" title="spring-cloud-commons 包负载均衡自动化配置"></a>spring-cloud-commons 包负载均衡自动化配置</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line"><span class="string">org.springframework.cloud.client.loadbalancer.AsyncLoadBalancerAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.client.loadbalancer.LoadBalancerAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.client.loadbalancer.reactive.LoadBalancerBeanPostProcessorAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.client.loadbalancer.reactive.ReactorLoadBalancerClientAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.client.loadbalancer.reactive.ReactiveLoadBalancerAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.client.serviceregistry.ServiceRegistryAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.commons.httpclient.HttpClientConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.commons.util.UtilAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.configuration.CompatibilityVerifierAutoConfiguration,\</span></span><br><span class="line"><span class="string">org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationAutoConfiguration</span></span><br></pre></td></tr></table></figure>

<h3 id="spring-cloud-commons-包"><a href="#spring-cloud-commons-包" class="headerlink" title="spring-cloud-commons 包"></a>spring-cloud-commons 包</h3><p>SmartInitializingSingleton<br>LoadBalancerRequestFactory<br>LoadBalancerClient 接口<br>LoadBalancerInterceptor ClientHttpRequestInterceptor<br>RestTemplateCustomizer</p>
<h3 id="spring-web-包"><a href="#spring-web-包" class="headerlink" title="spring-web 包"></a>spring-web 包</h3><p>RestTemplate<br>ClientHttpRequestFactory<br>ClientHttpRequestInterceptor<br>HttpMessage -&gt; HttpOutputMessage -&gt;  ClientHttpRequest(HttpRequest)<br>HttpMessage -&gt; HttpInputMessage  -&gt;  ClientHttpResponse<br>HttpRequest -&gt; HttpRequestWrapper<br>UriTemplateHandler<br>RequestCallback<br>HttpMessageConverter<br>ResponseErrorHandler<br>ResponseExtractor</p>
<h3 id="spring-cloud-netflix-ribbon"><a href="#spring-cloud-netflix-ribbon" class="headerlink" title="spring-cloud-netflix-ribbon"></a>spring-cloud-netflix-ribbon</h3><p>RibbonAutoConfiguration<br>RibbonLoadBalancerClient<br>RestTemplateCustomizer<br>RibbonClientHttpRequestFactory</p>
<h3 id="SpringClientFactory-服务子容器内默认配置"><a href="#SpringClientFactory-服务子容器内默认配置" class="headerlink" title="SpringClientFactory 服务子容器内默认配置"></a>SpringClientFactory 服务子容器内默认配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringClientFactory</span> <span class="keyword">extends</span> <span class="title class_">NamedContextFactory</span>&lt;RibbonClientSpecification&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAMESPACE</span> <span class="operator">=</span> <span class="string">&quot;ribbon&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">SpringClientFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//子容器相关类默认配置RibbonClientConfiguration 默认控制及命名空间</span></span><br><span class="line">		<span class="built_in">super</span>(RibbonClientConfiguration.class, NAMESPACE, <span class="string">&quot;ribbon.client.name&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="属性工厂"><a href="#属性工厂" class="headerlink" title="属性工厂"></a>属性工厂</h4><p>支持配置文件控制ribbon 相关元素  ILoadBalancer IPing IRule ServerList ServerListFilter</p>
<ul>
<li>从环境变量中获取相关服务  如：orderapplication.ribbon.NFLoadBalancerClassName</li>
<li>从环境变量中获取相关服务  如：orderapplication.ribbon.NFLoadBalancerPingClassName</li>
<li>从环境变量中获取相关服务  如：orderapplication.ribbon.NFLoadBalancerRuleClassName</li>
<li>从环境变量中获取相关服务  如：orderapplication.ribbon.NIWSServerListClassName</li>
<li>从环境变量中获取相关服务  如：orderapplication.ribbon.NIWSServerListFilterClassName</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PropertiesFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Map&lt;Class, String&gt; classToProperty = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">PropertiesFactory</span><span class="params">()</span> &#123;</span><br><span class="line">		classToProperty.put(ILoadBalancer.class, <span class="string">&quot;NFLoadBalancerClassName&quot;</span>);</span><br><span class="line">		classToProperty.put(IPing.class, <span class="string">&quot;NFLoadBalancerPingClassName&quot;</span>);</span><br><span class="line">		classToProperty.put(IRule.class, <span class="string">&quot;NFLoadBalancerRuleClassName&quot;</span>);</span><br><span class="line">		classToProperty.put(ServerList.class, <span class="string">&quot;NIWSServerListClassName&quot;</span>);</span><br><span class="line">		classToProperty.put(ServerListFilter.class, <span class="string">&quot;NIWSServerListFilterClassName&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSet</span><span class="params">(Class clazz, String name)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> StringUtils.hasText(getClassName(clazz, name));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getClassName</span><span class="params">(Class clazz, String name)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.classToProperty.containsKey(clazz)) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">classNameProperty</span> <span class="operator">=</span> <span class="built_in">this</span>.classToProperty.get(clazz);</span><br><span class="line">            <span class="comment">//从环境变量中获取相关服务  如：orderapplication.ribbon.NFLoadBalancerClassName</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> environment.getProperty(name + <span class="string">&quot;.&quot;</span> + NAMESPACE + <span class="string">&quot;.&quot;</span> + classNameProperty);</span><br><span class="line">			<span class="keyword">return</span> className;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> &lt;C&gt; C <span class="title function_">get</span><span class="params">(Class&lt;C&gt; clazz, IClientConfig config, String name)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> getClassName(clazz, name);</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasText(className)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Class&lt;?&gt; toInstantiate = Class.forName(className);</span><br><span class="line">				<span class="keyword">return</span> (C) SpringClientFactory.instantiateWithConfig(toInstantiate,</span><br><span class="line">						config);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unknown class to load &quot;</span> + className</span><br><span class="line">						+ <span class="string">&quot; for class &quot;</span> + clazz + <span class="string">&quot; named &quot;</span> + name);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="子容器相关类默认配置（RibbonClientConfiguration"><a href="#子容器相关类默认配置（RibbonClientConfiguration" class="headerlink" title="子容器相关类默认配置（RibbonClientConfiguration)"></a>子容器相关类默认配置（RibbonClientConfiguration)</h4><p>默认每个子容器都配置了Ribbon需要的组件</p>
<ul>
<li>IClientConfig  默认配置 DefaultClientConfigImpl</li>
<li>IRule  默认配置 ZoneAvoidanceRule</li>
<li>IPing  默认配置 DummyPing</li>
<li>ServerList <code>&lt;Server&gt;</code> 默认配置ConfigurationBasedServerList</li>
<li>ServerListUpdater 默认配置 PollingServerListUpdater</li>
<li>ILoadBalancer 默认配置 ZoneAwareLoadBalancer</li>
<li>ServerListFilter <code>&lt;Server&gt;</code> 默认配置 ZonePreferenceServerListFilter</li>
<li>RibbonLoadBalancerContext 默认配置 RibbonLoadBalancerContext</li>
<li>RetryHandler 默认配置 DefaultLoadBalancerRetryHandler</li>
<li>ServerIntrospector 默认配置 DefaultServerIntrospector</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RibbonClientConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Ribbon client default connect timeout.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_CONNECT_TIMEOUT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Ribbon client default read timeout.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_READ_TIMEOUT</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Ribbon client default Gzip Payload flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">DEFAULT_GZIP_PAYLOAD</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RibbonClientName</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;client&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> maybe re-instate autowired load balancers: identified by name they could be</span></span><br><span class="line">	<span class="comment">// associated with ribbon clients</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="keyword">public</span> IClientConfig <span class="title function_">ribbonClientConfig</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="type">DefaultClientConfigImpl</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultClientConfigImpl</span>();</span><br><span class="line"><span class="comment">//加载给定服务的属性</span></span><br><span class="line">		config.loadProperties(<span class="built_in">this</span>.name);</span><br><span class="line">		config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">		config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);</span><br><span class="line">		config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD);</span><br><span class="line">		<span class="keyword">return</span> config;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="keyword">public</span> IRule <span class="title function_">ribbonRule</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line"><span class="comment">//从配置文件中加载IRule</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.propertiesFactory.get(IRule.class, config, name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">ZoneAvoidanceRule</span> <span class="variable">rule</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZoneAvoidanceRule</span>();</span><br><span class="line">		rule.initWithNiwsConfig(config);</span><br><span class="line">		<span class="keyword">return</span> rule;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="keyword">public</span> IPing <span class="title function_">ribbonPing</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line"><span class="comment">//从配置文件中加载IRule</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.propertiesFactory.isSet(IPing.class, name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.propertiesFactory.get(IPing.class, config, name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DummyPing</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> ServerList&lt;Server&gt; <span class="title function_">ribbonServerList</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.propertiesFactory.isSet(ServerList.class, name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.propertiesFactory.get(ServerList.class, config, name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">ConfigurationBasedServerList</span> <span class="variable">serverList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConfigurationBasedServerList</span>();</span><br><span class="line">		serverList.initWithNiwsConfig(config);</span><br><span class="line">		<span class="keyword">return</span> serverList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="keyword">public</span> ServerListUpdater <span class="title function_">ribbonServerListUpdater</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PollingServerListUpdater</span>(config);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="keyword">public</span> ILoadBalancer <span class="title function_">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span><br><span class="line"><span class="params">			ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span><br><span class="line"><span class="params">			IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.propertiesFactory.isSet(ILoadBalancer.class, name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.propertiesFactory.get(ILoadBalancer.class, config, name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ZoneAwareLoadBalancer</span>&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">				serverListFilter, serverListUpdater);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">	<span class="keyword">public</span> ServerListFilter&lt;Server&gt; <span class="title function_">ribbonServerListFilter</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.propertiesFactory.isSet(ServerListFilter.class, name)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.propertiesFactory.get(ServerListFilter.class, config, name);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">ZonePreferenceServerListFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZonePreferenceServerListFilter</span>();</span><br><span class="line">		filter.initWithNiwsConfig(config);</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="keyword">public</span> RibbonLoadBalancerContext <span class="title function_">ribbonLoadBalancerContext</span><span class="params">(ILoadBalancer loadBalancer,</span></span><br><span class="line"><span class="params">			IClientConfig config, RetryHandler retryHandler)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RibbonLoadBalancerContext</span>(loadBalancer, config, retryHandler);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="keyword">public</span> RetryHandler <span class="title function_">retryHandler</span><span class="params">(IClientConfig config)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultLoadBalancerRetryHandler</span>(config);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="keyword">public</span> ServerIntrospector <span class="title function_">serverIntrospector</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultServerIntrospector</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preprocess</span><span class="params">()</span> &#123;</span><br><span class="line">		setRibbonProperty(name, DeploymentContextBasedVipAddresses.key(), name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Seata安装</title>
    <url>/2022/05/19/spring/seata/</url>
    <content><![CDATA[<p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案,</p>
<h2 id="一-Seata术语"><a href="#一-Seata术语" class="headerlink" title="一:Seata术语"></a>一:Seata术语</h2><h4 id="TC-Transaction-Coordinator-事务协调者"><a href="#TC-Transaction-Coordinator-事务协调者" class="headerlink" title="TC (Transaction Coordinator) - 事务协调者"></a>TC (Transaction Coordinator) - 事务协调者</h4><p>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<h4 id="TM-Transaction-Manager-事务管理器"><a href="#TM-Transaction-Manager-事务管理器" class="headerlink" title="TM (Transaction Manager) - 事务管理器"></a>TM (Transaction Manager) - 事务管理器</h4><p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
<h4 id="RM-Resource-Manager-资源管理器"><a href="#RM-Resource-Manager-资源管理器" class="headerlink" title="RM (Resource Manager) - 资源管理器"></a>RM (Resource Manager) - 资源管理器</h4><p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<h2 id="二：资源介绍"><a href="#二：资源介绍" class="headerlink" title="二：资源介绍"></a>二：资源介绍</h2><p>Seata分TC、TM和RM三个角色，TC（Server端）为单独服务端部署，TM和RM（Client端）由业务系统集成。</p>
<h4 id="client"><a href="#client" class="headerlink" title="client"></a>client</h4><p>存放client端sql脚本 (包含 <strong>undo_log</strong>表) </p>
<h4 id="config-center"><a href="#config-center" class="headerlink" title="config-center"></a>config-center</h4><p>各个配置中心参数导入脚本，<strong>config.txt</strong>(包含server和client，原名nacos-config.txt)为通用参数文件</p>
<h4 id="server"><a href="#server" class="headerlink" title="server"></a>server</h4><p>server端数据库脚本 (<strong>包含 lock_table、branch_table  global_table 与 distributed_lock</strong>) 及各个容器配置</p>
<h2 id="三：Server安装："><a href="#三：Server安装：" class="headerlink" title="三：Server安装："></a>三：Server安装：</h2><p>Server端存储模式（store.mode）现有file、db、redis三种（后续将引入raft,mongodb），</p>
<p>file模式无需改动，直接启动即可，注： file模式为单机模式，全局事务会话信息内存中读写并持久化本地文件root.data，性能较高;</p>
<p>db模式为高可用模式，全局事务会话信息通过db共享，相应性能差些;</p>
<p>redis模式Seata-Server 1.3及以上版本支持,性能较高,存在事务信息丢失风险,请提前配置合适当前场景的redis持久化配置.</p>
<h3 id="文件配置方式"><a href="#文件配置方式" class="headerlink" title="文件配置方式"></a>文件配置方式</h3><h4 id="文件模式"><a href="#文件模式" class="headerlink" title="文件模式"></a>文件模式</h4><h5 id="file-config-配置存储模式"><a href="#file-config-配置存储模式" class="headerlink" title="file.config 配置存储模式"></a>file.config 配置存储模式</h5><p>此处配置了全局事务以何种方式来存储，配置mode = “db” 支持 file db redis</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">store <span class="punctuation">&#123;</span></span><br><span class="line">  ## store mode<span class="punctuation">:</span> file、db、redis</span><br><span class="line">  mode = <span class="string">&quot;db&quot;</span></span><br><span class="line">  ## rsa decryption public key</span><br><span class="line">  publicKey = <span class="string">&quot;&quot;</span></span><br><span class="line">  ## file store property</span><br><span class="line">  file <span class="punctuation">&#123;</span></span><br><span class="line">    ## store location dir</span><br><span class="line">    dir = <span class="string">&quot;sessionStore&quot;</span></span><br><span class="line">    # branch session size <span class="punctuation">,</span> if exceeded first try compress lockkey<span class="punctuation">,</span> still exceeded throws exceptions</span><br><span class="line">    maxBranchSessionSize = <span class="number">16384</span></span><br><span class="line">    # globe session size <span class="punctuation">,</span> if exceeded throws exceptions</span><br><span class="line">    maxGlobalSessionSize = <span class="number">512</span></span><br><span class="line">    # file buffer size <span class="punctuation">,</span> if exceeded allocate new buffer</span><br><span class="line">    fileWriteBufferCacheSize = <span class="number">16384</span></span><br><span class="line">    # when recover batch read size</span><br><span class="line">    sessionReloadReadSize = <span class="number">100</span></span><br><span class="line">    # async<span class="punctuation">,</span> sync</span><br><span class="line">    flushDiskMode = async</span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  ## database store property</span><br><span class="line">  db <span class="punctuation">&#123;</span></span><br><span class="line">    ## the implement of javax.sql.DataSource<span class="punctuation">,</span> such as DruidDataSource(druid)/BasicDataSource(dbcp)/HikariDataSource(hikari) etc.</span><br><span class="line">    datasource = <span class="string">&quot;druid&quot;</span></span><br><span class="line">    ## mysql/oracle/postgresql/h2/oceanbase etc.</span><br><span class="line">    dbType = <span class="string">&quot;mysql&quot;</span></span><br><span class="line">    driverClassName = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="line">    ## if using mysql to store the data<span class="punctuation">,</span> recommend add rewriteBatchedStatements=<span class="literal"><span class="keyword">true</span></span> in jdbc connection param</span><br><span class="line">    url = <span class="string">&quot;jdbc:mysql://127.0.0.1:3306/seata?rewriteBatchedStatements=true&quot;</span></span><br><span class="line">    user = <span class="string">&quot;root&quot;</span></span><br><span class="line">    password = <span class="string">&quot;CHENxiao1989119&quot;</span></span><br><span class="line">    minConn = <span class="number">5</span></span><br><span class="line">    maxConn = <span class="number">100</span></span><br><span class="line">    globalTable = <span class="string">&quot;global_table&quot;</span></span><br><span class="line">    branchTable = <span class="string">&quot;branch_table&quot;</span></span><br><span class="line">    lockTable = <span class="string">&quot;lock_table&quot;</span></span><br><span class="line">    queryLimit = <span class="number">100</span></span><br><span class="line">    maxWait = <span class="number">5000</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"></span><br><span class="line">  ## redis store property</span><br><span class="line">  redis <span class="punctuation">&#123;</span></span><br><span class="line">    ## redis mode<span class="punctuation">:</span> single、sentinel</span><br><span class="line">    mode = <span class="string">&quot;single&quot;</span></span><br><span class="line">    ## single mode property</span><br><span class="line">    single <span class="punctuation">&#123;</span></span><br><span class="line">      host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">      port = <span class="string">&quot;6379&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    ## sentinel mode property</span><br><span class="line">    sentinel <span class="punctuation">&#123;</span></span><br><span class="line">      masterName = <span class="string">&quot;&quot;</span></span><br><span class="line">      ## such as <span class="string">&quot;10.28.235.65:26379,10.28.235.65:26380,10.28.235.65:26381&quot;</span></span><br><span class="line">      sentinelHosts = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">    password = <span class="string">&quot;&quot;</span></span><br><span class="line">    database = <span class="string">&quot;0&quot;</span></span><br><span class="line">    minConn = <span class="number">1</span></span><br><span class="line">    maxConn = <span class="number">10</span></span><br><span class="line">    maxTotal = <span class="number">100</span></span><br><span class="line">    queryLimit = <span class="number">100</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="registry-conf-注册及配置中心"><a href="#registry-conf-注册及配置中心" class="headerlink" title="registry.conf 注册及配置中心"></a>registry.conf 注册及配置中心</h5><p>此处配置seata的配置中心使用何种方式，及集群模式下的seata服务如何注册服务</p>
<h4 id="使用nacos作为配置中心及服务治理中心"><a href="#使用nacos作为配置中心及服务治理中心" class="headerlink" title="使用nacos作为配置中心及服务治理中心"></a>使用nacos作为配置中心及服务治理中心</h4><p>注册中心type = “nacos”，seata服务将seataServer注册到注册中心</p>
<p>配置中心type = “nacos”   seata服务将从nacos取得seata服务的配置信息，当采用file模式，将从file.conf文件中获取配置</p>
<p>seata服务配置项可从config.txt,中获取，并上传至配置中心</p>
<p>（1）下载config.txt,并自行对应的脚本nacos-config.sh 会到上层目录查找config.txt</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh /d/softw/seata/seata-server-1.4.2/conf/nacos-config.sh -h localhost -p 8848 -g SEATA_GROUP -t 7dba3cc6-3805-4f3d-b89c-0519044013b7 -u username -w password</span><br><span class="line">-h -- nacos ip</span><br><span class="line">-p -- nacos 端口</span><br><span class="line">-g -- seata-server配置文件 分组名</span><br><span class="line">-t -- seata-server配置文件 命名空间ID</span><br><span class="line">-u -- nacos账号</span><br><span class="line">-w -- nacos密码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（2）server可使用dataId = “seataServer.properties” cleant端使用上传配置 并拷贝参数到nacos</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">nacos <span class="punctuation">&#123;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;7dba3cc6-3805-4f3d-b89c-0519044013b7&quot;</span></span><br><span class="line">    group = <span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">    username = <span class="string">&quot;&quot;</span></span><br><span class="line">    password = <span class="string">&quot;&quot;</span></span><br><span class="line">    #可指定dataId</span><br><span class="line">    dataId = <span class="string">&quot;seataServer.properties&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h3 id="DBScript脚本"><a href="#DBScript脚本" class="headerlink" title="DBScript脚本"></a>DBScript脚本</h3><h4 id="Server端-MYSQL"><a href="#Server端-MYSQL" class="headerlink" title="Server端 MYSQL"></a>Server端 MYSQL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- -------------------------------- The script used when storeMode is &#x27;db&#x27; --------------------------------</span></span><br><span class="line"><span class="comment">-- the table to store GlobalSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `global_table`</span><br><span class="line">(</span><br><span class="line">    `xid`                       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `transaction_id`            <span class="type">BIGINT</span>,</span><br><span class="line">    `status`                    TINYINT      <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `application_id`            <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_service_group` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `transaction_name`          <span class="type">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    `timeout`                   <span class="type">INT</span>,</span><br><span class="line">    `begin_time`                <span class="type">BIGINT</span>,</span><br><span class="line">    `application_data`          <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`                DATETIME,</span><br><span class="line">    `gmt_modified`              DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`xid`),</span><br><span class="line">    KEY `idx_gmt_modified_status` (`gmt_modified`, `status`),</span><br><span class="line">    KEY `idx_transaction_id` (`transaction_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store BranchSession data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `branch_table`</span><br><span class="line">(</span><br><span class="line">    `branch_id`         <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `xid`               <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `transaction_id`    <span class="type">BIGINT</span>,</span><br><span class="line">    `resource_group_id` <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `resource_id`       <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `branch_type`       <span class="type">VARCHAR</span>(<span class="number">8</span>),</span><br><span class="line">    `status`            TINYINT,</span><br><span class="line">    `client_id`         <span class="type">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">    `application_data`  <span class="type">VARCHAR</span>(<span class="number">2000</span>),</span><br><span class="line">    `gmt_create`        DATETIME(<span class="number">6</span>),</span><br><span class="line">    `gmt_modified`      DATETIME(<span class="number">6</span>),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`branch_id`),</span><br><span class="line">    KEY `idx_xid` (`xid`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- the table to store lock data</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `lock_table`</span><br><span class="line">(</span><br><span class="line">    `row_key`        <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `xid`            <span class="type">VARCHAR</span>(<span class="number">128</span>),</span><br><span class="line">    `transaction_id` <span class="type">BIGINT</span>,</span><br><span class="line">    `branch_id`      <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `resource_id`    <span class="type">VARCHAR</span>(<span class="number">256</span>),</span><br><span class="line">    `table_name`     <span class="type">VARCHAR</span>(<span class="number">32</span>),</span><br><span class="line">    `pk`             <span class="type">VARCHAR</span>(<span class="number">36</span>),</span><br><span class="line">    `status`         TINYINT      <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;0:locked ,1:rollbacking&#x27;</span>,</span><br><span class="line">    `gmt_create`     DATETIME,</span><br><span class="line">    `gmt_modified`   DATETIME,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`row_key`),</span><br><span class="line">    KEY `idx_status` (`status`),</span><br><span class="line">    KEY `idx_branch_id` (`branch_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `distributed_lock`</span><br><span class="line">(</span><br><span class="line">    `lock_key`       <span class="type">CHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `lock_value`     <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `expire`         <span class="type">BIGINT</span>,</span><br><span class="line">    <span class="keyword">primary</span> key (`lock_key`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;AsyncCommitting&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;RetryCommitting&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;RetryRollbacking&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `distributed_lock` (lock_key, lock_value, expire) <span class="keyword">VALUES</span> (<span class="string">&#x27;TxTimeoutCheck&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="Client端sql"><a href="#Client端sql" class="headerlink" title="Client端sql"></a>Client端sql</h4><h5 id="AT模式-MYSQL-AT模式支持的数据库有：MySQL、Oracle、PostgreSQL、-TiDB、MariaDB。"><a href="#AT模式-MYSQL-AT模式支持的数据库有：MySQL、Oracle、PostgreSQL、-TiDB、MariaDB。" class="headerlink" title="AT模式 MYSQL AT模式支持的数据库有：MySQL、Oracle、PostgreSQL、 TiDB、MariaDB。"></a>AT模式 MYSQL AT模式支持的数据库有：MySQL、Oracle、PostgreSQL、 TiDB、MariaDB。</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意此处0.7.0+ 增加字段 context</span></span><br><span class="line"><span class="comment">-- for AT mode you must to init this sql for you business database. the seata server not need it.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `undo_log`</span><br><span class="line">(</span><br><span class="line">    `branch_id`     <span class="type">BIGINT</span>       <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;branch transaction id&#x27;</span>,</span><br><span class="line">    `xid`           <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;global transaction id&#x27;</span>,</span><br><span class="line">    `context`       <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;undo_log context,such as serialization&#x27;</span>,</span><br><span class="line">    `rollback_info` LONGBLOB     <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;rollback info&#x27;</span>,</span><br><span class="line">    `log_status`    <span class="type">INT</span>(<span class="number">11</span>)      <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;0:normal status,1:defense status&#x27;</span>,</span><br><span class="line">    `log_created`   DATETIME(<span class="number">6</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create datetime&#x27;</span>,</span><br><span class="line">    `log_modified`  DATETIME(<span class="number">6</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;modify datetime&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `ux_undo_log` (`xid`, `branch_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8 COMMENT <span class="operator">=</span><span class="string">&#x27;AT transaction mode undo table&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="SAGE模式-MYSQL-Saga模式不依赖数据源。"><a href="#SAGE模式-MYSQL-Saga模式不依赖数据源。" class="headerlink" title="SAGE模式 MYSQL Saga模式不依赖数据源。"></a>SAGE模式 MYSQL Saga模式不依赖数据源。</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- -------------------------------- The script used for sage  --------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `seata_state_machine_def`</span><br><span class="line">(</span><br><span class="line">    `id`               <span class="type">VARCHAR</span>(<span class="number">32</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    `name`             <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">    `tenant_id`        <span class="type">VARCHAR</span>(<span class="number">32</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant id&#x27;</span>,</span><br><span class="line">    `app_name`         <span class="type">VARCHAR</span>(<span class="number">32</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;application name&#x27;</span>,</span><br><span class="line">    `type`             <span class="type">VARCHAR</span>(<span class="number">20</span>)  COMMENT <span class="string">&#x27;state language type&#x27;</span>,</span><br><span class="line">    `comment_`         <span class="type">VARCHAR</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;comment&#x27;</span>,</span><br><span class="line">    `ver`              <span class="type">VARCHAR</span>(<span class="number">16</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;version&#x27;</span>,</span><br><span class="line">    `gmt_create`       DATETIME(<span class="number">3</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create time&#x27;</span>,</span><br><span class="line">    `status`           <span class="type">VARCHAR</span>(<span class="number">2</span>)   <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;status(AC:active|IN:inactive)&#x27;</span>,</span><br><span class="line">    `content`          TEXT COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">    `recover_strategy` <span class="type">VARCHAR</span>(<span class="number">16</span>) COMMENT <span class="string">&#x27;transaction recover strategy(compensate|retry)&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `seata_state_machine_inst`</span><br><span class="line">(</span><br><span class="line">    `id`                  <span class="type">VARCHAR</span>(<span class="number">128</span>)            <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    `machine_id`          <span class="type">VARCHAR</span>(<span class="number">32</span>)             <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;state machine definition id&#x27;</span>,</span><br><span class="line">    `tenant_id`           <span class="type">VARCHAR</span>(<span class="number">32</span>)             <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant id&#x27;</span>,</span><br><span class="line">    `parent_id`           <span class="type">VARCHAR</span>(<span class="number">128</span>) COMMENT <span class="string">&#x27;parent id&#x27;</span>,</span><br><span class="line">    `gmt_started`         DATETIME(<span class="number">3</span>)             <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;start time&#x27;</span>,</span><br><span class="line">    `business_key`        <span class="type">VARCHAR</span>(<span class="number">48</span>) COMMENT <span class="string">&#x27;business key&#x27;</span>,</span><br><span class="line">    `start_params`        TEXT COMMENT <span class="string">&#x27;start parameters&#x27;</span>,</span><br><span class="line">    `gmt_end`             DATETIME(<span class="number">3</span>) COMMENT <span class="string">&#x27;end time&#x27;</span>,</span><br><span class="line">    `excep`               <span class="type">BLOB</span> COMMENT <span class="string">&#x27;exception&#x27;</span>,</span><br><span class="line">    `end_params`          TEXT COMMENT <span class="string">&#x27;end parameters&#x27;</span>,</span><br><span class="line">    `status`              <span class="type">VARCHAR</span>(<span class="number">2</span>) COMMENT <span class="string">&#x27;status(SU succeed|FA failed|UN unknown|SK skipped|RU running)&#x27;</span>,</span><br><span class="line">    `compensation_status` <span class="type">VARCHAR</span>(<span class="number">2</span>) COMMENT <span class="string">&#x27;compensation status(SU succeed|FA failed|UN unknown|SK skipped|RU running)&#x27;</span>,</span><br><span class="line">    `is_running`          TINYINT(<span class="number">1</span>) COMMENT <span class="string">&#x27;is running(0 no|1 yes)&#x27;</span>,</span><br><span class="line">    `gmt_updated`         DATETIME(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `unikey_buz_tenant` (`business_key`, `tenant_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `seata_state_inst`</span><br><span class="line">(</span><br><span class="line">    `id`                       <span class="type">VARCHAR</span>(<span class="number">48</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">    `machine_inst_id`          <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;state machine instance id&#x27;</span>,</span><br><span class="line">    `name`                     <span class="type">VARCHAR</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;state name&#x27;</span>,</span><br><span class="line">    `type`                     <span class="type">VARCHAR</span>(<span class="number">20</span>)  COMMENT <span class="string">&#x27;state type&#x27;</span>,</span><br><span class="line">    `service_name`             <span class="type">VARCHAR</span>(<span class="number">128</span>) COMMENT <span class="string">&#x27;service name&#x27;</span>,</span><br><span class="line">    `service_method`           <span class="type">VARCHAR</span>(<span class="number">128</span>) COMMENT <span class="string">&#x27;method name&#x27;</span>,</span><br><span class="line">    `service_type`             <span class="type">VARCHAR</span>(<span class="number">16</span>) COMMENT <span class="string">&#x27;service type&#x27;</span>,</span><br><span class="line">    `business_key`             <span class="type">VARCHAR</span>(<span class="number">48</span>) COMMENT <span class="string">&#x27;business key&#x27;</span>,</span><br><span class="line">    `state_id_compensated_for` <span class="type">VARCHAR</span>(<span class="number">50</span>) COMMENT <span class="string">&#x27;state compensated for&#x27;</span>,</span><br><span class="line">    `state_id_retried_for`     <span class="type">VARCHAR</span>(<span class="number">50</span>) COMMENT <span class="string">&#x27;state retried for&#x27;</span>,</span><br><span class="line">    `gmt_started`              DATETIME(<span class="number">3</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;start time&#x27;</span>,</span><br><span class="line">    `is_for_update`            TINYINT(<span class="number">1</span>) COMMENT <span class="string">&#x27;is service for update&#x27;</span>,</span><br><span class="line">    `input_params`             TEXT COMMENT <span class="string">&#x27;input parameters&#x27;</span>,</span><br><span class="line">    `output_params`            TEXT COMMENT <span class="string">&#x27;output parameters&#x27;</span>,</span><br><span class="line">    `status`                   <span class="type">VARCHAR</span>(<span class="number">2</span>)   <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;status(SU succeed|FA failed|UN unknown|SK skipped|RU running)&#x27;</span>,</span><br><span class="line">    `excep`                    <span class="type">BLOB</span> COMMENT <span class="string">&#x27;exception&#x27;</span>,</span><br><span class="line">    `gmt_updated`              DATETIME(<span class="number">3</span>) COMMENT <span class="string">&#x27;update time&#x27;</span>,</span><br><span class="line">    `gmt_end`                  DATETIME(<span class="number">3</span>) COMMENT <span class="string">&#x27;end time&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`, `machine_inst_id`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line">  <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>

<h5 id="TCC模式mysql-TCC模式不依赖数据源-1-4-2版本及之前-，1-4-2版本之后增加了TCC防悬挂措施，需要数据源支持。"><a href="#TCC模式mysql-TCC模式不依赖数据源-1-4-2版本及之前-，1-4-2版本之后增加了TCC防悬挂措施，需要数据源支持。" class="headerlink" title="TCC模式mysql   TCC模式不依赖数据源(1.4.2版本及之前)，1.4.2版本之后增加了TCC防悬挂措施，需要数据源支持。"></a>TCC模式mysql   TCC模式不依赖数据源(1.4.2版本及之前)，1.4.2版本之后增加了TCC防悬挂措施，需要数据源支持。</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- -------------------------------- The script use tcc fence  --------------------------------</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> `tcc_fence_log`</span><br><span class="line">(</span><br><span class="line">    `xid`           <span class="type">VARCHAR</span>(<span class="number">128</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;global id&#x27;</span>,</span><br><span class="line">    `branch_id`     <span class="type">BIGINT</span>        <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;branch id&#x27;</span>,</span><br><span class="line">    `action_name`   <span class="type">VARCHAR</span>(<span class="number">64</span>)   <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;action name&#x27;</span>,</span><br><span class="line">    `status`        TINYINT       <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;status(tried:1;committed:2;rollbacked:3;suspended:4)&#x27;</span>,</span><br><span class="line">    `gmt_create`    DATETIME(<span class="number">3</span>)   <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create time&#x27;</span>,</span><br><span class="line">    `gmt_modified`  DATETIME(<span class="number">3</span>)   <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;update time&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`xid`, `branch_id`),</span><br><span class="line">    KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">    KEY `idx_status` (`status`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB</span><br><span class="line"><span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8;</span><br></pre></td></tr></table></figure>



<h5 id="XA模式-XA模式只支持实现了XA协议的数据库。Seata支持MySQL、Oracle、PostgreSQL和MariDB。"><a href="#XA模式-XA模式只支持实现了XA协议的数据库。Seata支持MySQL、Oracle、PostgreSQL和MariDB。" class="headerlink" title="XA模式   XA模式只支持实现了XA协议的数据库。Seata支持MySQL、Oracle、PostgreSQL和MariDB。"></a>XA模式   XA模式只支持实现了XA协议的数据库。Seata支持MySQL、Oracle、PostgreSQL和MariDB。</h5><h2 id="四：事务分组"><a href="#四：事务分组" class="headerlink" title="四：事务分组"></a>四：事务分组</h2><ul>
<li><p>每个Seata应用侧的RM、TM，都具有一个<strong>事务分组</strong>名</p>
</li>
<li><p>每个Seata协调器侧的TC，都具有一个<strong>集群名</strong>和<strong>Seata服务地址列表</strong> 映射</p>
<p>​    应用侧连接协调器侧时，经历如下两步：</p>
<p>​    通过事务分组的名称，从配置中获取到该应用侧对应的TC集群名</p>
<p>​    过集群名称，可以从注册中心中获取TC集群的地址列表 </p>
</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Client端配置事务分组</span></span><br><span class="line"><span class="attr">seata.tx-service-group</span>=<span class="string">$&#123;spring.application.name&#125;-tx-group</span></span><br><span class="line"><span class="comment">#Server端配置事务分组与集群的映射关系</span></span><br><span class="line"><span class="attr">service.vgroupMapping.default_tx_group</span>=<span class="string">default</span></span><br><span class="line"><span class="attr">service.vgroupMapping.seata-order-tx-group</span>=<span class="string">default</span></span><br><span class="line"><span class="attr">service.vgroupMapping.seata-store-tx-group</span>=<span class="string">default</span></span><br><span class="line"><span class="attr">service.vgroupMapping.seata-shop-tx-group</span>=<span class="string">default</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Seata集群名称是在SeataServer registry.conf配置文件中指定</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">registry <span class="punctuation">&#123;</span></span><br><span class="line">  # file 、nacos 、eureka、redis、zk、consul、etcd3、sofa</span><br><span class="line">  type = <span class="string">&quot;nacos&quot;</span></span><br><span class="line">  nacos <span class="punctuation">&#123;</span></span><br><span class="line">    application = <span class="string">&quot;seata-server&quot;</span></span><br><span class="line">    serverAddr = <span class="string">&quot;127.0.0.1:8848&quot;</span></span><br><span class="line">    group = <span class="string">&quot;SEATA_GROUP&quot;</span></span><br><span class="line">    namespace = <span class="string">&quot;7dba3cc6-3805-4f3d-b89c-0519044013b7&quot;</span></span><br><span class="line">    cluster = <span class="string">&quot;default&quot;</span></span><br><span class="line">    username = <span class="string">&quot;&quot;</span></span><br><span class="line">    password = <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="远程服务调用XID的事务传播："><a href="#远程服务调用XID的事务传播：" class="headerlink" title="远程服务调用XID的事务传播："></a>远程服务调用XID的事务传播：</h2><p>分布在网络上的服务如何感知并加入到分布式的事务过程中呢，事务属性如何传播的呢？</p>
<p><strong>在spring-cloud-starter-alibaba-seata环境下调用方：</strong></p>
<p>Seata集成了RestTemplet 并自动配了com.alibaba.cloud.seata.SeataRestTemplateAutoConfiguration</p>
<p>Seata集成了RestTemplet 并自动配了com.alibaba.cloud.seata.feign.SeataFeignClientAutoConfiguration</p>
<p>Seata集成了hystrix 并自动配了com.alibaba.cloud.seata.feign.hystrix.SeataHystrixAutoConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">io.seata.integration.http.TransactionPropagationIntercepter&#123;</span><br><span class="line"><span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest httpRequest, <span class="type">byte</span>[] bytes, ClientHttpRequestExecution clientHttpRequestExecution)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">HttpRequestWrapper</span> <span class="variable">requestWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpRequestWrapper</span>(httpRequest);</span><br><span class="line">        <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> RootContext.getXID();</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(xid)) &#123;</span><br><span class="line">            #将TX_XID 添加到请求头</span><br><span class="line">            requestWrapper.getHeaders().add(<span class="string">&quot;TX_XID&quot;</span>, xid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clientHttpRequestExecution.execute(requestWrapper, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">com.alibaba.cloud.seata.feign.SeataFeignClient&#123;</span><br><span class="line">    <span class="keyword">public</span> Response <span class="title function_">execute</span><span class="params">(Request request, Options options)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        #修改请求头</span><br><span class="line">        <span class="type">Request</span> <span class="variable">modifiedRequest</span> <span class="operator">=</span> <span class="built_in">this</span>.getModifyRequest(request);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.delegate.execute(modifiedRequest, options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Request <span class="title function_">getModifyRequest</span><span class="params">(Request request)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> RootContext.getXID();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(xid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Map&lt;String, Collection&lt;String&gt;&gt; headers = <span class="keyword">new</span> <span class="title class_">HashMap</span>(<span class="number">16</span>);</span><br><span class="line">            headers.putAll(request.headers());</span><br><span class="line">            List&lt;String&gt; seataXid = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">            seataXid.add(xid);</span><br><span class="line">            #添加TX_XID到请求头</span><br><span class="line">            headers.put(<span class="string">&quot;TX_XID&quot;</span>, seataXid);</span><br><span class="line">            <span class="keyword">return</span> Request.create(request.method(), request.url(), headers, request.body(), request.charset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在spring-cloud-starter-alibaba-seata环境下接收方：</strong></p>
<p>Seata集成了MvcHandlerInterceptor并自动配了com.alibaba.cloud.seata.SeataHandlerInterceptorConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeataHandlerInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(SeataHandlerInterceptor.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SeataHandlerInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">xid</span> <span class="operator">=</span> RootContext.getXID();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rpcXid</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;TX_XID&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;xid in RootContext &#123;&#125; xid in RpcContext &#123;&#125;&quot;</span>, xid, rpcXid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(xid) &amp;&amp; rpcXid != <span class="literal">null</span>) &#123;</span><br><span class="line">            #从请求头中拿到TX_XID 并绑定rpcxid 达到事务传播功能</span><br><span class="line">            RootContext.bind(rpcXid);</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;bind &#123;&#125; to RootContext&quot;</span>, rpcXid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注：在seata-all包io.seata.integration中 集成了，dubbo,grpc,http,motan,sofa.rpc等事务传播功能：</strong></p>
<h2 id="事务边界定义、控制及事务状态查询（高阶api）"><a href="#事务边界定义、控制及事务状态查询（高阶api）" class="headerlink" title="事务边界定义、控制及事务状态查询（高阶api）"></a>事务边界定义、控制及事务状态查询（高阶api）</h2><h3 id="GlobalTransactionScanner-AbstractAutoProxyCreator-（注解扫描）"><a href="#GlobalTransactionScanner-AbstractAutoProxyCreator-（注解扫描）" class="headerlink" title="GlobalTransactionScanner(AbstractAutoProxyCreator),（注解扫描）"></a>GlobalTransactionScanner(AbstractAutoProxyCreator),（注解扫描）</h3><p>代理对象创建过程,对Seata目标代理对象进行分析并创建合适的植入点。确定哪些类可以做TCC,,根据目标类配置是否是TCC模式 ，确定是否植入TccActionInterceptor拦截（如类上是否有@LocalTCC），根据类上是否有@GlobalTransactional 或者方法上是否有    @GlobalTransactional 或者@GlobalLock 来确定是否植入GlobalTransactionalInterceptor。</p>
<p>TccActionInterceptor对指定@LocalTCC的类方法上有@TwoPhaseBusinessAction做拦截</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@LocalTCC</span><br><span class="line">public interface OrderTcc &#123;</span><br><span class="line">    @TwoPhaseBusinessAction(name = &quot;insertOrder&quot;,commitMethod = &quot;commit&quot;,rollbackMethod = &quot;cancel&quot;)</span><br><span class="line">    public Object insertOrder(@BusinessActionContextParameter(paramName = &quot;order&quot;) OrderInfo order);</span><br><span class="line">    public boolean commit(BusinessActionContext businessActionContext);</span><br><span class="line">    public boolean cancel(BusinessActionContext businessActionContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GlobalTransactionalInterceptor(MethodInterceptor) 提供两种模板方法，根据注解的不同使用不同的模板方法</p>
<p>​    1：TransactionalTemplate 请求全局锁，开启全局事务 模板方法</p>
<p>​        通过GlobalTransactionContext GlobalTransaction  把一个业务服务的调用包装成带有分布式事务支持的服务。</p>
<p>​    2：GlobalLockTemplate，请求全局锁</p>
<p>​        通过RootContext 把一个业务服务的调用包装全局事务锁内进行的服务。</p>
<h2 id="用于控制事务上下文的传播-低阶api"><a href="#用于控制事务上下文的传播-低阶api" class="headerlink" title="用于控制事务上下文的传播(低阶api)"></a>用于控制事务上下文的传播(低阶api)</h2><p>RootContext 事务的根上下文：负责在应用的运行时，维护 XID 。</p>
<p>高阶API 的实现都是基于 RootContext 中维护的 XID 来做的。应用的当前运行的操作是否在一个全局事务的上下文中，就是看 RootContext 中是否有 XID，RootContext 的默认实现是基于 ThreadLocal 的，即 XID 保存在当前线程上下文中</p>
<p>Seata管方文档:<a href="https://seata.io/zh-cn/index.html">Seata</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Seata</tag>
      </tags>
  </entry>
  <entry>
    <title>Seata-AT</title>
    <url>/2022/05/19/spring/seataat/</url>
    <content><![CDATA[<h2 id="AT模式两阶段提交"><a href="#AT模式两阶段提交" class="headerlink" title="AT模式两阶段提交"></a>AT模式两阶段提交</h2><ul>
<li>基于支持本地 ACID 事务的关系型数据库。</li>
<li>Java 应用，通过 JDBC 访问数据库。</li>
</ul>
<p>两阶段提交协议的演变：</p>
<ul>
<li>一阶段：业务数据和回滚日志记录在同一个本地事务中提交，释放本地锁和连接资源。</li>
<li>二阶段：<ul>
<li>提交异步化，非常快速地完成。</li>
<li>回滚通过一阶段的回滚日志进行反向补偿。</li>
</ul>
</li>
</ul>
<p>隔离级别：全局事务隔离级别为读未提交</p>
<h2 id="如何解决脏读脏写"><a href="#如何解决脏读脏写" class="headerlink" title="如何解决脏读脏写:"></a>如何解决脏读脏写:</h2><p>1：脏写因为出现在分支事务中，可使用<code>@GlobalTransactional</code> 升级分支事务请求全局事务锁，来解决脏写问题。</p>
<p>2：脏写因为出现在分支事务中，可使用<code>@GlobalLock + select for update</code> 升级分支事务请求全局事务锁，来解决脏写问题。</p>
<p>3：脏读因为全局事务有可能回滚，导致事务外查询数据会读取到脏数据，可使用<code>@GlobalLock + select for update</code> 升级分支事务请求全局事务锁，来解决脏读问题。</p>
<p><strong>允许空回滚：</strong></p>
<p>事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因为丢包而导致的网络超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；</p>
<p>TCC服务在未收到Try请求的情况下收到Cancel请求，这种场景被称为空回滚；TCC服务在实现时应当允许空回滚的执行；</p>
<p><strong>防悬挂控制:</strong></p>
<p>事务协调器在调用TCC服务的一阶段Try操作时，可能会出现因网络拥堵而导致的超时，此时事务协调器会触发二阶段回滚，调用TCC服务的Cancel操作；在此之后，拥堵在网络上的一阶段Try数据包被TCC服务收到，出现了二阶段Cancel请求比一阶段Try请求先执行的情况；</p>
<p>用户在实现TCC服务时，应当允许空回滚，但是要拒绝执行空回滚之后到来的一阶段Try请求。</p>
<p><strong>幂等控制</strong>:<br>        无论是网络数据包重传，还是异常事务的补偿执行，都会导致TCC服务的Try、Confirm或者Cancel操作被重复执行；用户在实现TCC服务时，需要考虑幂等控制，即Try、Confirm、Cancel 执行次和执行多次的业务结果是一样的</p>
<p><strong>业务数据可见性控制:</strong></p>
<p>TCC服务的一阶段Try操作会做资源的预留，在二阶段操作执行之前，如果其他事务需要读取被预留的资源数据，那么处于中间状态的业务数据该如何向用户展示，需要业务在实现时考虑清楚；通常的设计原则是“宁可不展示、少展示，也不多展示、错展示”</p>
<p><strong>业务数据并发访问控制:</strong><br>        TCC服务的一阶段Try操作预留资源之后，在二阶段操作执行之前，预留的资源都不会被释放；如果此时其他分布式事务修改这些业务资源，会出现分布式事务的并发问题；</p>
<p>用户在实现TCC服务时，需要考虑业务数据的并发控制，尽量将逻辑锁粒度降到最低，以最大限度的提高分布式事务的并发性</p>
<h2 id="全局事务锁"><a href="#全局事务锁" class="headerlink" title="全局事务锁"></a>全局事务锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//io.seata.rm.datasource.exec.BaseTransactionalExecutor类</span></span><br><span class="line"><span class="comment">//全局锁key构建 及锁请求检查</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">prepareUndoLog</span><span class="params">(TableRecords beforeImage, TableRecords afterImage)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">if</span> (beforeImage.getRows().isEmpty() &amp;&amp; afterImage.getRows().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ConnectionProxy</span> <span class="variable">connectionProxy</span> <span class="operator">=</span> statementProxy.getConnectionProxy();</span><br><span class="line">        <span class="type">TableRecords</span> <span class="variable">lockKeyRecords</span> <span class="operator">=</span> sqlRecognizer.getSQLType() == SQLType.DELETE ? beforeImage : afterImage;</span><br><span class="line">    	<span class="comment">//构建全局事务锁key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKeys</span> <span class="operator">=</span> buildLockKey(lockKeyRecords);</span><br><span class="line">        connectionProxy.appendLockKey(lockKeys);</span><br><span class="line">        <span class="type">SQLUndoLog</span> <span class="variable">sqlUndoLog</span> <span class="operator">=</span> buildUndoItem(beforeImage, afterImage);</span><br><span class="line">        connectionProxy.appendUndoLog(sqlUndoLog);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//io.seata.rm.datasource.exec.SelectForUpdateExecutor</span></span><br><span class="line"><span class="comment">//全局锁key构建 及锁请求检查</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">doExecute</span><span class="params">(Object... args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">                    <span class="comment">// Try to get global lock of those rows selected</span></span><br><span class="line">    <span class="type">TableRecords</span> <span class="variable">selectPKRows</span> <span class="operator">=</span> buildTableRecords(getTableMeta(), selectPKSQL, paramAppenderList);</span><br><span class="line">    <span class="comment">//构建全局事务锁key</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">lockKeys</span> <span class="operator">=</span> buildLockKey(selectPKRows);</span><br><span class="line">    <span class="keyword">if</span> (RootContext.inGlobalTransaction()) &#123;</span><br><span class="line">        <span class="comment">//do as usual</span></span><br><span class="line">        statementProxy.getConnectionProxy().checkLock(lockKeys);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (RootContext.requireGlobalLock()) &#123;</span><br><span class="line">        <span class="comment">//check lock key before commit just like DML to avoid reentrant lock problem(no xid thus ca</span></span><br><span class="line">        <span class="comment">// not reentrant)</span></span><br><span class="line">        statementProxy.getConnectionProxy().appendLockKey(lockKeys);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Unknown situation!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//io.seata.rm.datasource.ConnectionProxy类</span></span><br><span class="line"><span class="comment">//提交前注册分支并申请及检查全局锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doCommit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="keyword">if</span> (context.inGlobalTransaction()) &#123;</span><br><span class="line">        <span class="comment">//@GlobalTransaction</span></span><br><span class="line">        processGlobalTransactionCommit();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.isGlobalLockRequire()) &#123;</span><br><span class="line">        <span class="comment">//@GlobalLocks</span></span><br><span class="line">        processLocalCommitWithGlobalLocks();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        targetConnection.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//@GlobalTransaction</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processGlobalTransactionCommit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">                <span class="comment">//注册分支并获取全局锁</span></span><br><span class="line">                register();</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">//@GlobalLocks</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processLocalCommitWithGlobalLocks</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">            checkLock(context.buildLockKeys());</span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//事务分支注册并获取全局锁</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">         ...	</span><br><span class="line">            <span class="type">Long</span> <span class="variable">branchId</span> <span class="operator">=</span> 				       DefaultResourceManager.get().branchRegister(BranchType.AT,getDataSourceProxy().getResourceId(),</span><br><span class="line">                <span class="literal">null</span>, context.getXid(), <span class="literal">null</span>, context.buildLockKeys());</span><br><span class="line">		...</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">//全局锁检查</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkLock</span><span class="params">(String lockKeys)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// Just check lock without requiring lock by now.</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">lockable</span> <span class="operator">=</span> DefaultResourceManager.get().lockQuery(BranchType.AT,</span><br><span class="line">                getDataSourceProxy().getResourceId(), context.getXid(), lockKeys);</span><br><span class="line">            <span class="keyword">if</span> (!lockable) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">LockConflictException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://seata.io/zh-cn/blog/seata-tcc.html">深度剖析 Seata TCC 模式（一）</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Seata</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel</title>
    <url>/2021/11/05/spring/sentinel/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL命令</title>
    <url>/2022/05/30/tool/opensslcommon/</url>
    <content><![CDATA[<p>查看ca证书的内容<br>openssl x509 -in ca.crt -noout -text</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>自签名证书</title>
    <url>/2022/05/30/tool/opensslzqm/</url>
    <content><![CDATA[<h1 id="Centos7-环境下生成自签名SSL证书的具体过程："><a href="#Centos7-环境下生成自签名SSL证书的具体过程：" class="headerlink" title="Centos7 环境下生成自签名SSL证书的具体过程："></a>Centos7 环境下生成自签名SSL证书的具体过程：</h1><ol>
<li><p>修改 openssl 配置文件<br>vi /etc/pki/tls/openssl.cnf<br>match 表示后续生成的子证书的对应项必须和创建根证书时填的值一样，否则报错。以下配置只规定子证书的 countryName 必须和根证书一致。<br>[policy_match] 段配置改成如下：<br>countryName = match<br>stateOrProvinceName = optional<br>organizationName = optional<br>organizationalUnitName = optional<br>commonName = supplied<br>emailAddress = optional</p>
</li>
<li><p>在服务器 pki 的 CA 目录下新建两个文件<br>cd /etc/pki/CA &amp;&amp; touch index.txt serial &amp;&amp; echo 01 &gt; serial</p>
</li>
<li><p>生成CA根证书密钥<br>cd /etc/pki/CA/ &amp;&amp; openssl genrsa -out private/cakey.pem 2048 &amp;&amp; chmod 400 private/cakey.pem</p>
</li>
<li><p>生成根证书（根据提示输入信息，除了 Country Name 选项需要记住的，后面的随便填）<br>openssl req -new -x509 -key private/cakey.pem -out cacert.pem</p>
</li>
<li><p>生成密钥文件<br>openssl genrsa -out nginx.key 2048</p>
</li>
<li><p>生成证书请求文件（CSR）:<br>A.根据提示输入信息，除了 Country Name 与前面根证书一致外，其他随便填写<br>B.Common Name 填写要保护的域名，比如：*.qhh.me<br>openssl req -new -key nginx.key -out nginx.csr</p>
</li>
<li><p>使用 openssl 签署 CSR 请求，生成证书<br>openssl ca -in nginx.csr -cert /etc/pki/CA/cacert.pem -keyfile /etc/pki/CA/private/cakey.pem -days 365 -out nginx.crt</p>
</li>
</ol>
<blockquote>
<p>参数项说明：</p>
</blockquote>
<ol>
<li>-in: CSR 请求文件</li>
<li>-cert: 用于签发的根 CA 证书</li>
<li>-keyfile: 根 CA 的私钥文件</li>
<li>-days: 生成的证书的有效天数</li>
<li>-out: 生成证书的文件名</li>
</ol>
<p>至此自签名证书生成完成，最终需要：nginx.key 和 nginx.crt<br>8. 配置Nginx使用自签名证书</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen  80;</span><br><span class="line">  server_name     domain;</span><br><span class="line">  return  301     https://$host$request_uri;  # 表示强制将http请求重定向到https端口</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">    listen  443 ssl;</span><br><span class="line">    ssl_certificate       ssl/nginx.crt; # 前面生成的 crt 证书文件</span><br><span class="line">    ssl_certificate_key   ssl/nginx.key; # 前面生成的证书私钥</span><br><span class="line">    server_name     domain;</span><br><span class="line">    location / &#123;</span><br><span class="line">    root /var/www-html;</span><br><span class="line">    index  index.html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringWebMvc</title>
    <url>/2021/09/07/spring/springWebMvc/</url>
    <content><![CDATA[<p>SpringWebMVC是构建在ServletAPI上的最初的Web框架，从一开始就包含在Spring框架中。正式名称“SpringWebMVC”来自其源模块(Spring-webmvc)的名称，但它更常见的名称是“SpringMVC”。与SpringWebMVC并行，SpringFramework5.0引入了一个反应性堆栈Web框架，它的名称“SpringWebFlux”也是基于它的源模块(SpringWebFlux)。</p>
<p>与许多其他Web框架一样，SpringMVC是围绕前端控制器模式设计的，其中一个中心servlet DispatcherServlet为请求处理提供了一个共享算法，而实际工作则由可配置的委托组件执行。该模型具有灵活性，支持多种工作流。与任何servlet一样，DispatcherServlet需要使用Java配置或web.xml根据servlet规范进行声明和映射。反过来，DispatcherServlet使用Spring配置来发现请求映射、视图解析、异常处理等所需的委托组件。</p>
<p>SpringBoot遵循不同的初始化顺序。SpringBoot没有连接到servlet容器的生命周期，而是使用Spring配置引导自身和嵌入式servlet容器。<code>Filter</code>和<code>Servlet</code>声明在Spring配置中,容器检测到并在servlet容器中注册. </p>
<p>传统的Spring和Springmvc依赖于servlet容器的生命周期，通过org.springframework.web.context.ContextLoaderListener 容器监听器和org.springframework.web.servlet.DispatcherServlet 注册 来完成容器的启动 这与SpringBoot 通过容器初始化，通过工厂方式创建WebServer ，然后监听ServletContext ,并回调</p>
<span id="more"></span>

<h1 id="上下文层次结构"><a href="#上下文层次结构" class="headerlink" title="上下文层次结构"></a>上下文层次结构</h1><p>DispatcherServlet 可以直接与 ServletContext 进项关联 xml，或者借助 WebApplicationContext 与 ServletContext 进项关联(JavaConfig) ，如果应用程序想要获取WebApplicationContext，可通过RequestContextUtils 工具类获取到它.通常情况下WebApplicationContext 有一个上下文层次结构，应用程序环境有父子容器关系，根<code>ApplicationContext</code>通常包含基础设施bean（扫描service包）,这些bean实际上是继承的，可以在WebApplicationContext （扫描controller包）特定的子级中重写(即重新声明),下图显示了这种关系，</p>
<p><img src="/images/mvc-context-hierarchy.png"></p>
<h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><p>DispatcherServlet 就像Servlet 链接到ServletContext 有多重方式，支持web.xml,或者JAVA 配置方式 来进项链接.（Tomcat容器方式）</p>
<h2 id="web-xml-方式类链接-DispatcherServlet"><a href="#web-xml-方式类链接-DispatcherServlet" class="headerlink" title="web.xml 方式类链接 DispatcherServlet"></a>web.xml 方式类链接 DispatcherServlet</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;web-app&gt;</span><br><span class="line">     &lt;!--ROOTApplicationContext--&gt;</span><br><span class="line">    &lt;listener&gt;</span><br><span class="line">        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;</span><br><span class="line">    &lt;/listener&gt;</span><br><span class="line">    &lt;context-param&gt;</span><br><span class="line">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;classpath:spring.xml,classpath:dubbo-consumer.xml&lt;/param-value&gt;</span><br><span class="line">    &lt;/context-param&gt;</span><br><span class="line">      &lt;!--注册DispatcherServlet--&gt;</span><br><span class="line">    &lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">        &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure>

<h2 id="WebApplicationInitializer-方式类链接-DispatcherServlet"><a href="#WebApplicationInitializer-方式类链接-DispatcherServlet" class="headerlink" title="WebApplicationInitializer 方式类链接 DispatcherServlet"></a>WebApplicationInitializer 方式类链接 DispatcherServlet</h2><p>现在JavaConfig配置方式在逐步取代xml配置方式。而WebApplicationInitializer可以看做是Web.xml的替代，它是一个接口。通过实现WebApplicationInitializer，在其中可以添加servlet，listener等，在加载Web项目的时候会加载这个接口实现类，从而起到web.xml相同的作用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStartup(ServletContext servletContext) &#123;</span><br><span class="line">    </span><br><span class="line">        // Load Spring web application configuration</span><br><span class="line">        AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();</span><br><span class="line">        //可采用注解的方式替代xml配置</span><br><span class="line">        context.register(AppConfig.class);</span><br><span class="line">        </span><br><span class="line">        // Create and register the DispatcherServlet</span><br><span class="line">        DispatcherServlet servlet = new DispatcherServlet(context);</span><br><span class="line">        ServletRegistration.Dynamic registration = servletContext.addServlet(&quot;app&quot;, servlet);</span><br><span class="line">        registration.setLoadOnStartup(1);</span><br><span class="line">        registration.addMapping(&quot;/*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者 采用xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class MyWebApplicationInitializer implements WebApplicationInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onStartup(ServletContext container) &#123;</span><br><span class="line">        XmlWebApplicationContext appContext = new XmlWebApplicationContext();</span><br><span class="line">        appContext.setConfigLocation(&quot;/WEB-INF/spring-mvc.xml&quot;);</span><br><span class="line"></span><br><span class="line">        ServletRegistration.Dynamic registration = container.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(appContext));</span><br><span class="line">        registration.setLoadOnStartup(1);</span><br><span class="line">        registration.addMapping(&quot;/*&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="特殊的Bean"><a href="#特殊的Bean" class="headerlink" title="特殊的Bean"></a>特殊的Bean</h1><p>DispatcherServlet接受请求并强请求委派给SpringMvc中定义的相应功能Bean进项处理，这些Bean担任不同的角色，有者不同的处理能力，这些通常带有内置的契约，我们可以自定义他们的属性或者替换他们来完成我们的业务需求</p>
<table>
<thead>
<tr>
<th align="left">Bean</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">HandlerMapping</td>
<td align="left">将请求映射到处理程序以及生成拦截器处理链。映射是基于一些标准，其细节取决于HandlerMapping实现。两主HandlerMapping实现是RequestMappingHandlerMapping(支持@RequestMapping)和SimpleUrlHandlerMapping(它维护对处理程序的URI路径模式的显式注册)。</td>
</tr>
<tr>
<td align="left">HandlerAdapter</td>
<td align="left">调用映射到请求的处理程序，可适配多种具体的执行方式，如处理程序为handlerMethod Controller HandlerFunction  Servlet HttpRequestHandler，HandlerAdapter主要目的是隐藏调用细节，简化DispatcherServlet，让DispatcherServlet专注于流程控制</td>
</tr>
<tr>
<td align="left">HandlerExceptionResolver</td>
<td align="left">mvc中解决异常的策略，可以将程序中的执行异常，映射到处理程序，HTML试图，或者其他结果，常见的HandlerExceptionResolver实现有，SimpleMappingExceptionResolver，DefaultHandlerExceptionResolver，ResponseStatusExceptionResolver，ExceptionHandlerExceptionResolver</td>
</tr>
<tr>
<td align="left">ViewResolver</td>
<td align="left">如果处理程序返回视图数据模型，那么ViewResolver负责对视图数据模型进行解析,可根据具体的请求接受类型，返回最适合的视图View，并由View进行视图的渲染</td>
</tr>
<tr>
<td align="left">LocaleResolver,LocaleContextResolver</td>
<td align="left">解析Locale客户端正在使用并可能使用他们的时区，以便能够提供国际化的视图</td>
</tr>
<tr>
<td align="left">ThemeResolver</td>
<td align="left">解决您的Web应用程序可以使用的主题</td>
</tr>
<tr>
<td align="left">MultipartResolver</td>
<td align="left">抽象用于解析多部分请求(例如，浏览器表单文件上传)</td>
</tr>
<tr>
<td align="left">FlashMapManager</td>
<td align="left">存储和检索“输入”和“输出”FlashMap它可以用于将属性从一个请求传递到另一个请求</td>
</tr>
</tbody></table>
<h1 id="doDispatch执行流程"><a href="#doDispatch执行流程" class="headerlink" title="doDispatch执行流程:"></a>doDispatch执行流程:</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">         .....</span><br><span class="line">		try &#123;</span><br><span class="line">			ModelAndView mv = null;</span><br><span class="line">			Exception dispatchException = null;</span><br><span class="line">			try &#123;</span><br><span class="line">			    //-------MultipartResolver 解析并装饰 request</span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line">				//-------遍历HandlerMapping 并找到匹配的 处理链 HandlerExecutionChain</span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">				if (mappedHandler == null) &#123;noHandlerFound(processedRequest, response);return;&#125;</span><br><span class="line">				//-------遍历HandlerAdapter 找到支持执行程序的适配器</span><br><span class="line">				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line">				//-------applyPreHandle 拦截器前置处理执行</span><br><span class="line">				if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;return;&#125;</span><br><span class="line">				//-------执行器执行</span><br><span class="line">				mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">				 //-------applyPostHandle 拦截器后置处理执行</span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex) &#123;dispatchException = ...;&#125;</span><br><span class="line">			catch (Throwable err) &#123;dispatchException =...;&#125;</span><br><span class="line">			 //-------异常解析，视图解析 ，视图渲染  拦截器afterCompletion处理执行</span><br><span class="line">			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">		     //-------拦截器afterCompletion处理执行</span><br><span class="line">			triggerAfterCompletion</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Throwable err) &#123;</span><br><span class="line">		   //-------拦截器afterCompletion处理执行</span><br><span class="line">			triggerAfterCompletion</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><ol>
<li>HandlerMapping实现都有哪些，何时被初始化  如何使用扩展</li>
<li>HandlerAdapter实现都有哪些，何时被初始化 如何使用扩展</li>
<li>HandlerExceptionResolver 实现都有哪些，何时被初始化  如何使用扩展            </li>
<li>ViewResolver   实现都有哪些，何时被初始化   如何使用扩展      </li>
<li>LocaleResolver,LocaleContextResolver        实现都有哪些，何时被初始化 如何使用扩展            </li>
<li>ThemeResolver 实现都有哪些，何时被初始化 如何使用扩展          </li>
<li>MultipartResolver   实现都有哪些，何时被初始化 如何使用扩展          </li>
<li>FlashMapManager 实现都有哪些，何时被初始化 如何使用扩展          </li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>springmvc</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>StarUml 激活</title>
    <url>/2022/02/10/tool/umlrg/</url>
    <content><![CDATA[<h3 id="第一步，解包"><a href="#第一步，解包" class="headerlink" title="第一步，解包"></a>第一步，解包</h3><p><code>app.asar</code> 文件是 <code>Electron</code> 程序的主业务文件，是一种压缩格式的文件。我们需要修改的部分就被压缩在这里，具体文件位置为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\StarUML</span><br><span class="line">├─locales</span><br><span class="line">├─resources</span><br><span class="line">| └─app.asar</span><br><span class="line">└─swiftshader</span><br></pre></td></tr></table></figure>

<p><code>app.asar</code> 文件可以使用编辑器直接打开，但如果直接修改会导致程序无法正常运行，因此需要解包修改再压缩。</p>
<p>解包前需要确认您的电脑已经安装 <code>node.js</code> ，可在 <code>CMD</code> 执行以下命令，若回显版本号说明已安装，若没有安装请移步：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files&gt;node -v</span><br><span class="line">v12.18.3</span><br></pre></td></tr></table></figure>

<p>之后全局安装 <code>asar</code> 工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g asar </span><br><span class="line">或者 </span><br><span class="line">cnpm install -g asar</span><br><span class="line"></span><br><span class="line">C:\Program Files&gt;asar -V</span><br><span class="line">v3.0.3</span><br><span class="line"></span><br><span class="line">// 出现版本号说明安装成功</span><br></pre></td></tr></table></figure>

<p>解压 <code>app.asar</code> 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">asar extract app.<span class="property">asar</span> ./asar/</span><br></pre></td></tr></table></figure>

<p>使用上面命令将 <code>app.asar</code> 解压到同级目录 <code>asar</code> 下，前提是 <code>cd</code> 到文件所在目录，并创建好 <code>asar</code> 文件</p>
<h3 id="第二步，激活"><a href="#第二步，激活" class="headerlink" title="第二步，激活"></a>第二步，激活</h3><p>解压后在 asar 目录下，找到这个文件：<code>asar\src\engine\license-manager.js</code>，使用你偏好的编辑器打开，修改其中这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">checkLicenseValidity () &#123;</span><br><span class="line">  this.validate().then(() =&gt; &#123;</span><br><span class="line">    setStatus(this, true)</span><br><span class="line">  &#125;, () =&gt; &#123;</span><br><span class="line">    //setStatus(this,false)  &lt;-- comment this line</span><br><span class="line">    setStatus(this, true) //&lt;-- add this line</span><br><span class="line">    //UnregisteredDialog.showDialog() &lt;-- comment this line</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意其中注释的部分，总结来看就是将 <code>false</code> 改为 <code>true</code>，再将 <code>false</code> 的后续动作注释即可。</p>
<h3 id="第三步，压缩"><a href="#第三步，压缩" class="headerlink" title="第三步，压缩"></a>第三步，压缩</h3><p>修改完成后，将修改后的内容重新打包回 <code>app.asar</code> ，使用以下命令压缩即可，其中 pack 是我前一步解压的目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asar pack asar app.asar</span><br></pre></td></tr></table></figure>

<p>注：建议在此前备份旧的 app.asar 文件，以免造成无法挽回的损失。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>uml</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡</title>
    <url>/2022/05/14/xitong/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<p>系统性能是系统提供给用户众多性能指标的混合体，最具代表性的两个指标为吞吐量，响应时间，那么负载均衡是我们增加系统吞吐量也就是系统性能的有效手段</p>
<h1 id="常用的负载均衡技术"><a href="#常用的负载均衡技术" class="headerlink" title="常用的负载均衡技术"></a>常用的负载均衡技术</h1><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ol>
<li>基于DNS的负载均衡: 在DNS中为多个地址配置同一个名字，在查询的时候将得到其中一个，从而使客服访问不同的服务器，达到负载均衡的目的。缺点：它不能区分服务器差异，也不能反应服务器状态</li>
<li>地址转换网关负载均衡: 支持负载均衡的地址转换网关，<em><strong>可以将一个外部TCP地址映射到内部多个IP地址</strong></em>，对每次TCP连接请求动态使用其中一个地址，达到负载均衡的目的</li>
<li>协议内部支持负载均衡: 有的协议内部支持与负载均衡相关的功能，如HTTP协议中的重定向功能</li>
<li>NAT(NET Address Translation 网络地址转换) 负载均衡:<em><strong>Nat将一个IP地址转换为另一个IP地址</strong></em>，一般用于未注册的内部地址与合法的，已注册的IP地址进行转换，只用于解决IP地址紧张，不想让网络外部知道内部网络结构等场合下。</li>
<li>反向代理负载均衡：正向代理服务是内部通过代理访问外部网络，通过制定代理服务，并发送请求由代理服务器发送真实请求到网络，拿到结果后返回结果给用户，那么反向代理是网络上的用户向反向代理服务器发送请求，反向代理服务器向内部服务请求结果，并最终响应给用户的代理请求。<br>那么内部服务可配置多个站点，由反向代理服务器，实现负载均衡的功能。</li>
<li>混合性负载均衡: 多个集群组成，每个集群使用不同的负载均衡技术</li>
</ol>
<h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><ol>
<li><em><strong>DNS 实现负载均衡</strong></em></li>
<li><em><strong>硬件负载均衡</strong></em><br>硬件负载均衡是通过专门的硬件设备来实现负载均衡功能，类似于交换机、路由器，是一个负载均衡专用的网络设备。目前业界典型的硬件负载均衡设备有两款：F5 和 A10</li>
<li><em><strong>软件负载均衡</strong></em><br>软件负载均衡，可以在普通的服务器上运行负载均衡软件，实现负载均衡功能。目前常见的有 Nginx、HAproxy、LVS</li>
</ol>
<h2 id="网络层级"><a href="#网络层级" class="headerlink" title="网络层级"></a>网络层级</h2><table>
<thead>
<tr>
<th>OSI 7层模型</th>
<th>TCP/IP 4层模型</th>
<th>层</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>应用层</td>
<td>7层</td>
</tr>
<tr>
<td>表示层</td>
<td>应用层</td>
<td>6层</td>
</tr>
<tr>
<td>会话层</td>
<td>应用层 HTTP、 SSH、FTP、SMTP</td>
<td>5层</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层 TCP/UDP(PORT)</td>
<td>4层</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层 IP</td>
<td>3层</td>
</tr>
<tr>
<td>数据链路层2</td>
<td>数据链路层 MAC</td>
<td>2层</td>
</tr>
<tr>
<td>物理层</td>
<td>数据链路层</td>
<td>1层</td>
</tr>
</tbody></table>
<img src="/2022/05/14/xitong/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/2.png" class="">

<p>网络七层模型是一个标准，而非实现。网络四层模型是一个实现的应用模型。网络四层模型由七层模型简化合并而来。</p>
<img src="/2022/05/14/xitong/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/1.png" class="" title="OSI层模型">
<h3 id="7层负载均衡"><a href="#7层负载均衡" class="headerlink" title="7层负载均衡"></a>7层负载均衡</h3><p>&emsp;&emsp;七层负载均衡工作在OSI模型的应用层，应用层协议较多，常用http、radius、dns等。七层负载就可以基于这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个Web服务器的负载均衡，除了根据IP加端口进行负载外，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡 </p>
<h3 id="4层负载均衡"><a href="#4层负载均衡" class="headerlink" title="4层负载均衡"></a>4层负载均衡</h3><p>&emsp;&emsp;所谓四层即运输层，就是基于 IP + 端口的负载均衡，四层负载均衡工作在OSI模型的传输层，由于在传输层，只有TCP/UDP协议，这两种协议中除了包含源IP、目标IP以外，还包含源端口号及目的端口号。四层负载均衡服务器在接受到客户端请求后，以后通过修改数据包的地址信息（IP+端口号）将流量转发到应用服务器</p>
<h3 id="3层负载均衡"><a href="#3层负载均衡" class="headerlink" title="3层负载均衡"></a>3层负载均衡</h3><p>&emsp;&emsp;基于 IP 地址,和二层负载均衡类似，负载均衡服务器对外依然提供一个VIP（虚IP），但是集群中不同的机器采用不同的IP地址。当负载均衡服务器接受到请求之后，根据不同的负载均衡算法，通过IP将请求转发至不同的真实服务器</p>
<h3 id="2层负载均衡"><a href="#2层负载均衡" class="headerlink" title="2层负载均衡"></a>2层负载均衡</h3><p>&emsp;&emsp;基于 MAC 地址,负载均衡服务器对外依然提供一个VIP（虚IP），集群中不同的机器采用相同IP地址，但是机器的MAC地址不一样。当负载均衡服务器接受到请求之后，通过改写报文的目标MAC地址的方式将请求转发到目标机器实现负载均衡</p>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><ul>
<li>高可用集群     优点：避免单节点故障，另一节点能迅速顶替工作</li>
<li>负载均衡集群   优点：提高负载，提高并发量</li>
<li>分布式存储集群  优点：极大提升存储容量，提高数据可用性，保证数据安全</li>
</ul>
<h1 id="常用负载均衡工具"><a href="#常用负载均衡工具" class="headerlink" title="常用负载均衡工具"></a>常用负载均衡工具</h1><h2 id="LVS"><a href="#LVS" class="headerlink" title="LVS"></a>LVS</h2><p>LVS（Linux Virtual Server），也就是Linux虚拟服务器, 是一个由章文嵩博士发起的自由软件项目。使用LVS技术要达到的目标是：通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器群集，它具有良好可靠性、可扩展性和可操作性。从而以低廉的成本实现最优的服务性能</p>
<h3 id="LVS工作模式"><a href="#LVS工作模式" class="headerlink" title="LVS工作模式"></a>LVS工作模式</h3><ul>
<li>LVS/NAT：网络地址转换<img src="/2022/05/14/xitong/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/4.png" class=""></li>
</ul>
<p>-通过网络地址转换实现的虚拟服务器</p>
<p>-大并发访问时，调度器的性能成为瓶颈</p>
<ul>
<li>LVS/DR：直接路由</li>
</ul>
<img src="/2022/05/14/xitong/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/5.png" class="">

<p>-直接使用路由技术实现虚拟服务器</p>
<p>-节点服务器需要配置VIP，注意MAC地址广播</p>
<ul>
<li>LVS/TUN：IP隧道</li>
</ul>
<img src="/2022/05/14/xitong/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/6.png" class="">

<p>-通过隧道方式实现虚拟服务器</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx（发音同engine x）是一个网页服务器，它能反向代理HTTP, HTTPS, SMTP, POP3, IMAP的协议链接，以及一个负载均衡器和一个HTTP缓存。</p>
<h3 id="upstream支持的负载均衡算法"><a href="#upstream支持的负载均衡算法" class="headerlink" title="upstream支持的负载均衡算法"></a>upstream支持的负载均衡算法</h3><ul>
<li>轮询（默认）rr round robin 可以通过weight指定轮询的权重，权重越大，被调度的次数越多</li>
<li>ip_hash 根据每个请求IP进行调度，可以解决session的问题，不能使用weight</li>
<li>fair 可以根据请求页面的大小和加载时间长短进行调度，使用第三方的upstream_fair模块</li>
<li>url_hash 按请求的url的hash进行调度，从而使每个url定向到同一服务器，使用第三方的hash模块<h3 id="upstream支持的状态参数"><a href="#upstream支持的状态参数" class="headerlink" title="upstream支持的状态参数"></a>upstream支持的状态参数</h3></li>
<li>down： 暂停对该服务器的调度</li>
<li>backup: 类似于LVS Sorry Server，当所有的非backup的服务器故障时启用</li>
<li>max_fails: 请求失败的次数，默认为1</li>
<li>fail_timeout: 在经历max_fails次失败后，暂停服务的时间<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">upstream tianyun.com &#123;</span><br><span class="line">       #ip_hash;</span><br><span class="line">       server 192.168.1.5 weight=1 max_fails=2 fail_timeout=2;</span><br><span class="line">       server 192.168.1.2 weight=2 max_fails=2 fail_timeout=2;</span><br><span class="line">       server 192.168.1.3 max_fails=2 fail_timeout=5 down;</span><br><span class="line">       server 192.168.1.4 backup;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">location  / &#123;</span><br><span class="line">     proxy_pass  http://httpservers;</span><br><span class="line">     proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当使用ip_hash时，服务器状态不可使用weight和backup</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>proxy_next_upstream：这个指令属于 http_proxy 模块的，指定后端返回什么样的异常响应时，使用另一个realserver</p>
</blockquote>
<h2 id="HAProxy"><a href="#HAProxy" class="headerlink" title="HAProxy"></a>HAProxy</h2><p>HAProxy是一个使用C语言编写的自由及开放源代码软件，其提供高可用性、负载均衡，以及基于TCP和HTTP的应用程序代理。</p>
]]></content>
      <categories>
        <category>系统性能</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>ORACLE sql 分析</title>
    <url>/2022/08/31/db/oracl/sqlanalysi/</url>
    <content><![CDATA[<p>EXPLAIN PLAN FOR select * from A_AGENT a where a.ID=’AG20181121000000000011525’;</p>
<p>–SELECT plan_table_output FROM TABLE(DBMS_XPLAN.DISPLAY(‘PLAN_TABLE’));</p>
<p>select * from table(dbms_xplan.display);</p>
]]></content>
      <categories>
        <category>DB</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>疯传</title>
    <url>/2022/05/07/Knowledge/contagious/gongkaixing/</url>
    <content><![CDATA[<h2 id="公开性-（模仿心理学-社会认同感-可观察性力量）"><a href="#公开性-（模仿心理学-社会认同感-可观察性力量）" class="headerlink" title="公开性 （模仿心理学 社会认同感 可观察性力量）"></a>公开性 （模仿心理学 社会认同感 可观察性力量）</h2><p>&emsp;&emsp;肯-西格尔（ken segall）一个广告代理公司的总监，长期与乔布斯合作，乔布斯曾对苹果图标在电脑上正放还是反着放很苦恼，他们曾就苹果公司电脑上的苹果图标如何摆放进行讨论。<br>一种情况是将苹果图标正放，当使用者打开电脑的时候看到的图标是正的，并且他们能很好的判断电脑是否是摆正的状态，而且能给用户带来极致的用户体验，这也是乔布斯追求的。但是周围的人看到的图标是返这的，这让乔布斯很是不爽，他觉得会影响苹果的品牌形象。<br>另一种情况是苹果图标是反着的。周围的的人能看到苹果的图标是正着的。后来他们决定将标志反过来放，<strong>原因就是可观察性</strong>，乔布斯发现，<strong>看到别人在做某事的时候人么也会更可能的模仿</strong>。乔布斯是站在了品牌的角度考虑了这个问题，这个设计也是苹果图片自带广告传播属性。<br>使产品风靡的另一种催化剂 <strong>公众的可视性</strong></p>
<h3 id="模仿心理学"><a href="#模仿心理学" class="headerlink" title="模仿心理学"></a>模仿心理学</h3><p>&emsp;&emsp;心里学家将这种从众的心里现象叫做<strong>社会认同感</strong></p>
<p>&emsp;&emsp;如当人们旅游到了一个陌生的城市，走在美食街道往往选择人多的餐馆作为参考，认为人多的餐馆，菜品一定不差<strong>社会认同感</strong></p>
<p>&emsp;&emsp;如咖啡师和酒保换班通常会自己往小费的罐子中投一把一元钱，或者5元钱，是同一个道理，如果罐子是空的，顾客可能认为别人都不付小费，那么自己也不会那么大方，如果罐子是装满了钱，人们则会认为别人肯定都付了小费，自己也会大方一点。<strong>社会认同感</strong></p>
<p>&emsp;&emsp;再比如每年申请肾移植的人超过10万人，那么能够移植的肾是有限的，那么排队的人只能先来后到了，那么如果一个可移植的肾要被移植那需要完成各种匹配，可移植的肾有可能会被有些人拒绝，试想一个排在100位的患者，接收到一个可移植的肾，他有可能会拒绝，社会认同效应就会浮现，因为他觉得前边有90多位患者拒绝那这个肾脏肯定不是好肾。事实上没十个肾移植的人都因此错过治疗。<strong>社会认同感</strong></p>
<p>&emsp;&emsp;从众心理甚至会影响人们选择的职业类型，曾有一些实验，在一些读MBA的学生当中采访他们对未来的憧憬，对未来的工作报复可谓五花八门，医疗改革者，旅游网站，娱乐圈，政府官员等，但是在读了1年MBA后，回答投资银行或者咨询行业的人占了2/3，当学生们读MBA期间会了解到不同的工作机会，但是从众的心里学会受到社会影响所驱使，学生不确定自己将来要做什么职业，所以他们会看别人怎么选。<strong>社会认同感</strong></p>
<blockquote>
<p>当我们想利用这种心里现象的时候，对我们要做的事情有一定的好处，比如说酒保，但是当我们被这种社会认同感所影响的时候，那会是多么可怕，甚至会影响肾病患者的治疗，行业的选择甚至将来的一生，积极的方面不说，如见到苹果电脑的设计，能使苹果产品自带广告效应，单说消极的一面，为什么人们有时候会需要这种社会认同感，或者说求助于社会认同感。</p>
</blockquote>
]]></content>
      <categories>
        <category>知识</category>
      </categories>
      <tags>
        <tag>疯传</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM G1</title>
    <url>/2022/07/21/java/jvm/gc/</url>
    <content><![CDATA[<h1 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#堆</span><br><span class="line">-Xms/-Xmx</span><br><span class="line"></span><br><span class="line">#分区 Region</span><br><span class="line">-XX:G1HeapRegionSize=1048576(1m) #可指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区</span><br><span class="line"></span><br><span class="line">#卡片(Card) 和全局卡片 (Global Card Table) 和 记录卡片(Rset)</span><br><span class="line"></span><br><span class="line">-XX:+UseG1GC </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-XX:InitialHeapSize=1073741824 </span><br><span class="line">-XX:InitiatingHeapOccupancyPercent=35 </span><br><span class="line">-XX:+ManagementServer </span><br><span class="line">-XX:MarkStackSize=4194304 </span><br><span class="line">#GC与应用的耗费时间比 G1默认为9(10)，而CMS默认为99(100) CMS的设计原则是耗费在GC上的时间尽可能的少</span><br><span class="line">-XX:GCTimeRatio </span><br><span class="line">#目标暂停时间 默认200ms</span><br><span class="line">-XX:MaxGCPauseMillis=20 </span><br><span class="line">#最大的堆内存容量</span><br><span class="line">-XX:MaxHeapSize=1073741824</span><br><span class="line"></span><br><span class="line">####################################年轻代</span><br><span class="line">#年轻代配置固定大小 (固定值)</span><br><span class="line">-Xmn100m</span><br><span class="line">#年轻代比例 (固定值比例)</span><br><span class="line">-XX:NewRatio=1   </span><br><span class="line">#最大的年轻代容量 (固定值大小 可伸缩)</span><br><span class="line">-XX:NewSize=2m </span><br><span class="line">#最大的年轻代容量 (固定值大小 可伸缩)</span><br><span class="line">-XX:MaxNewSize=2m  </span><br><span class="line">#整个年轻代内存初始空间 (按比例配置 可伸缩)</span><br><span class="line">-XX:G1NewSizePercent=5</span><br><span class="line">#整个年轻代内存最大空间 (按比例配置 可伸缩)</span><br><span class="line">-XX:G1MaxNewSizePercent=60</span><br><span class="line"></span><br><span class="line">#####################垃圾回收</span><br><span class="line">#晋升到老年代的对象任期阈值 </span><br><span class="line">-XX:MaxTenuringThreshold=15 </span><br><span class="line"></span><br><span class="line">#老年代</span><br><span class="line">#每轮MixedGC回收的Region的最大比例 CSet对堆的总大小占比 10%</span><br><span class="line">-XX:G1OldCSetRegionThresholdPercent=10</span><br><span class="line"></span><br><span class="line">#候选老年代分区的CSet准入条件，活跃度阈值 85% 区域内存活的对象低于此值，那么该区将被纳入Cset,当GC时间过长时候，可适当调整低此值，过了此值就会被GC带走</span><br><span class="line">-XX:G1MixedGCLiveThresholdPercent=85</span><br><span class="line"></span><br><span class="line">#混合垃圾收集阈值   当老年代占用空间超过整堆比IHOP阈值(默认45%)时，Occupancy(占用) G1就会启动一次混合垃圾收集周期。</span><br><span class="line">#为了满足暂停目标，G1可能不能一口气将所有的候选分区收集掉，</span><br><span class="line">#因此G1可能会产生连续多次的混合收集与应用线程交替执行，每次STW的混合收集与年轻代收集过程相类似</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent=45</span><br><span class="line"></span><br><span class="line">#通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量(确定加入混合Cset的分区数量)；根据堆废物百分比，当收集达到参数低于时5%，不再启动新的混合收集（确定是否MixGc）</span><br><span class="line">#混合周期的最大总次数(默认8)</span><br><span class="line">-XX:G1MixedGCCountTarget=8</span><br><span class="line">#堆废物百分比(默认5%)  垃圾占整个堆的百分比，如果超过5%，将触发多轮的MIXgc</span><br><span class="line">-XX:G1HeapWastePercent=5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-XX:GCLogFileSize=104857600 </span><br><span class="line">-XX:MinHeapDeltaBytes=1048576 </span><br><span class="line">-XX:NumberOfGCLogFiles=10 </span><br><span class="line">-XX:+PrintGC </span><br><span class="line">-XX:+PrintGCDateStamps </span><br><span class="line">-XX:+PrintGCDetails </span><br><span class="line">-XX:+PrintGCTimeStamps </span><br><span class="line">-XX:+UnlockCommercialFeatures </span><br><span class="line">-XX:+UseCompressedClassPointers </span><br><span class="line">-XX:+UseCompressedOops </span><br><span class="line"></span><br><span class="line">-XX:+UseGCLogFileRotation </span><br></pre></td></tr></table></figure>

<h1 id="分代模型"><a href="#分代模型" class="headerlink" title="分代模型"></a>分代模型</h1><p>分代模型的是将关注点放在最近被分配的对像上，因为大部分的对象是可以很快被回收的，只有少量的对象的生命周期是长的。分代可可以避免整堆扫描，避免长生命周期的对象的拷贝，同事独立收集可以降低响应时间。</p>
<h2 id="分代-Generation"><a href="#分代-Generation" class="headerlink" title="分代 Generation"></a>分代 Generation</h2><p>G1将内存在逻辑上划分为年轻代和老年代Old，其中年轻代又划分为Eden空间和Survivor空间。但年轻代空间并不是固定不变的，当现有年轻代分区占满时，JVM会分配新的空闲分区加入到年轻代空间</p>
<h2 id="本地分配缓冲-Local-allocation-buffer-TLAB"><a href="#本地分配缓冲-Local-allocation-buffer-TLAB" class="headerlink" title="本地分配缓冲 Local allocation buffer (TLAB)"></a>本地分配缓冲 Local allocation buffer (TLAB)</h2><p>解决对象在堆内存分配操作时候的并发情况。</p>
<p>由于分区的思想，每个线程均可以”认领”某个分区用于线程本地的内存分配，而不需要顾及分区是否连续。因此，每个应用线程和GC线程都会独立的使用分区，进而减少同步时间，提升GC效率，这个分区称为本地分配缓冲区(Lab)。</p>
<p>TLAB 应用线程本地缓冲区 应用线程可以独占一个本地缓冲区(TLAB)来创建的对象，而大部分都会落入Eden区域(巨型对象或分配失败除外)，因此TLAB的分区属于Eden空间</p>
<p>GCLAB 每个GC线程同样可以独占一个本地缓冲区(GCLAB)用来转移对象，每次回收会将对象复制到Suvivor空间或老年代空间；对于从Eden/Survivor空间晋升(Promotion)到Survivor/老年代空间的对象，同样有GC独占的本地缓冲区进行操作，该部分称为晋升本地缓冲区(PLAB)。</p>
<h2 id="分区模型"><a href="#分区模型" class="headerlink" title="分区模型"></a>分区模型</h2><ul>
<li><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><p>G1对内存的使用以分区(Region)为单位，而对对象的分配则以卡片(Card)为单位。</p>
</li>
<li><h3 id="Card-全局卡片Global-Card-Table"><a href="#Card-全局卡片Global-Card-Table" class="headerlink" title="Card/全局卡片Global Card Table"></a>Card/全局卡片Global Card Table</h3><p>每个分区内部又被分成了若干个大小为512 Byte卡片(Card)，标识堆内存最小可用粒度所有分区的卡片将会记录在全局卡片表(Global Card Table)中，分配的对象会占用物理上连续的若干个卡片，当查找对分区内对象的引用时便可通过记录卡片来查找该引用对象(见RSet)。每次对内存的回收，都是对指定分区的卡片进行处理</p>
</li>
<li><h3 id="记录卡片Rset"><a href="#记录卡片Rset" class="headerlink" title="记录卡片Rset"></a>记录卡片Rset</h3><blockquote>
<p>Rset 记录了引用当前分区内对象的引用所在的卡片的索引，帮助确定分区内对象是否存活。</p>
</blockquote>
</li>
</ul>
<p>在串行和并行收集器中，GC通过整堆扫描，来确定对象是否处于可达路径中。然而G1为了避免STW式的整堆扫描，在每个分区记录了一个已记忆集合(RSet)，内部类似一个反向指针，记录引用分区内对象的卡片索引。当要回收该分区时，通过扫描分区的RSet，来确定引用本分区内的对象是否存活，进而确定本分区内的对象存活情况。</p>
<p>事实上，并非所有的引用都需要记录在RSet中，如果一个分区确定需要扫描，那么无需RSet也可以无遗漏的得到引用关系。那么引用源自本分区的对象，当然不用落入RSet中；同时，G1 GC每次都会对年轻代进行整体收集，因此引用源自年轻代的对象，也不需要在RSet中记录。最后只有老年代的分区可能会有RSet记录，这些分区称为拥有RSet分区(an RSet’s owning region)</p>
<ul>
<li><h3 id="Per-Region-Table-PRT"><a href="#Per-Region-Table-PRT" class="headerlink" title="Per Region Table(PRT)"></a>Per Region Table(PRT)</h3>RSet在内部使用Per Region Table(PRT)记录分区的引用情况。由于RSet的记录要占用分区的空间，如果一个分区非常”受欢迎”(该分区内的对象很多都被别的对象引用)，那么RSet占用的空间会上升，从而降低分区的可用空间。G1应对这个问题采用了改变RSet的密度的方式，在PRT中将会以三种模式记录引用：</li>
</ul>
<ol>
<li>稀少：直接记录引用对象的卡片索引</li>
<li>细粒度：记录引用对象的分区索引</li>
<li>粗粒度：只记录引用情况，每个分区对应一个比特位<br>由上可知，粗粒度的PRT只是记录了引用数量，需要通过整堆扫描才能找出所有引用，因此扫描速度也是最慢的</li>
</ol>
<ul>
<li><h3 id="收集集合-CSet"><a href="#收集集合-CSet" class="headerlink" title="收集集合 CSet"></a>收集集合 CSet</h3></li>
</ul>
<p>收集集合(CSet)代表每次GC暂停时回收的一系列目标分区（待垃圾回收的分区记录集合表），任意一次收集暂停中，CSet所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。</p>
<p>年轻代收集CSet只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到CSet中。候选老年代分区的CSet准入条件，可以通过活跃度阈值-XX:G1MixedGCLiveThresholdPercent(默认85%)进行设置（活跃度在85的分区不进入Cset），从而拦截那些回收开销巨大的对象；</p>
<p>同时，每次混合收集时候可以包含候选老年代分区一同收集，可根据CSet对堆的总大小占比-XX:G1OldCSetRegionThresholdPercent(默认10%)设置数量上限,每轮MixedGC回收的Region的最大比例，最多10% ，控制回收时间，可限制候选区一同收集。</p>
<p>由上述可知，G1的收集都是根据CSet进行操作的，年轻代收集与混合收集没有明显的不同，最大的区别在于两种收集的触发条件。</p>
<h2 id="巨型对象-Humongous-Region"><a href="#巨型对象-Humongous-Region" class="headerlink" title="巨型对象 Humongous Region"></a>巨型对象 Humongous Region</h2><p>一个大小达到甚至超过分区大小一半的对象称为巨型对象(Humongous Object)。当线程为巨型分配空间时，不能简单在TLAB进行分配，因为巨型对象的移动成本很高，而且有可能一个分区不能容纳巨型对象。因此，巨型对象会直接在老年代分配，所占用的连续空间称为巨型分区(Humongous Region)。G1内部做了一个优化，一旦发现没有引用指向巨型对象，则可直接在年轻代收集周期中被回收。</p>
<p>巨型对象会独占一个、或多个连续分区，其中第一个分区被标记为开始巨型(StartsHumongous)，相邻连续分区被标记为连续巨型(ContinuesHumongous)。由于无法享受Lab带来的优化，并且确定一片连续的内存空间需要扫描整堆，因此确定巨型对象开始位置的成本非常高，如果可以，应用程序应避免生成巨型对象</p>
<h2 id="收集"><a href="#收集" class="headerlink" title="收集"></a>收集</h2><h3 id="年轻代收集-CSet-of-Young-Collection"><a href="#年轻代收集-CSet-of-Young-Collection" class="headerlink" title="年轻代收集  CSet of Young Collection"></a>年轻代收集  CSet of Young Collection</h3><p>应用线程不断活动后，年轻代空间会被逐渐填满。当JVM分配对象到Eden区域失败(Eden区已满)时，便会触发一次STW式的年轻代收集。在年轻代收集中，Eden分区存活的对象将被拷贝到Survivor分区；原有Survivor分区存活的对象，将根据任期阈值(tenuring threshold)分别晋升到PLAB中，新的survivor分区和老年代分区。而原有的年轻代分区将被整体回收掉。</p>
<p>同时，年轻代收集还负责维护对象的年龄(存活次数)，辅助判断老化(tenuring)对象晋升的时候是到Survivor分区还是到老年代分区。年轻代收集首先先将晋升对象尺寸总和、对象年龄信息维护到年龄表中，再根据年龄表、Survivor尺寸、Survivor填充容量-XX:TargetSurvivorRatio(默认50%)、最大任期阈值-XX:MaxTenuringThreshold(默认15)，计算出一个恰当的任期阈值，凡是超过任期阈值的对象都会被晋升到老年代。</p>
<h3 id="混合收集集合-CSet-of-Mixed-Collection"><a href="#混合收集集合-CSet-of-Mixed-Collection" class="headerlink" title="混合收集集合  CSet of Mixed Collection"></a>混合收集集合  CSet of Mixed Collection</h3><p>年轻代收集不断活动后，老年代的空间也会被逐渐填充。当老年代占用空间超过整堆比IHOP阈值-XX:InitiatingHeapOccupancyPercent(默认45%)时，G1就会启动一次混合垃圾收集周期。为了满足暂停目标，G1可能不能一口气将所有的候选分区收集掉，因此G1可能会产生连续多次的混合收集与应用线程交替执行，每次STW的混合收集与年轻代收集过程相类似。</p>
<p>为了确定包含到年轻代收集集合CSet的老年代分区，JVM通过参数混合周期的最大总次数-XX:G1MixedGCCountTarget(默认8)、堆废物百分比-XX:G1HeapWastePercent(默认5%)。通过候选老年代分区总数与混合周期最大总次数，确定每次包含到CSet的最小分区数量；根据堆废物百分比，当收集达到参数时，不再启动新的混合收集。而每次添加到CSet的分区，则通过计算得到的GC效率进行安排</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JMC(Java Mission Control)</title>
    <url>/2022/07/19/java/jvm/javamissioncontol/</url>
    <content><![CDATA[<h1 id="JMC-客户端使用JMX-链接到JVM"><a href="#JMC-客户端使用JMX-链接到JVM" class="headerlink" title="JMC 客户端使用JMX 链接到JVM"></a>JMC 客户端使用JMX 链接到JVM</h1><p>一个是JMX端口（需要指定），JMX远程连接端口。<br>一个是RMI端口（默认随机），实际通信用的端口。<br>一个是本地服务端口（随机），用于本地jstat、jconsole连接用，本地使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=&quot;-Dcom.sun.management.jmxremote=true</span><br><span class="line">-Djava.rmi.server.hostname=10.3.60.150</span><br><span class="line">-Dcom.sun.management.jmxremote.port=10000  </span><br><span class="line">-Dcom.sun.management.jmxremote.rmi.port=10001</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false    </span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=true </span><br><span class="line">-Dcom.sun.management.jmxremote.password.file=/root/jmx/jmxremote.password</span><br><span class="line">-Dcom.sun.management.jmxremote.access.file=/root/jmx/jmxremote.access</span><br><span class="line">-XX:+UnlockCommercialFeatures</span><br><span class="line">-XX:+FlightRecorder</span><br><span class="line">-XX:StartFlightRecording=duration=60s,filename=150-cms-startFlight.jfr</span><br><span class="line">-XX:FlightRecorderOptions=defaultrecording=true,dumponexit=true,dumponexitpath=150-cms-onexit.jfr&quot;</span><br></pre></td></tr></table></figure>


<ul>
<li>控制密码文件有限传阅<br>chmode 600 password.file<br>chmode 600 access.file</li>
</ul>
<h1 id="JVM-使用命令行启动飞行器"><a href="#JVM-使用命令行启动飞行器" class="headerlink" title="JVM 使用命令行启动飞行器"></a>JVM 使用命令行启动飞行器</h1><p>解锁商业功能:UnlockCommercialFeatures  使JFR可用:FlightRecorder  短暂监控 StartFlightRecording 启动飞行器，持续时间60s 并保持到文件myrecording.jfr</p>
<p>-XX:+|-UnlockCommercialFeatures</p>
<p>-XX:+|-FlightRecorder</p>
<p>-XX:FlightRecorderOptions=defaultrecording=true,dumponexit=true,dumponexitpath=onexit.jfr,loglevel=trace</p>
<p>-XX:StartFlightRecording=duration=60s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:StartFlightRecording=duration=60s,filename=startFlight.jfr  -XX:FlightRecorderOptions=defaultrecording=true,dumponexit=true,dumponexitpath=onexit.jfr,loglevel=trace MyApp</span><br></pre></td></tr></table></figure>

<p>在 JVM 启动参数中加入-XX:+StartFlightRecording=参数启动记录事件。参数为一个以逗号间隔的键值对数据。下面将介绍这些选项：</p>
<p>name=name<br>指定记录的名称</p>
<p>defaultrecording=true/false<br>是否在初始化时启动记录事件，默认为 false，对于反应分析，应设置为 true</p>
<p>settings=path<br>JFR 配置文件的路径</p>
<p>delay=time<br>开始记录前的延时</p>
<p>duration=time<br>记录持续时间</p>
<p>filename=path<br>保存记录事件的文件路径</p>
<p>compress=true/false<br>是否使用 gzip 压缩记录数据，默认为 false</p>
<p>maxage=time<br>环形缓存中保存记录的数据的最长时间</p>
<p>maxsize=size<br>环形缓存占用的最大空间</p>
<h1 id="使用动态命令"><a href="#使用动态命令" class="headerlink" title="使用动态命令"></a>使用动态命令</h1><p><a href="https://docs.oracle.com/javacomponents/jmc-5-4/jfr-runtime-guide/run.htm#JFRUH164">官方参考文档</a></p>
<h3 id="启动飞行器"><a href="#启动飞行器" class="headerlink" title="启动飞行器"></a>启动飞行器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">jcmd process_id JFR.start [option_list]</span><br><span class="line"></span><br><span class="line">jcmd pid JFR.start duration=60s filename=myrecording.jfr</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看pid jvm 可执行的命令</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">jcmd  pid  help</span><br></pre></td></tr></table></figure>

<ol>
<li>JFR.start</li>
</ol>
<p>启动飞行器</p>
<ol start="2">
<li>JFR.check</li>
</ol>
<p>检查为指定进程运行的所有录制的状态，包括录制标识号、文件名、持续时间等</p>
<ol start="3">
<li>JFR.stop</li>
</ol>
<p>停止带有特定标识号的飞行器(默认情况下，停止飞行器1)。</p>
<ol start="4">
<li>JFR.dump</li>
</ol>
<p>转储到目前为止由具有特定标识号的记录收集的数据(默认情况下，转储来自记录1的数据)。</p>
<h2 id="Access-denied-Invalid-access-level-for-requested-MBeanServer-operation"><a href="#Access-denied-Invalid-access-level-for-requested-MBeanServer-operation" class="headerlink" title="Access denied! Invalid access level for requested MBeanServer operation."></a>Access denied! Invalid access level for requested MBeanServer operation.</h2><p>配置 JRE_HOME/lib/management/jmxremote.access  <em><strong>com.sun.management.</strong></em>*</p>
<p>monitorRole   readonly<br>controlRole   readwrite <br>              create javax.management.monitor.<em>,javax.management.timer.</em>,com.oracle.jrockit.<em>,com.sun.management.</em> <br>              unregister</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA自带工具命令</title>
    <url>/2022/07/18/java/jvm/javatoll/</url>
    <content><![CDATA[<h1 id="JAVA-自带工具"><a href="#JAVA-自带工具" class="headerlink" title="JAVA 自带工具"></a>JAVA 自带工具</h1><ol>
<li>监控工具</li>
<li>故障排除工具</li>
<li>Java故障排除、分析、监控和管理工具</li>
<li>程方法调用(RMI)工具</li>
<li>国际化工具</li>
<li>基础工具</li>
<li>安全</li>
<li>脚本工具</li>
</ol>
<h2 id="一-监控工具"><a href="#一-监控工具" class="headerlink" title="一. 监控工具"></a>一. 监控工具</h2><ul>
<li><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3></li>
</ul>
<blockquote>
<p>JVM进程状态工具——列出目标系统上已检测的HotSpot Java虚拟机    jps [ options ] [ hostid ] </p>
</blockquote>
<blockquote>
<p>hostid -&gt; ([protocol:][[//]hostname][:port][/servername])  </p>
</blockquote>
<blockquote>
<p>protocol 默认为rmi</p>
</blockquote>
<blockquote>
<p>servername 此参数的处理取决于实现。对于优化的本地协议，该字段被忽略。对于rmi协议，该参数是一个字符串，表示远程主机上RMI远程对象的名称。请参见jstatd命令的-n选项</p>
</blockquote>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出传递给main方法的参数。对于嵌入式JVM，输出可能为空</span></span><br><span class="line">jps -m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出传递给JVM的参数。</span></span><br><span class="line">jps -v</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务器上启动jstatd 链接远程服务器</span></span><br><span class="line">jps -v rmi://12.3.10.105:10000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">输出应用程序主类的完整包名或应用程序JAR文件的完整路径名。</span></span><br><span class="line">jps -l</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3></li>
</ul>
<blockquote>
<p>jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ]</p>
</blockquote>
<blockquote>
<p>vmid  =&gt;  [protocol:][//]lvmid[@hostname[:port]/servername]</p>
</blockquote>
<p>一些常用的工具</p>
<blockquote>
<p>jstat -gcnew -h 3 21891 250 #年轻代统计</p>
</blockquote>
<blockquote>
<p>jstat -gcutil 21891 250 7 #gc统计信息</p>
</blockquote>
<blockquote>
<p>jstat -gcutil <a href="mailto:&#x34;&#48;&#52;&#x39;&#54;&#64;&#x72;&#x65;&#109;&#x6f;&#116;&#101;&#46;&#100;&#111;&#x6d;&#97;&#x69;&#x6e;">&#x34;&#48;&#52;&#x39;&#54;&#64;&#x72;&#x65;&#109;&#x6f;&#116;&#101;&#46;&#100;&#111;&#x6d;&#97;&#x69;&#x6e;</a> 1000 #监控远程服务</p>
</blockquote>
<ol>
<li>generalOption（常规命令行选项 statOption）</li>
</ol>
<p> 一个常规命令行选项(-help或-options)  jstat -options<br> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-class</span><br><span class="line">-compiler</span><br><span class="line">-gc</span><br><span class="line">-gccapacity</span><br><span class="line">-gccause</span><br><span class="line">-gcnew</span><br><span class="line">-gcnewcapacity</span><br><span class="line">-gcold</span><br><span class="line">-gcoldcapacity</span><br><span class="line">-gcpermcapacity</span><br><span class="line">-gcutil</span><br><span class="line">-printcompilation</span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>outputOptions （输出格式选项）<br>一个或多个输出选项，由单个statOption加上-t、-h和-J选项组成。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-h n</span><br><span class="line"></span><br><span class="line">每n个样本(输出行)显示一个列标题，其中n是正整数。默认值为0，表示在第一行数据上方显示列标题</span><br><span class="line"></span><br><span class="line">如：jstat -gcutil -h 2 24583 1000 10 （每两行输出一下标题）</span><br><span class="line"></span><br><span class="line">-t</span><br><span class="line"></span><br><span class="line">将时间戳列显示为输出的第一列。时间戳是自目标JVM启动以来的时间。</span><br><span class="line"></span><br><span class="line">-JjavaOption</span><br><span class="line">将javaOption传递给java应用程序启动器。例如，-J-Xms48m将启动内存设置为48兆字节。有关选项的完整列表，请参见Java-Java应用程序启动器</span><br><span class="line"></span><br></pre></td></tr></table></figure>
下表总结了jstat为每个statOption输出的列。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-class Option  类加载统计</span><br><span class="line">Column	Description</span><br><span class="line">Loaded	Number of classes loaded.</span><br><span class="line">Bytes	Number of Kbytes loaded.</span><br><span class="line">Unloaded	Number of classes unloaded.</span><br><span class="line">Bytes	Number of Kbytes unloaded.</span><br><span class="line">Time	Time spent performing class load and unload operations.</span><br><span class="line"></span><br><span class="line">-compiler Option  HotSpot Just-In-Time Compiler Statistics JIT编译统计</span><br><span class="line">Column	Description</span><br><span class="line">Compiled	Number of compilation tasks performed.</span><br><span class="line">Failed	Number of compilation tasks that failed.</span><br><span class="line">Invalid	Number of compilation tasks that were invalidated.</span><br><span class="line">Time	Time spent performing compilation tasks.</span><br><span class="line">FailedType	Compile type of the last failed compilation.</span><br><span class="line">FailedMethod	Class name and method for the last failed compilation.</span><br><span class="line"></span><br><span class="line">-gc Option 垃圾收集的堆统计信息</span><br><span class="line">Column	Description</span><br><span class="line">S0C	Current survivor space 0 capacity (KB).</span><br><span class="line">S1C	Current survivor space 1 capacity (KB).</span><br><span class="line">S0U	Survivor space 0 utilization (KB).</span><br><span class="line">S1U	Survivor space 1 utilization (KB).</span><br><span class="line">EC	Current eden space capacity (KB).</span><br><span class="line">EU	Eden space utilization (KB).</span><br><span class="line">OC	Current old space capacity (KB).</span><br><span class="line">OU	Old space utilization (KB).</span><br><span class="line">PC	Current permanent space capacity (KB).</span><br><span class="line">PU	Permanent space utilization (KB).</span><br><span class="line">YGC	Number of young generation GC Events.</span><br><span class="line">YGCT	Young generation garbage collection time.</span><br><span class="line">FGC	Number of full GC events.</span><br><span class="line">FGCT	Full garbage collection time.</span><br><span class="line">GCT	Total garbage collection time.</span><br><span class="line"></span><br><span class="line">-gccapacity Option  各代内存池和空间容量</span><br><span class="line">Column	Description</span><br><span class="line">NGCMN	Minimum new generation capacity (KB).</span><br><span class="line">NGCMX	Maximum new generation capacity (KB).</span><br><span class="line">NGC	Current new generation capacity (KB).</span><br><span class="line">S0C	Current survivor space 0 capacity (KB).</span><br><span class="line">S1C	Current survivor space 1 capacity (KB).</span><br><span class="line">EC	Current eden space capacity (KB).</span><br><span class="line">OGCMN	Minimum old generation capacity (KB).</span><br><span class="line">OGCMX	Maximum old generation capacity (KB).</span><br><span class="line">OGC	Current old generation capacity (KB).</span><br><span class="line">OC	Current old space capacity (KB).</span><br><span class="line">PGCMN	Minimum permanent generation capacity (KB).</span><br><span class="line">PGCMX	Maximum Permanent generation capacity (KB).</span><br><span class="line">PGC	Current Permanent generation capacity (KB).</span><br><span class="line">PC	Current Permanent space capacity (KB).</span><br><span class="line">YGC	Number of Young generation GC Events.</span><br><span class="line">FGC	Number of Full GC Events.</span><br><span class="line"></span><br><span class="line">-gccause Option  该选项显示与-gcutil选项相同的垃圾收集统计信息摘要，但包括上次垃圾收集事件的原因和(如果适用)当前垃圾收集事件。除了为-gcutil列出的列之外，该选项还添加了以下列:</span><br><span class="line"></span><br><span class="line">Garbage Collection Statistics, Including GC Events</span><br><span class="line">Column	Description</span><br><span class="line">LGCC	Cause of last Garbage Collection.</span><br><span class="line">GCC	Cause of current Garbage Collection.</span><br><span class="line"></span><br><span class="line">-gcnew Option 年轻代统计信息</span><br><span class="line">Column	Description</span><br><span class="line">S0C	Current survivor space 0 capacity (KB).</span><br><span class="line">S1C	Current survivor space 1 capacity (KB).</span><br><span class="line">S0U	Survivor space 0 utilization (KB).</span><br><span class="line">S1U	Survivor space 1 utilization (KB).</span><br><span class="line">TT	Tenuring threshold.</span><br><span class="line">MTT	Maximum tenuring threshold.</span><br><span class="line">DSS	Desired survivor size (KB).</span><br><span class="line">EC	Current eden space capacity (KB).</span><br><span class="line">EU	Eden space utilization (KB).</span><br><span class="line">YGC	Number of young generation GC events.</span><br><span class="line">YGCT	Young generation garbage collection time.</span><br><span class="line"></span><br><span class="line">-gcnewcapacity Option  年轻代空间统计</span><br><span class="line">Column	Description</span><br><span class="line">NGCMN</span><br><span class="line">Minimum new generation capacity (KB).</span><br><span class="line">NGCMX	Maximum new generation capacity (KB).</span><br><span class="line">NGC	Current new generation capacity (KB).</span><br><span class="line">S0CMX	Maximum survivor space 0 capacity (KB).</span><br><span class="line">S0C	Current survivor space 0 capacity (KB).</span><br><span class="line">S1CMX	Maximum survivor space 1 capacity (KB).</span><br><span class="line">S1C	Current survivor space 1 capacity (KB).</span><br><span class="line">ECMX	Maximum eden space capacity (KB).</span><br><span class="line">EC	Current eden space capacity (KB).</span><br><span class="line">YGC	Number of young generation GC events.</span><br><span class="line">FGC	Number of Full GC Events.</span><br><span class="line"></span><br><span class="line">-gcold Option 来年代和永久代统计信息</span><br><span class="line">Column	Description</span><br><span class="line">PC	Current permanent space capacity (KB).</span><br><span class="line">PU	Permanent space utilization (KB).</span><br><span class="line">OC	Current old space capacity (KB).</span><br><span class="line">OU	old space utilization (KB).</span><br><span class="line">YGC	Number of young generation GC events.</span><br><span class="line">FGC	Number of full GC events.</span><br><span class="line">FGCT	Full garbage collection time.</span><br><span class="line">GCT	Total garbage collection time.</span><br><span class="line"></span><br><span class="line">-gcoldcapacity Option 老年代统计</span><br><span class="line">Column	Description</span><br><span class="line">OGCMN	Minimum old generation capacity (KB).</span><br><span class="line">OGCMX	Maximum old generation capacity (KB).</span><br><span class="line">OGC	Current old generation capacity (KB).</span><br><span class="line">OC	Current old space capacity (KB).</span><br><span class="line">YGC	Number of young generation GC events.</span><br><span class="line">FGC	Number of full GC events.</span><br><span class="line">FGCT	Full garbage collection time.</span><br><span class="line">GCT	Total garbage collection time.</span><br><span class="line"></span><br><span class="line">-gcpermcapacity Option 永久代统计</span><br><span class="line">Column	Description</span><br><span class="line">PGCMN	Minimum permanent generation capacity (KB).</span><br><span class="line">PGCMX	Maximum permanent generation capacity (KB).</span><br><span class="line">PGC	Current permanent generation capacity (KB).</span><br><span class="line">PC	Current permanent space capacity (KB).</span><br><span class="line">YGC	Number of young generation GC events.</span><br><span class="line">FGC	Number of full GC events.</span><br><span class="line">FGCT	Full garbage collection time.</span><br><span class="line">GCT	Total garbage collection time.</span><br><span class="line"></span><br><span class="line">-gcutil Option 垃圾收集统计信息摘要</span><br><span class="line">Column	Description</span><br><span class="line">S0	Survivor space 0 utilization as a percentage of the space&#x27;s current capacity.</span><br><span class="line">S1	Survivor space 1 utilization as a percentage of the space&#x27;s current capacity.</span><br><span class="line">E	Eden space utilization as a percentage of the space&#x27;s current capacity.</span><br><span class="line">O	Old space utilization as a percentage of the space&#x27;s current capacity.</span><br><span class="line">P	Permanent space utilization as a percentage of the space&#x27;s current capacity.</span><br><span class="line">YGC	Number of young generation GC events.</span><br><span class="line">YGCT	Young generation garbage collection time.</span><br><span class="line">FGC	Number of full GC events.</span><br><span class="line">FGCT	Full garbage collection time.</span><br><span class="line">GCT	Total garbage collection time.</span><br><span class="line"></span><br><span class="line">-printcompilation Option HotSpot Compiler Method Statistics 方法统计</span><br><span class="line">Column	Description</span><br><span class="line">Compiled	Number of compilation tasks performed by the most recently compiled method.</span><br><span class="line">Size	Number of bytes of bytecode of the most recently compiled method.</span><br><span class="line">Type	Compilation type of the most recently compiled method.</span><br><span class="line">Method	Class name and method name identifying the most recently compiled method. Class name uses &quot;/&quot; instead of &quot;.&quot; as namespace separator. Method name is the method within the given class. The format for these two fields is consistent with the HotSpot - XX:+PrintComplation option.</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><h3 id="jstatd"><a href="#jstatd" class="headerlink" title="jstatd"></a>jstatd</h3></li>
</ul>
<p>JVM jstat Daemon——启动RMI服务器应用程序，该应用程序监视被检测的HotSpot Java虚拟机的创建和终止，并提供一个接口，允许远程监视工具连接到在本地系统上运行的Java虚拟机。</p>
<h2 id="二-故障排除工具"><a href="#二-故障排除工具" class="headerlink" title="二. 故障排除工具"></a>二. 故障排除工具</h2><ul>
<li><h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3></li>
</ul>
<p>jinfo打印给定Java进程或核心文件或远程调试服务器的Java配置信息。配置信息包括Java系统属性和Java虚拟机命令行标志。</p>
<p>如果给定的进程在64位虚拟机上运行，您可能需要指定-J-d64选项，例如: jinfo -J-d64 -sysprops pid</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost bin]# ./jinfo -flags 27463</span><br><span class="line">Attaching to process ID 27463, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.172-b11</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=3 -XX:InitialHeapSize=268435456 -XX:MaxHeapSize=536870912 -XX:MaxNewSize=178782208 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=89128960 -XX:OldSize=179306496 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC </span><br><span class="line">Command line:  -Xms256m -Xmx512m</span><br><span class="line"></span><br><span class="line">#查看某个flag</span><br><span class="line">[root@localhost bin]# ./jinfo -flag CICompilerCount 27463</span><br><span class="line">-XX:CICompilerCount=3</span><br><span class="line"></span><br><span class="line">#修改某个配置项值</span><br><span class="line">[root@localhost bin]# ./jinfo -flag CICompilerCount=4 27463</span><br><span class="line">#将配置项修改为false 禁用配置</span><br><span class="line">[root@localhost bin]# ./jinfo -flag -UseParallelGC 27463</span><br><span class="line">#将配置项修改为true 启用配置</span><br><span class="line">[root@localhost bin]# ./jinfo -flag +UseParallelGC 27463</span><br><span class="line"></span><br><span class="line">#查看jvm配置信息， 环境配置，系统配置 </span><br><span class="line">[root@localhost bin]# ./jinfo 27463</span><br><span class="line">Attaching to process ID 27463, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.172-b11</span><br><span class="line">Java System Properties:</span><br><span class="line"></span><br><span class="line">java.runtime.name = Java(TM) SE Runtime Environment</span><br><span class="line">java.vm.version = 25.172-b11</span><br><span class="line">sun.boot.library.path = /usr/local/src/jdk/jre/lib/amd64</span><br><span class="line">java.vendor.url = http://java.oracle.com/</span><br><span class="line">java.vm.vendor = Oracle Corporation</span><br><span class="line">path.separator = :</span><br><span class="line">file.encoding.pkg = sun.io</span><br><span class="line">java.vm.name = Java HotSpot(TM) 64-Bit Server VM</span><br><span class="line">sun.os.patch.level = unknown</span><br><span class="line">sun.java.launcher = SUN_STANDARD</span><br><span class="line">user.country = CN</span><br><span class="line">user.dir = /usr/local/agentManageAccount-dubbo/releases/20220406-170930</span><br><span class="line">java.vm.specification.name = Java Virtual Machine Specification</span><br><span class="line">java.runtime.version = 1.8.0_172-b11</span><br><span class="line">java.awt.graphicsenv = sun.awt.X11GraphicsEnvironment</span><br><span class="line">os.arch = amd64</span><br><span class="line">java.endorsed.dirs = /usr/local/src/jdk/jre/lib/endorsed</span><br><span class="line">java.io.tmpdir = /tmp</span><br><span class="line">line.separator = </span><br><span class="line"></span><br><span class="line">java.vm.specification.vendor = Oracle Corporation</span><br><span class="line">os.name = Linux</span><br><span class="line">sun.jnu.encoding = UTF-8</span><br><span class="line">java.library.path = /usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib</span><br><span class="line">java.specification.name = Java Platform API Specification</span><br><span class="line">java.class.version = 52.0</span><br><span class="line">sun.management.compiler = HotSpot 64-Bit Tiered Compilers</span><br><span class="line">os.version = 2.6.32-431.el6.x86_64</span><br><span class="line">user.home = /root</span><br><span class="line">user.timezone = PRC</span><br><span class="line">java.awt.printerjob = sun.print.PSPrinterJob</span><br><span class="line">file.encoding = UTF-8</span><br><span class="line">java.specification.version = 1.8</span><br><span class="line">user.name = root</span><br><span class="line">java.class.path = agentManageAccount-dubbo.jar</span><br><span class="line">java.vm.specification.version = 1.8</span><br><span class="line">sun.arch.data.model = 64</span><br><span class="line">sun.java.command = agentManageAccount-dubbo.jar</span><br><span class="line">java.home = /usr/local/src/jdk/jre</span><br><span class="line">user.language = zh</span><br><span class="line">java.specification.vendor = Oracle Corporation</span><br><span class="line">awt.toolkit = sun.awt.X11.XToolkit</span><br><span class="line">java.vm.info = mixed mode</span><br><span class="line">java.version = 1.8.0_172</span><br><span class="line">java.ext.dirs = /usr/local/src/jdk/jre/lib/ext:/usr/java/packages/lib/ext</span><br><span class="line">sun.boot.class.path = /usr/local/src/jdk/jre/lib/resources.jar:/usr/local/src/jdk/jre/lib/rt.jar:/usr/local/src/jdk/jre/lib/sunrsasign.jar:/usr/local/src/jdk/jre/lib/jsse.jar:/usr/local/src/jdk/jre/lib/jce.jar:/usr/local/src/jdk/jre/lib/charsets.jar:/usr/local/src/jdk/jre/lib/jfr.jar:/usr/local/src/jdk/jre/classes</span><br><span class="line">java.vendor = Oracle Corporation</span><br><span class="line">file.separator = /</span><br><span class="line">java.vendor.url.bug = http://bugreport.sun.com/bugreport/</span><br><span class="line">sun.io.unicode.encoding = UnicodeLittle</span><br><span class="line">sun.cpu.endian = little</span><br><span class="line">sun.cpu.isalist = </span><br><span class="line"></span><br><span class="line">VM Flags:</span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=3 -XX:InitialHeapSize=268435456 -XX:MaxHeapSize=536870912 -XX:MaxNewSize=178782208 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=89128960 -XX:OldSize=179306496 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC </span><br><span class="line">Command line:  -Xms256m -Xmx512m</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h3>堆转储浏览器-在堆转储文件(例如，由jmap -dump生成的文件)上启动web服务器，允许浏览堆。</li>
</ul>
<blockquote>
<p>使用 jhat file 查看。</p>
</blockquote>
<ul>
<li><h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p>打印给定进程或核心文件或远程调试服务器的共享对象内存映射或堆内存细节。</p>
</li>
<li><h3 id="jsadebugd"><a href="#jsadebugd" class="headerlink" title="jsadebugd"></a>jsadebugd</h3></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsadebugd pid [ server-id ]</span><br><span class="line">jsadebugd executable core [ server-id ]</span><br></pre></td></tr></table></figure>
<p>Java可服务性代理调试守护进程——附加到进程或核心文件，并充当调试服务器。</p>
<p>&nbsp;&nbsp;使用jinfo，jmap，jstack命令不仅可监控本地主机上的JVM进程，也可监控远端主机上的JVM进程，前者称为“本地模式”，后者称为“联网模式”。“联网模式”下的整个监控体系实质上是一个RMI应用程序。在“联网模式”下，一般情况下，远端主机上“运行rmiregistry服务，运行RMI Server”，本地主机上“运行RMI Client”，整个体系中“无需运行Web Server服务（因为所有相关类都可在本地获取）”。</p>
<p>&nbsp;&nbsp;如果rmiregistry没有启动，jsadebugd将在标准(1099)端口内部启动rmiregistry。可以通过向调试服务器发送SIGINT(按Ctrl-C)来停止调试服务器。</p>
<p>&nbsp;&nbsp;在远端主机上，通过运行jsadebugd命令开启RMI Server（需要注意的是，运行jsadebugd命令同时会自动运行rmiregistry服务，而无需手动运行），使用“PID”选项值指定远端主机上待被监控的JVM进程ID，使用“ServerId”选项值作为RMI Server内向rmiregistry服务注册所生成Remote Object实例的名称（如果未指定，则使用默认名称）；在本地主机上，运行jinfo，jmap，jstack命令作为RMI Client</p>
<blockquote>
<p>在远端主机上，执行jsadebugd -J-Djava.rmi.server.hostname=12.3.10.105 pid serviceID 命令开启RMI Server（同时开启rmiregistry服务），并使用“remoteObject1”名称向rmiregistry服务注册所生成的Remote Object实例</p>
</blockquote>
<blockquote>
<p>在本地主机上，执行jinfo/jmap/jstack <a href="mailto:&#115;&#x65;&#114;&#x76;&#x69;&#x63;&#101;&#x49;&#68;&#x40;&#x72;&#x65;&#109;&#x6f;&#x74;&#x65;&#x73;&#x65;&#114;&#118;&#101;&#114;&#46;&#104;&#111;&#x73;&#116;">&#115;&#x65;&#114;&#x76;&#x69;&#x63;&#101;&#x49;&#68;&#x40;&#x72;&#x65;&#109;&#x6f;&#x74;&#x65;&#x73;&#x65;&#114;&#118;&#101;&#114;&#46;&#104;&#111;&#x73;&#116;</a> 命令作为RMI Client与远端主机上的rmiregistry服务和RMI Server进行交互，而达到监控远端主机上相应JVM进程的目标。执行jinfo，jmap，jstack命令时可使用的选项参数可具体参考这些命令的“本地模式”用法</p>
</blockquote>
<ul>
<li><h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3>打印给定进程或核心文件或远程调试服务器的线程堆栈跟踪。</li>
</ul>
<h2 id="三-Java故障排除、分析、监控和管理工具"><a href="#三-Java故障排除、分析、监控和管理工具" class="headerlink" title="三. Java故障排除、分析、监控和管理工具"></a>三. Java故障排除、分析、监控和管理工具</h2><ul>
<li>###jcmd</li>
</ul>
<p>JVM诊断命令工具——向正在运行的Java虚拟机发送诊断命令请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jcmd [ options ]</span><br><span class="line"></span><br><span class="line">jcmd [ pid | main-class ] PerfCounter.print</span><br><span class="line"></span><br><span class="line">jcmd [ pid | main-class ] command [ arguments ]</span><br><span class="line"></span><br><span class="line">jcmd [ pid | main-class ] -f file</span><br></pre></td></tr></table></figure>

<blockquote>
<p>./jcmd -l #打印正在运行的Java进程及其进程id、主类和命令行参数的列表。<br>./jcmd 1055 help #查看进程1055可执行的命令 ，获取结果如下:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1055:</span><br><span class="line">The following commands are available:</span><br><span class="line">JFR.stop</span><br><span class="line">JFR.start</span><br><span class="line">JFR.dump</span><br><span class="line">JFR.check</span><br><span class="line">VM.native_memory</span><br><span class="line">VM.check_commercial_features</span><br><span class="line">VM.unlock_commercial_features</span><br><span class="line">ManagementAgent.stop</span><br><span class="line">ManagementAgent.start_local</span><br><span class="line">ManagementAgent.start</span><br><span class="line">VM.classloader_stats</span><br><span class="line">GC.rotate_log</span><br><span class="line">Thread.print</span><br><span class="line">GC.class_stats</span><br><span class="line">GC.class_histogram</span><br><span class="line">GC.heap_dump</span><br><span class="line">GC.finalizer_info</span><br><span class="line">GC.heap_info</span><br><span class="line">GC.run_finalization</span><br><span class="line">GC.run</span><br><span class="line">VM.uptime</span><br><span class="line">VM.dynlibs</span><br><span class="line">VM.flags</span><br><span class="line">VM.system_properties</span><br><span class="line">VM.command_line</span><br><span class="line">VM.version</span><br><span class="line">help</span><br></pre></td></tr></table></figure>
<blockquote>
<p>./jcmd 1055 GC.run #对进程1055 pid 执行GC.run 命令</p>
</blockquote>
<ul>
<li>###jconsole</li>
</ul>
<p>一个符合JMX标准的图形化工具，用于监控Java虚拟机。它可以监控本地和远程JVM。它还可以监控和管理应用程序。 有关更多信息，请参见Java平台的监控和管理。</p>
<ul>
<li>###jmc</li>
</ul>
<p>Java Mission Control (JMC)客户端包括监控和管理Java应用程序的工具，而不会引入通常与这些类型的工具相关的性能开销。</p>
<ul>
<li>###jvisualvm</li>
</ul>
<p>一个图形工具，当基于Java技术的应用程序(Java应用程序)在Java虚拟机中运行时，它提供有关这些应用程序的详细信息。Java VisualVM提供内存和CPU分析、堆转储分析、内存泄漏检测、MBeans访问和垃圾收集。有关更多信息，请参见Java VisualVM。</p>
<h2 id="四-程方法调用-RMI-工具"><a href="#四-程方法调用-RMI-工具" class="headerlink" title="四. 程方法调用(RMI)工具"></a>四. 程方法调用(RMI)工具</h2><h2 id="五-国际化工具"><a href="#五-国际化工具" class="headerlink" title="五. 国际化工具"></a>五. 国际化工具</h2><ul>
<li>###native2ascii</li>
</ul>
<blockquote>
<p>JAVA_HOME\bin\native2ascii -encoding GBK D:\src\resources.properties D:\classes\resources.properties</p>
</blockquote>
<p>native2ascii [options] [inputfile [outputfile]]</p>
<p>options：</p>
<p>-reverse</p>
<p>执行相反的操作:将采用Unicode转义的ISO-8859-1编码的文件转换为Java运行时环境支持的任何字符编码的文件</p>
<p>-encoding encoding_name</p>
<p>指定转换过程要使用的字符编码的名称。如果该选项不存在，则使用默认的字符编码(由Java.nio.charset.charset.default charset方法确定)。encoding_name字符串必须是Java运行时环境支持的字符编码的名称，<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/intl/encoding.doc.html">请参见支持的编码文档。</a></p>
<p>-Joption</p>
<p>将option传递给java虚拟机，其中option是Java应用程序启动程序参考页上描述的选项之一。例如，-J-Xms48m将启动内存设置为48兆字节</p>
<h2 id="六-基础工具"><a href="#六-基础工具" class="headerlink" title="六. 基础工具"></a>六. 基础工具</h2><h2 id="七-安全"><a href="#七-安全" class="headerlink" title="七. 安全"></a>七. 安全</h2><h2 id="八-脚本工具"><a href="#八-脚本工具" class="headerlink" title="八. 脚本工具"></a>八. 脚本工具</h2><p>jrunscript是一个命令行脚本shell。jrunscript支持交互式(读取-评估-打印)模式和批处理(-f选项)模式的脚本执行。这是一个脚本语言独立的外壳。默认情况下，JavaScript是使用的语言，但是-l选项可以用于指定不同的语言。通过Java到脚本语言的通信，jrunscript支持“探索性编程”风格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jrunscript</span><br><span class="line">js&gt; print(&#x27;Hello World\n&#x27;);</span><br><span class="line">Hello World</span><br><span class="line">js&gt; 34 + 55</span><br><span class="line">89.0</span><br><span class="line">js&gt; t = new java.lang.Thread(function() &#123; print(&#x27;Hello World\n&#x27;); &#125;)</span><br><span class="line">Thread[Thread-0,5,main]</span><br><span class="line">js&gt; t.start()</span><br><span class="line">js&gt; Hello World</span><br><span class="line"></span><br><span class="line">js&gt;</span><br></pre></td></tr></table></figure>

<p> <a href="https://docs.oracle.com/javase/7/docs/technotes/tools/share/jrunscript.html">参考文档</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Jprofiler</title>
    <url>/2022/07/18/java/jvm/jprofiler/</url>
    <content><![CDATA[<h1 id="1-核心组件"><a href="#1-核心组件" class="headerlink" title="1. 核心组件"></a>1. 核心组件</h1><p>JProfiler 包含用于采集目标 JVM 分析数据的 JProfiler agent、用于可视化分析数据的 JProfiler UI、提供各种功能的命令行工具.</p>
<p>它们之间的关系如下图所示:</p>
<img src="/2022/07/18/java/jvm/jprofiler/JPROFILER.png" class="" title="JPROFILER架构图">

<h3 id="JProfiler-agent"><a href="#JProfiler-agent" class="headerlink" title="JProfiler agent"></a>JProfiler agent</h3><p>JProfiler agent 是一个本地库，它可以在 JVM 启动时通过参数-agentpath:<path to native library>进行加载或者在程序运行时通过 JVM Attach 机制进行加载。Agent 被成功加载后，会设置 JVMTI 环境，监听虚拟机产生的事件，如类加载、线程创建等。例如，当它监听到类加载事件后，会给这些类注入用于执行度量操作的字节码。</p>
<h3 id="JProfiler-UI"><a href="#JProfiler-UI" class="headerlink" title="JProfiler UI"></a>JProfiler UI</h3><p>JProfiler UI 是一个可独立部署的组件，它通过 socket 和 agent 建立连接。这意味着不论目标 JVM 运行在本地还是远端，JProfiler UI 和 agent 间的通信机制都是一样的。</p>
<p>JProfiler UI 的主要功能是展示通过 agent 采集上来的分析数据，此外还可以通过它控制 agent 的采集行为，将快照保存至磁盘，展示保存的快照。</p>
<h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><p>JProfiler 提供了一系列命令行工具以实现不同的功能。</p>
<p>jpcontroller - 用于控制 agent 的采集行为。它通过 agent 注册的 JProfiler MBean 向 agent 传递命令。</p>
<p>jpenable - 用于将 agent 加载到一个正在运行的 JVM 上。</p>
<p>jpdump - 用于获取正在运行的 JVM 的堆快照。</p>
<p>jpexport &amp; jpcompare - 用于从保存的快照中提取数据并创建 HTML 报告。</p>
<p>要想对一个JVM进行分析，JProfiler的分析代理必须被加载到该JVM中。这可以通过两种不同的方式实现： 通过在启动脚本中指定一个-agentpath VM参数，或者通过Attach API将代理加载到已经运行的JVM中</p>
<p>两种模式JProfiler都支持。添加VM参数是分析的首选方式，集成向导、IDE插件和从JProfiler内启动JVM的会话配置都使用这种方式。 Attach既可在本地使用，也可通过SSH远程使用。</p>
<h1 id="2-JProfiler-设置"><a href="#2-JProfiler-设置" class="headerlink" title="2. JProfiler 设置"></a>2. JProfiler 设置</h1><h2 id="数据采集模式"><a href="#数据采集模式" class="headerlink" title="数据采集模式"></a>数据采集模式</h2><p>JProfier 提供两种数据采集模式 Sampling 和 Instrumentation。</p>
<ol>
<li><p>Sampling（采样） - 适合于不要求数据完全精确的场景。优点是对系统性能的影响较小，缺点是某些特性不支持（如方法级别的统计信息）</p>
</li>
<li><p>Instrumentation（仪表） - 完整功能模式，统计信息也是精确的。缺点是如果需要分析的类比较多，对应用性能影响较大。为了降低影响，往往需要和 Filter 一起使用</p>
</li>
</ol>
<h2 id="应用启动模式"><a href="#应用启动模式" class="headerlink" title="应用启动模式"></a>应用启动模式</h2><p>通过为 JProfiler agent 指定不同的参数可以控制应用的启动模式。</p>
<ol>
<li><p>等待模式 - 只有在 Jprofiler GUI 和 agent 建立连接并完成分析配置设置后，应用才会真正启动。在这种模式下，您能够获取应用启动时期的分析数据。对应的命令为-agentpath:<path to native library>=port=8849</p>
</li>
<li><p>立即启动模式 - 应用会立即启动，Jprofiler GUI 会在需要时和 agent 建立连接并设置分析配置。这种模式相对灵活，但会丢失应用启动初期的分析数据。对应的命令为-agentpath:<path to native library>=port=8849,nowait。</p>
</li>
</ol>
<h1 id="3-agentpath-VM参数-启动profiler-agent"><a href="#3-agentpath-VM参数-启动profiler-agent" class="headerlink" title="3. -agentpath VM参数 启动profiler agent"></a>3. -agentpath VM参数 启动profiler agent</h1><p>-agentpath是JVM提供的一个通用VM参数，用于加载任何一种使用JVMTI接口的本地库。 由于分析接口JVMTI是一个本地接口，所以分析代理必须是一个本地库。这意味着你只能在 明确支持的平台上进行分析。 32位和64位JVM也需要不同的本地库。另外，Java代理是用-javaagent VM参数加载的，并且只能访问有限的功能。</p>
<p>在-agentpath: 后面附加本地库的完整路径名。有一个等效参数-agentlib:， 你只需要指定特定平台的库名，但必须确保库路径中包含该库。在库的路径之后，你可以添加一个等号，并向代理传递选项，用逗号隔开。例如，在Linux上，整个参数看起来可能像这样：</p>
<blockquote>
<p>-agentpath:/opt/jprofiler10/bin/linux-x64/libjprofilerti.so=port=8849,nowait</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># jprofiler agent配置</span><br><span class="line">nohup java -agentpath:/usr/local/src/jprofiler12.0.4/bin/linux-x64/libjprofilerti.so=port=8849,nowait -jar -Xms256m -Xmx256m  ./$RESOURCE_NAME id.properties  &gt;/dev/null 2&gt;&amp;1  &amp;</span><br></pre></td></tr></table></figure>

<p>第一个等号将路径名与参数分开，第二个等号是参数port=8849 的一部分。 这个常用参数定义了分析代理监听来自JProfiler GUI连接的端口，实际上8849是默认端口，所以也可以省略这个参数。 如果你想在同一台机器上分析多个JVM，必须分配不同端口， 不过IDE插件和本地启动的会话会自动分配这个端口，对于集成向导，你必须显式选择端口。</p>
<p>第二个参数nowait告诉分析代理不要在启动时为了等待JProfiler GUI连接而阻塞JVM。 启动时的阻塞是默认的，因为分析代理不是以命令行参数的形式接收其分析设置，而是从JProfiler GUI或配置文件接收。 命令行参数仅用于引导分析代理，告诉它如何启动和传递调试标记。</p>
<p>默认情况下，JProfiler代理将通信Socket绑定到所有可用的网络接口。如果出于安全原因不希望这样做， 你可以添加选项address=[IP地址]以便选择指定接口，或loopback 只监听来自本地机器的请求。对于通过JProfiler UI启动的或通过IDE集成的JVM，会自动添加loopback</p>
<h1 id="4-jpenable-将-agent-加载到一个正在运行的-JVM-上"><a href="#4-jpenable-将-agent-加载到一个正在运行的-JVM-上" class="headerlink" title="4. jpenable 将 agent 加载到一个正在运行的 JVM 上"></a>4. jpenable 将 agent 加载到一个正在运行的 JVM 上</h1><ol>
<li><p>服务器运行 jpenable</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[root@localhost bin]# ./jpenable </span><br><span class="line">选择一个 JVM:</span><br><span class="line">org.apache.catalina.startup.Bootstrap start [6221] [1]</span><br><span class="line">org.apache.catalina.startup.Bootstrap start [9791] [2]</span><br><span class="line">org.elasticsearch.bootstrap.Elasticsearch -d [11417] [3]</span><br><span class="line">agentManageInternetCard-dubbo.jar [11778] [4]</span><br><span class="line">agentManageKafka-dubbo.jar [19613] [5]</span><br><span class="line">org.apache.catalina.startup.Bootstrap start [20276] [6]</span><br><span class="line">org.apache.catalina.startup.Bootstrap start [22974] [7]</span><br><span class="line">./agentManageJob.jar [24583] [8]</span><br><span class="line">./account-Job-1.0-SNAPSHOT.jar /us...project/job/id.properties [26293] [9]</span><br><span class="line">agentManageJobOrder-dubbo.jar [26438] [10]</span><br><span class="line">sun.tools.jstatd.Jstatd -p 10000 [27456] [11]</span><br><span class="line">agentManageAccount-dubbo.jar [27463] [12]</span><br><span class="line"></span><br><span class="line">8  # 选择添加agnet的进程</span><br><span class="line"></span><br><span class="line">请选择分析模式:</span><br><span class="line">GUI模式(与 JProfiler GUI Attach) [1, 回车(Enter)]</span><br><span class="line">离线模式(使用配置文件去设置分析设置) [2]</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">请输入分析端口</span><br><span class="line">[39923]</span><br><span class="line">1234</span><br><span class="line">你现在可以使用 JProfiler GUI 连接端口 1234</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Jprofiler ui Attach 到远程agnet</p>
</li>
</ol>
<img src="/2022/07/18/java/jvm/jprofiler/jenable.png" class="" title="jenable">

<p><a href="https://zhuanlan.zhihu.com/p/54274894">参考文档</a></p>
<p><a href="https://www.ej-technologies.com/resources/jprofiler/help_zh_CN/doc/main/architecture.html">官方帮助文档</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM监控工具</title>
    <url>/2022/07/14/java/jvm/monitortool/</url>
    <content><![CDATA[<h1 id="JVM运行监控"><a href="#JVM运行监控" class="headerlink" title="JVM运行监控"></a>JVM运行监控</h1><ol>
<li>java自带工具命令</li>
<li>Eclipse Memory Analyzer</li>
<li>JMX Jstatd - Jconsole VisualVm</li>
<li>Btrace </li>
<li>火焰图</li>
<li>Flight Recorder  JavaMissionControl</li>
<li>JProfiler</li>
</ol>
<blockquote>
<p>监控整个集群的各项资源的使用情况以及各个服务的存活情况</p>
</blockquote>
<blockquote>
<p>监控代码问题导致的线程死锁，OOM</p>
</blockquote>
<h1 id="JMX-Jstatd-服务及Jconsole-VisualVm"><a href="#JMX-Jstatd-服务及Jconsole-VisualVm" class="headerlink" title="JMX Jstatd 服务及Jconsole VisualVm"></a>JMX Jstatd 服务及Jconsole VisualVm</h1><ol>
<li><p>JMX:使用JMX需要远程JVM在启动的时候开启远程访问支持，设定JMX端口等，每一个JMX连接一个远程JVM。</p>
</li>
<li><p>JStatD:使用jstatd连接方式时，需要在远程主机上创建安全策略文件然后启动jstatd进程，并且此进程需要一直保持运行状态,<strong>客户端可以看到远程主机上当前用户的所有JVM的信息</strong>，即只要创建一个jstatd连接</p>
</li>
</ol>
<h2 id="JMX方式"><a href="#JMX方式" class="headerlink" title="JMX方式"></a>JMX方式</h2><p>JMX，是Java Management Extensions(Java管理扩展)的缩写，是一个为应用程序植入管理功能的框架。用户可以在任何Java应用程序中使用这些代理和服务实现管理（Mbean）</p>
<p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/agent.html#:~:text=Using%20File-Based%20Password%20Authentication%201%20Copy%20the%20password,and%20rename%20it%20to%20jmxremote.password.%20More%20items...%20">管方说明</a></p>
<img src="/2022/07/14/java/jvm/monitortool/jmxstracture.jpg" class="" title="JMX架构">

<h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><table>
<thead>
<tr>
<th align="left">配置</th>
<th align="left">功能</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-Dcom.sun.management.jmxremote=true</td>
<td align="left">相关 JMX 代理侦听开关</td>
<td align="left">true / false. Default is true.</td>
</tr>
<tr>
<td align="left">-Djava.rmi.server.hostname</td>
<td align="left">服务器端的IP</td>
<td align="left">服务ip</td>
</tr>
<tr>
<td align="left">-Dcom.sun.management.jmxremote.rmi.port=1000</td>
<td align="left">rmi端口</td>
<td align="left">默认随机</td>
</tr>
<tr>
<td align="left">-Dcom.sun.management.jmxremote.port=29094</td>
<td align="left">相关 JMX 代理侦听请求的端口</td>
<td align="left">Port number. No default.</td>
</tr>
<tr>
<td align="left">-Dcom.sun.management.jmxremote.authenticate=false</td>
<td align="left">指定是否需要密码验证</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">-Dcom.sun.management.jmxremote.password.file=JRE_HOME/lib/management/jmxremote.password</td>
<td align="left">密码认证文件，可自行指定，不指定在默认位置</td>
<td align="left">JRE_HOME/lib/management/ jmxremote.password</td>
</tr>
<tr>
<td align="left">-Dcom.sun.management.jmxremote.access.file=JRE_HOME/lib/management/jmxremote.access</td>
<td align="left">权限控制文件，可自行指定，不指定在默认位置</td>
<td align="left">JRE_HOME/lib/management/jmxremote.access</td>
</tr>
<tr>
<td align="left">-Dcom.sun.management.jmxremote.ssl</td>
<td align="left">指定是否使用 SSL 通讯</td>
<td align="left">true / false. Default is true.</td>
</tr>
<tr>
<td align="left">-Dcom.sun.management.jmxremote.registry.ssl</td>
<td align="left">Binds the RMI connector stub to an RMI registry protected by SSL.</td>
<td align="left">true / false. Default is false.</td>
</tr>
<tr>
<td align="left">-Dcom.sun.management.jmxremote.ssl.enabled.protocols</td>
<td align="left">A comma-delimited list of SSL/TLS protocol versions to enable. Used in conjunction with com.sun.management.jmxremote.ssl.</td>
<td align="left">Default SSL/TLS protocol version.</td>
</tr>
<tr>
<td align="left">-Dcom.sun.management.jmxremote.ssl.enabled.cipher.suitese</td>
<td align="left">A comma-delimited list of SSL/TLS cipher suites to enable. Used in conjunction with com.sun.management.jmxremote.ssl.</td>
<td align="left">Default SSL/TLS cipher suites.</td>
</tr>
<tr>
<td align="left">-Dcom.sun.management.jmxremote.ssl.need.client.auth</td>
<td align="left">If this property is true and the property com.sun.management.jmxremote.ssl is also true, then client authentication will be performed. It is recommended that you set this property to true.</td>
<td align="left">true / false. Default is false.</td>
</tr>
<tr>
<td align="left">-Dcom.sun.management.jmxremote.login.config</td>
<td align="left">Specifies the name of a Java Authentication and Authorization Service (JAAS) login configuration entry to use when the JMX agent authenticates users. When using this property to override the default login configuration, the named configuration entry must be in a file that is loaded by JAAS. In addition, the login modules specified in the configuration should use the name and password callbacks to acquire the user’s credentials. For more information, see the API documentation for javax.security.auth.callback.NameCallback and javax.security.auth.callback.PasswordCallback.</td>
<td align="left">Default login configuration is a file-based password authentication.</td>
</tr>
</tbody></table>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">JAVA_OPTS=&quot;</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">JAVA_OPTS</span> </span><br><span class="line">-Djava.rmi.server.hostname=127.0.0.1</span><br><span class="line">-Dcom.sun.management.jmxremote.port=10000       </span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false    # Disabling SSL</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=true # Disabling Security</span><br><span class="line">&quot;</span><br></pre></td></tr></table></figure>

<p>远程监控和管理需要安全性，以确保未经授权的人无法控制或监控您的应用程序。默认情况下，启用安全套接字层(SSL)和传输层安全性(TLS)上的密码身份验证。您可以分别禁用密码验证和SSL    </p>
<h3 id="密码认证"><a href="#密码认证" class="headerlink" title="密码认证"></a>密码认证</h3><p>JMX支持多种认证方式 使用LDAP认证，基于文件的密码认证，也可以禁用密码认证</p>
<h5 id="禁用密码及禁用ssl"><a href="#禁用密码及禁用ssl" class="headerlink" title="禁用密码及禁用ssl"></a>禁用密码及禁用ssl</h5><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote.ssl=false    # Disabling SSL</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false # Disabling Security</span><br></pre></td></tr></table></figure>

<h5 id="基于文件的密码认证"><a href="#基于文件的密码认证" class="headerlink" title="基于文件的密码认证"></a>基于文件的密码认证</h5><p><strong>环境类型</strong></p>
<ol>
<li>单用户环境</li>
</ol>
<p>To Set up a Single-User Environment</p>
<p>You set up the password file in the JRE_HOME/lib/management directory as follows.</p>
<p>Copy the password template file, jmxremote.password.template, to jmxremote.password.</p>
<p>Set file permissions so that only the owner can read and write the password file.</p>
<p>Add passwords for roles such as monitorRole and controlRole.</p>
<ol start="2">
<li>多用户环境<br>To Set up a Multiple-User Environment</li>
</ol>
<p>You set up the password file in the JRE_HOME/lib/management directory as follows.</p>
<p>Copy the password template file, jmxremote.password.template, to your home directory and rename it to jmxremote.password.</p>
<p>Set file permissions so that only you can read and write the password file.</p>
<p>Add passwords for the roles such as monitorRole and controlRole.</p>
<p>Set the following system property when you start the Java VM.</p>
<p>com.sun.management.jmxremote.password.file=pwFilePath</p>
<p>In the above property, pwFilePath is the path to the password file.</p>
<p><strong>文件配置</strong><br>密码文件定义了不同的角色及其密码。访问控制文件(默认为jmxremote.access)定义了每个角色允许的访问权限。要发挥作用，角色必须在密码和访问文件中都有一个条目。</p>
<ol>
<li>密码文件 </li>
</ol>
<ul>
<li><p>模板文件位置 jdk/jre/lib/management/jmxremote.password.template</p>
</li>
<li><p>拷贝template文件到 JRE_HOME/lib/management/jmxremote.password 或者 你的用户目录, 为文件里的角色添加密码</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># specify actual password instead of the text password</span><br><span class="line">monitorRole password</span><br><span class="line">controlRole password</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod 600 jmxremote.password</span><br></pre></td></tr></table></figure>

<p><em><strong>您必须确保只有所有者拥有该文件的读写权限，因为它包含明文形式的密码。出于安全原因，系统会检查文件是否只对所有者可读，如果不可读，则返回错误退出。因此，在多用户环境中，您应该将密码文件存储在私有位置，如您的主目录</strong></em></p>
<ol start="2">
<li>访问控制文件</li>
</ol>
<ul>
<li><p>访问文件定义了角色及其访问级别。默认情况下，access文件定义了以下两个主要角色。</p>
<p> monitorRole, 它授予监视的只读访问权限</p>
<p> controlRole, 它授予监视和管理的读写权限</p>
</li>
<li><p>访问控制条目由角色名称和关联的访问级别组成。角色名不能包含空格或制表符，并且必须对应于密码文件中的条目。访问级别可以是下列之一。</p>
<p> readonly,   它授予读取MBean属性的权限。对于监控，这意味着这个角色的远程客户端可以读取测量值，但是不能执行任何改变运行程序环境的操作。远程客户端也可以监听MBean通知    </p>
<p> readwrite, 它授予读取和写入MBean属性、调用对它们的操作以及创建或删除它们的权限。这种访问应该只授予受信任的客户端，因为它们可能会干扰应用程序的操作。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># The &quot;monitorRole&quot; role has readonly access.</span><br><span class="line"># The &quot;controlRole&quot; role has readwrite access.</span><br><span class="line">monitorRole readonly</span><br><span class="line">controlRole readwrite</span><br></pre></td></tr></table></figure>

<p><em><strong>默认情况下，access文件命名为jmxremote.access。属性名是来自与密码文件相同空间的标识。关联的值必须是readonly或readwrite。</strong></em></p>
<blockquote>
<p>注意:</p>
</blockquote>
<blockquote>
<p>可以在management.properties文件中指定 com.sun.management.jmxremote.* 属性，而不是在命令行中传递它们。<br>在这种情况下，需要系统属性-Dcom.sun.management.config.file=management.properties来指定management . properties文件的位置</p>
</blockquote>
<h2 id="Jstatd-方式"><a href="#Jstatd-方式" class="headerlink" title="Jstatd 方式"></a>Jstatd 方式</h2><p>jstatd工具是一个RMI服务器应用程序，它监视被检测的HotSpot Java虚拟机(JVM)的创建和终止，并提供一个接口，允许远程监视工具连接到在本地主机上运行的JVM</p>
<p>jstatd服务器要求本地主机上存在RMI注册表。jstatd服务器将尝试在默认端口或-p port选项指示的端口上连接到RMI注册表。如果没有找到RMI注册中心，将在jstatd应用程序中创建一个，绑定到-p port选项指定的端口，或者如果省略-p port，则绑定到默认的RMI注册中心端口。可以通过指定-nr选项来禁止创建内部RMI注册表。</p>
<blockquote>
<p>注册表其实不用写任何代码，在你的JAVA_HOME下bin目录下有一个rmiregistry程序，需要在你的程序的classpath下运行该程序</p>
</blockquote>
<h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><ul>
<li>-nr</li>
</ul>
<p>如果没有找到现有的RMI注册中心，不要试图在jstatd进程中创建内部RMI注册中心</p>
<ul>
<li>-p  port</li>
</ul>
<p>期望在其中找到RMI注册表的端口号，或者，如果没有找到，则在没有指定-nr的情况下创建。</p>
<ul>
<li>-n  rminame</li>
</ul>
<p>远程RMI对象在RMI注册表中绑定到的名称。默认名称为JStatRemoteHost。如果在同一台主机上启动了多个jstatd服务器，那么通过指定这个选项，可以使每个服务器的导出RMI对象的名称是唯一的。但是，这样做需要在监控客户端的hostid和vmid字符串中包含唯一的服务器名称</p>
<ul>
<li>-Joption</li>
</ul>
<p>将选项传递给javac调用的java启动器。例如，-J-Xms48m将启动内存设置为48兆字节。对于-J来说，将选项传递给执行用Java编写的应用程序的底层VM是一个常见的约定。</p>
<h3 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a>安全配置</h3><p>jstatd服务器只能监视它拥有适当的本地访问权限的JVM。因此，jstatd进程必须使用与目标JVM相同的用户凭证运行。一些用户凭证，例如基于UNIX的系统中的root用户，有权访问系统上任何JVM导出的工具。使用这种凭证运行的jstatd进程可以监控系统上的任何JVM，但是会引入额外的安全问题。</p>
<p>jstatd服务器不提供任何远程客户端的身份验证。因此，运行jstatd服务器进程会向网络上的任何用户公开jstatd进程对其拥有访问权限的所有JVM的检测导出。这种暴露在您的环境中可能是不希望的，在启动jstatd进程之前应该考虑本地安全策略，尤其是在生产环境或不安全的网络中</p>
<p>如果没有安装其他安全管理器，jstatd服务器将安装RMISecurityPolicy的实例，因此需要指定安全策略文件。策略文件必须符合默认策略实现的策略文件语法</p>
<p>以下策略文件将允许jstatd服务器在没有任何安全异常的情况下运行。与授予所有代码库所有权限相比，此策略不够自由，但比授予运行jstatd服务器的最低权限的策略更自由。</p>
<ul>
<li><p>jstatd -J-Djava.security.policy=jstatd.all.policy</p>
</li>
<li><p>文件位置  jdk/bin/jstatd.all.policy</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant codebase &quot;file:$&#123;java.home&#125;/../lib/tools.jar&quot; &#123;</span><br><span class="line">   permission java.security.AllPermission;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h3><ul>
<li>使用内部RMI注册表</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jstatd -J-Djava.security.policy=all.policy</span><br></pre></td></tr></table></figure>

<ul>
<li>使用外部注册表</li>
</ul>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line">rmiregistry&amp;</span><br><span class="line">jstatd -J-Djava.security.policy=all.policy</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个例子演示了在端口2020上用外部RMI注册服务器启动jstatd。</span></span><br><span class="line">rmiregistry 2020&amp;</span><br><span class="line">jstatd -J-Djava.security.policy=all.policy -p 2020</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个例子演示了在端口2020上用一个外部RMI注册表启动jstatd，绑定到名为AlternateJstatdServerName。</span></span><br><span class="line">rmiregistry 2020&amp;</span><br><span class="line">jstatd -J-Djava.security.policy=all.policy -p 2020 -n AlternateJstatdServerName</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这个例子演示了如何启动jstatd，如果没有找到RMI注册表，它就不会创建RMI注册表。这个例子假设RMI注册表已经在运行。如果不是，则会发出适当的错误消息。</span></span><br><span class="line">jstatd -J-Djava.security.policy=all.policy -nr</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个例子演示了在启用RMI日志功能的情况下启动jstatd。这项技术有助于故障排除或监控服务器活动</span></span><br><span class="line">jstatd -J-Djava.security.policy=all.policy -J-Djava.rmi.server.logCalls=true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>jvm参数配置</title>
    <url>/2022/07/25/java/jvm/parallel/</url>
    <content><![CDATA[<img src="/2022/07/25/java/jvm/parallel/jvmmap.png" class="" title="jvmmap">

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-Xms1g</span><br><span class="line">-Xmx2g</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=70</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction=0</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection</span><br><span class="line">-XX:ParallelGCThreads=4</span><br></pre></td></tr></table></figure>

<hr>
<p>Serial垃圾收集器（新生代） 新生代使用Serial  老年代则使用SerialOld     </p>
<blockquote>
<p>开启：-XX:+UseSerialGC 关闭：-XX:-UseSerialGC</p>
</blockquote>
<blockquote>
<blockquote>
<p>SerialOld收集器(串行老年代) 搭配Parallel Scavenge使用  及  CMS发生Concurrent Mode Failure之后的预案</p>
</blockquote>
</blockquote>
<p>ParNew垃圾收集器（新生代） 新生代使用功能ParNew 老年代则使用功能CMS</p>
<blockquote>
<p>开启 -XX:+UseParNewGC 关闭 -XX:-UseParNewGC</p>
</blockquote>
<p>Parallel Scavenge收集器（新生代） 新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</p>
<blockquote>
<p>开启 -XX:+UseParallelGC 关闭 -XX:-UseParallelGC </p>
</blockquote>
<hr>
<p>ParallelOld垃圾收集器（老年代） 新生代使用功能Parallel Scavenge 老年代将会使用Parallel Old收集器</p>
<blockquote>
<p>开启 -XX:+UseParallelOldGC 关闭 -XX:-UseParallelOldGC</p>
</blockquote>
<p>CMS垃圾收集器（老年代）  新生代使用功能ParNew 老年代则使用功能CMS 老年代担保失败 则采用SerialOld收集器串行收集</p>
<blockquote>
<p>开启 -XX:+UseConcMarkSweepGC 关闭 -XX:-UseConcMarkSweepGC</p>
</blockquote>
<p> G1垃圾收集器</p>
<blockquote>
<p>开启 -XX:+UseG1GC 关闭 -XX:-UseG1GC</p>
</blockquote>
<hr>
<h3 id="对象的一些配置"><a href="#对象的一些配置" class="headerlink" title="对象的一些配置"></a>对象的一些配置</h3><ul>
<li>-XX:+UseTLAB  开启本地线程预分配</li>
<li>-XX:InitialTenuringThreshol=7  年轻代对象转换为老年代对象最小年龄值，默认值7</li>
<li>-XX:MaxTenuringThreshold=15 进入老年代最大的GC年龄 年轻代对象转换为老年代对象最大年龄值，默认值15</li>
</ul>
<blockquote>
<p>动态年龄判断：</p>
<blockquote>
<p>虚拟机不是永远要去对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄</p>
</blockquote>
</blockquote>
<ul>
<li>-XX:PretenureSizeThreshold=1000000 新生代可容纳的最大对象，超过此值直接进入老年代</li>
</ul>
<h3 id="内存空间的配置"><a href="#内存空间的配置" class="headerlink" title="内存空间的配置"></a>内存空间的配置</h3><ul>
<li>-Xms2g：初始堆空间内存 （默认为物理内存的1/64）</li>
<li>-Xmx2g：最大堆空间内存（默认为物理内存的1/4）</li>
<li>-Xmn512m：设置新生代的大小。(初始值及最大值)</li>
<li>-Xss512k：线程堆栈大小</li>
<li>-XX:MetaspaceSize ：初始化的Metaspace大小</li>
<li>-XX:MaxMetaspaceSize：Metaspace最大值</li>
<li>-XX:NewRatio=2：配置新生代与老年代在堆结构的占比 老年代:新生代 = 2:1 ，新生代占整个堆的1/3</li>
<li>-XX:SurvivorRatio=8：设置新生代中Eden和S0/S1空间的比例 eden:S = 8:1</li>
<li>-XX:MaxTenuringThreshold=15：设置新生代垃圾的最大年龄</li>
<li>-XX:+PrintGCDetails：输出详细的GC处理日志</li>
<li>打印gc简要信息：① -XX:+PrintGC   ② -verbose:gc</li>
<li>-XX:HandlePromotionFailure=true：是否设置空间分配担保</li>
<li>-XX:MaxDirectMemorySize=2g：堆外直内存配置</li>
</ul>
<blockquote>
<p>空间分配担保：</p>
<blockquote>
<p>jdk6之前在发生minorGc之前，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么MinorGc可以确保安全，如果不成立，虚拟机会查看-XX:HandlePromotionFailure<br>jdk7及以后只要老年代的连续空间大于新生代对象的总大小或者历次晋升到老年代的对象的平均大小就进行MinorGC，否则FullGC，HandlePromotionFailure 不再使用</p>
</blockquote>
</blockquote>
<h3 id="并发标记清除收集器相关配置"><a href="#并发标记清除收集器相关配置" class="headerlink" title="并发标记清除收集器相关配置"></a>并发标记清除收集器相关配置</h3><ul>
<li>-XX:+UseConcMarkSweepGC ：打开CMS收集器 新生代默认使用ParNewGc, 担保失败使用SerialOld</li>
<li>-XX:+UseCMSInitiatingOccupancyOnly ： 指定用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction参数的值),如果不指定,JVM仅在第一次使用设定值,后续则会根据运行时采集的数据做自动调整，如果指定了该参数，那么每次JVM都会在到达规定设定值时才进行GC</li>
<li>-XX:CMSInitiatingOccupancyFraction=75 ：老年代被使用的内存空间的阈值，达到该阈值则触发Full GC 75%</li>
<li>-XX:CMSFullGCsBeforeCompaction=0 ：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</li>
<li>-XX:+UseCMSCompactAtFullCollection ：在FullGc后进行整理压缩操作 打开压缩功能</li>
</ul>
<h3 id="垃圾收集线程"><a href="#垃圾收集线程" class="headerlink" title="垃圾收集线程"></a>垃圾收集线程</h3><ul>
<li>-XX:ParallelGCThreads=20 ：并发收集线程数</li>
</ul>
<h3 id="Parallel-收集器-关注吞吐量"><a href="#Parallel-收集器-关注吞吐量" class="headerlink" title="Parallel 收集器 关注吞吐量"></a>Parallel 收集器 关注吞吐量</h3><p>-XX:+UseParallelGC 使用Parallel Scavenge + Serial Old组合收集器  新生代</p>
<p>-XX:+UseParallelOldGC 使用Parallel Scavenge +Parallel Old组合收集器 老年代</p>
<p>-XX:+UseAdaptiveSizePolicy  自适应调节策略 配合 -XX:MaxGCPauseMillis -XX:GCTimeRatio 使用,主要控制新生代收集</p>
<p>-XX:MaxGCPauseMillis=100  控制最大垃圾收集停顿时间 值是一个大于0的毫秒数</p>
<p>-XX:GCTimeRatio=99 直接设置吞吐量大小 大于0且小于100的整数 如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（既1 /（1 + 19）），默认值为99，就是允许最大1%（既 1 /（1 + 99））的垃圾收集时间</p>
<hr>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>一次tomcat假死问题排查</title>
    <url>/2022/07/13/java/tomcat/tomcat_die/</url>
    <content><![CDATA[<p>#Tomcat 假死问题排查思路</p>
<h3 id="Jvm内存问题及线程问题排查"><a href="#Jvm内存问题及线程问题排查" class="headerlink" title="Jvm内存问题及线程问题排查"></a>Jvm内存问题及线程问题排查</h3><ol>
<li>JVM内存使用情况查看 </li>
</ol>
<blockquote>
<p>jmap -heap pid</p>
</blockquote>
<blockquote>
<p>jmap -dump:live,format=b,file=/home/xxxx.hprof pid</p>
</blockquote>
<blockquote>
<p>jmap -histo:live 27151</p>
</blockquote>
<blockquote>
<p>jmap -histo 18230 | sort -n -r -k 2 | head -10  //统计实例最多的类 前十位有哪些</p>
</blockquote>
<blockquote>
<p>jmap -histo 18230 | sort -n -r -k 3 | head -10  //统计合计容量前十的类有哪些  </p>
</blockquote>
<blockquote>
<p>jstat -gcutil pid 1000 3 //监控gc 状态</p>
</blockquote>
<blockquote>
<p>jinfo -flags pid // 查看tomcatJVM配置参数</p>
</blockquote>
<ol start="2">
<li>线程栈问题提取 检查是否有锁问题</li>
</ol>
<blockquote>
<p>./jstack pid |grep http-nio-8090-exec （请求处理线程，可以检查处理线程卡在了哪里）<br>./jstack -l pid</p>
<blockquote>
<p>打印关于锁的其他信息，比如拥有的java.util.concurrent ownable同步器的列表。</p>
</blockquote>
</blockquote>
<blockquote>
<p>jstack -F pid</p>
<blockquote>
<p>当 jstack [-l] pid 没有响应时，强制打印一个堆栈转储。</p>
</blockquote>
</blockquote>
<ol start="3">
<li>查看tomcat进程内线程</li>
</ol>
<blockquote>
<p>ps -Lf –pid 16139 |wc -l</p>
<blockquote>
<p> 统计该tomcat进程内的线程个数 </p>
</blockquote>
</blockquote>
<blockquote>
<p>pstree -p 16139 |wc -l</p>
<blockquote>
<p>统计该tomcat进程内的线程个数 </p>
</blockquote>
</blockquote>
<ol start="4">
<li>查看进程打开的TCP链接的连接数</li>
</ol>
<blockquote>
<p>netstat -anpt|grep pid  -c</p>
</blockquote>
<ol start="5">
<li>查看端口的TCP连接数</li>
</ol>
<blockquote>
<p>  netstat -anpt|grep port -c</p>
</blockquote>
<h3 id="Tomcat相关配置"><a href="#Tomcat相关配置" class="headerlink" title="Tomcat相关配置"></a>Tomcat相关配置</h3><ol>
<li>catalina.sh 相关配置</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">JAVA_OPTS</span>=<span class="string">&quot;-server </span></span><br><span class="line"><span class="attr">-Dfile.encoding</span>=<span class="string">UTF-8 </span></span><br><span class="line"><span class="attr">-Xms2048m</span> <span class="string"></span></span><br><span class="line"><span class="attr">-Xmx2048m</span></span><br><span class="line"><span class="attr">-Xloggc</span>:<span class="string">/home/tomcat/images/gclogs/cms-gc-150.log</span></span><br><span class="line"><span class="attr">-verbose</span>:<span class="string">gc -XX:+PrintGCDetails</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintGCDateStamps</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+UseGCLogFileRotation</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+PrintGCApplicationStoppedTime</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">NumberOfGCLogFiles=10</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">GCLogFileSize=100M</span></span><br><span class="line"><span class="attr">-Dlog4j2.formatMsgNoLookups</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+UseConcMarkSweepGC</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">CMSInitiatingOccupancyFraction=75</span></span><br><span class="line"><span class="attr">-XX</span>:<span class="string">+UseCMSInitiatingOccupancyOnly</span></span><br><span class="line"><span class="attr">&quot;</span></span><br></pre></td></tr></table></figure>


<ol start="2">
<li>垃圾回收器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=<span class="number">75</span></span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly </span><br></pre></td></tr></table></figure>

<p>-XX:+UseConcMarkSweepGC<br>表示年轻代使用 ParNew，老年代的用 CMS 垃圾回收器</p>
<p>-XX:CMSInitiatingOccupancyFraction=75 </p>
<p>由于 CMS 在执行过程中，用户线程还需要运行，那就需要保证有充足的内存空间供用户使用。<br>如果等到老年代空间快满了，再开启这个回收过程，用户线程可能会产生“Concurrent Mode Failure”的错误，这时会临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，<br>这样停顿时间就很长了（STW）。这部分空间预留，一般在 30% 左右即可，那么能用的大概只有 70%。参数 -XX:CMSInitiatingOccupancyFraction 用来配置这个比例，但它首先必须配置 -XX:+UseCMSInitiatingOccupancyOnly 参数。</p>
<p>-XX:+UseCMSInitiatingOccupancyOnly</p>
<ol start="3">
<li>TomcatConnector</li>
</ol>
<p><a href="https://tomcat.apache.org/tomcat-7.0-doc/config/http.html#Introduction">官网介绍</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8081&quot;</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">protocol</span>=<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">keepAliveTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">acceptorThreadCount</span>=<span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">maxThreads</span>=<span class="string">&quot;360&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">maxConnections</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">acceptCount</span>=<span class="string">&quot;200&quot;</span>       </span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8445&quot;</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">URIEncoding</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
 <Connector port="8081" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8445" URIEncoding="UTF-8" />
</blockquote>
<ul>
<li> protocol：</li>
</ul>
<p><em>一：BIO org.apache.coyote.http11.Http11Protocol - blocking Java connector</em> <br/><br><br/><br>一个线程处理一个请求。缺点：并发量高时，线程数较多，浪费资源。<br/><br>Tomcat7或以下，在Linux系统中默认使用这种方式。</p>
<p><em>二：NIO  org.apache.coyote.http11.Http11NioProtocol - non blocking Java connector</em><br/><br><br/><br>利用Java的异步IO处理，可以通过少量的线程处理大量的请求。<br/><br>Tomcat8在Linux系统中默认使用这种方式。<br/><br>Tomcat7必须修改Connector配置来启动：<br/><br><Connector port="8080" protocol="org.apache.coyote.http11.Http11NioProtocol" connectionTimeout="20000" redirectPort="8443"/> </p>
<p><em>三：APR org.apache.coyote.http11.Http11AprProtocol - the APR/native connector.</em><br/><br><br/><br>即Apache Portable Runtime，从操作系统层面解决io阻塞问题。<br/><br>Tomcat7或Tomcat8在Win7或以上的系统中启动默认使用这种方式。<br/><br>Linux如果安装了apr和native，Tomcat直接启动就支持apr。（安装方法：<a href="http://www.cnblogs.com/nb-blog/p/5278502.html%EF%BC%89">http://www.cnblogs.com/nb-blog/p/5278502.html）</a></p>
<ul>
<li><p>URIEncoding：<br/><br>This specifies the character encoding used to decode the URI bytes, after %xx decoding the URL. If not specified, ISO-8859-1 will be used.</p>
</li>
<li><p>acceptorThreadCount：<br/><br>用于接受连接的线程数。在多CPU的机器上增加这个值，虽然你永远不会真的需要超过2。此外，对于许多非保持活动状态的连接，您可能也想增加该值。默认值为1。</p>
</li>
</ul>
<ul>
<li><p>connectionLinger<br/><br>此连接器使用的套接字在关闭时停留的秒数。默认值为-1，表示禁用套接字逗留</p>
</li>
<li><p>connectionUploadTimeout<br/><br>指定数据上载过程中使用的超时时间(以毫秒为单位)。这仅在disableUploadTimeout设置为false时生效</p>
</li>
<li><p>disableUploadTimeout<br/><br>该标志允许servlet容器在数据上传期间使用不同的、通常更长的连接超时。如果未指定，此属性将设置为true，从而禁用更长的超时</p>
</li>
<li><p>keepAliveTimeout<br/><br>此连接器在关闭连接之前等待另一个HTTP请求的毫秒数。默认值是使用为connectionTimeout属性设置的值。使用值-1表示没有(即无限)超时</p>
</li>
<li><p>maxConnections<br/><br>服务器在任何给定时间接受和处理的最大连接数。当达到这个数目时，服务器将接受，但不处理，一个进一步的连接。这个额外的连接将被阻塞，直到被处理的连接数低于最大连接数，<br>此时服务器将再次开始接受和处理新的连接。请注意，一旦达到限制，操作系统可能仍然会根据acceptCount设置接受连接。默认值因连接器类型而异。<br>对于BIO，默认值是maxThreads的值，除非使用了执行器，在这种情况下，默认值将是来自执行器的maxThreads的值。对于NIO，默认值为10000。对于APR/native，默认值为8192。<br>仅对于NIO，将该值设置为-1将禁用maxConnections功能，并且不会计算连接数。</p>
</li>
<li><p>maxThreads<br/><br>此连接器要创建的最大请求处理线程数，因此决定了可以处理的最大并发请求数。如果未指定，该属性将设置为200。如果一个执行器与这个连接器相关联，那么这个属性将被忽略，<br>因为连接器将使用执行器而不是内部线程池来执行任务。<br>注意，如果配置了executor，为该属性设置的任何值都将被正确记录，但它将被报告(例如通过JMX)为-1，以表明它未被使用。</p>
</li>
<li><p>acceptCount<br/><br>当所有可能的请求处理线程都在使用中时，传入连接请求的最大队列长度。队列已满时收到的任何请求都将被拒绝。默认值为100</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
      </tags>
  </entry>
</search>
